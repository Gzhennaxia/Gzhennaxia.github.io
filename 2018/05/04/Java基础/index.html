<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "9cf29b7d"
    });
  daovoice('update');
  </script>




















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


  




  <meta name="description" content="面向对象重写和重载的区别为什么重写equals方法必须重写hashcode方法这是常规协定： 1. 两个对象的equals方法为true时，其hashcode值必须相同    2. hashcode值相同的两个对象，不要求其equals方法的返回值为true 因为像Set，HashMap等要求去重的结构中，如果使用自定义的类，如果不重写hashcode方法，纵然两个对象是等价的，也不能达到去重的效">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://yoursite.com/2018/05/04/Java基础/index.html">
<meta property="og:site_name" content="Gzhennaxia">
<meta property="og:description" content="面向对象重写和重载的区别为什么重写equals方法必须重写hashcode方法这是常规协定： 1. 两个对象的equals方法为true时，其hashcode值必须相同    2. hashcode值相同的两个对象，不要求其equals方法的返回值为true 因为像Set，HashMap等要求去重的结构中，如果使用自定义的类，如果不重写hashcode方法，纵然两个对象是等价的，也不能达到去重的效">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdn.net/20180413174328748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JfZXZhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20161205160942891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004734695-988542448.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1525453070093&di=ef28b6f2d34adc2e6eebbeded78ef13c&imgtype=0&src=http%3A%2F%2Fwww.zhaolongedu.com%2Fuploads%2Fallimg%2F180103%2F1-1P103094552640.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20160506145211579">
<meta property="og:updated_time" content="2018-05-24T01:00:32.449Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java基础">
<meta name="twitter:description" content="面向对象重写和重载的区别为什么重写equals方法必须重写hashcode方法这是常规协定： 1. 两个对象的equals方法为true时，其hashcode值必须相同    2. hashcode值相同的两个对象，不要求其equals方法的返回值为true 因为像Set，HashMap等要求去重的结构中，如果使用自定义的类，如果不重写hashcode方法，纵然两个对象是等价的，也不能达到去重的效">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180413174328748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JfZXZhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">






  <link rel="canonical" href="http://yoursite.com/2018/05/04/Java基础/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java基础 | Gzhennaxia</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gzhennaxia</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朕">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gzhennaxia">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java基础
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-04 10:41:58" itemprop="dateCreated datePublished" datetime="2018-05-04T10:41:58+08:00">2018-05-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-24 09:00:32" itemprop="dateModified" datetime="2018-05-24T09:00:32+08:00">2018-05-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java基础/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><h1 id="为什么重写equals方法必须重写hashcode方法"><a href="#为什么重写equals方法必须重写hashcode方法" class="headerlink" title="为什么重写equals方法必须重写hashcode方法"></a>为什么重写equals方法必须重写hashcode方法</h1><p>这是常规协定：</p>
<pre><code>1. 两个对象的equals方法为true时，其hashcode值必须相同
   2. hashcode值相同的两个对象，不要求其equals方法的返回值为true
</code></pre><p>因为像Set，HashMap等要求去重的结构中，如果使用自定义的类，如果不重写hashcode方法，纵然两个对象是等价的，也不能达到去重的效果，因为Object的hashcode返回的一般是对象的地址。Object的equals方法比较的也是两个对象的地址。</p>
<h1 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h1><blockquote>
<p><a href="http://www.cnblogs.com/Blogyin/p/7809382.html" target="_blank" rel="noopener">JAVA类的加载、连接与初始化</a> </p>
</blockquote>
<p>类的生命周期总共分为5个步骤：加载—&gt;连接（验证+准备+解析）—&gt;初始化—&gt;使用—&gt;卸载</p>
<ol>
<li>类的加载是指把.class文件中的二进制数据读入到内存中，把他放在方法区内，然后在堆里创建一个Class的对象，用来封装类在方法区内的数据结构  </li>
</ol>
<h2 id="Java程序的初始化顺序"><a href="#Java程序的初始化顺序" class="headerlink" title="Java程序的初始化顺序"></a>Java程序的初始化顺序</h2><p>父类静态变量—父类静态代码块—子类静态变量—子类静态代码块—父类非静态变量—父类非静态变量代码块—父类构造函数—子类非静态变量—子类非静态代码块—子类构造函数</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><ol>
<li>” ” 引号创建的字符串在常量池中</li>
<li>new，new创建字符串时首先查看池中是否有相同值的字符串，如果有，则拷贝一份到堆中，然后返回堆中的地址；如果池中没有，则在堆中创建一份，然后返回堆中的地址（注意，此时不需要从堆中复制到池中，否则导致浪费池的空间）</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180413174328748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JfZXZhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<h2 id="java-lang-不用import"><a href="#java-lang-不用import" class="headerlink" title="java.lang - 不用import"></a><a href="http://www.cnblogs.com/zedosu/p/6518124.html" target="_blank" rel="noopener">java.lang - 不用import</a></h2><p>java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。 它被自动引入每个java程序，所以不必import 。</p>
<h2 id="String字符串拼接符-“-”底层原理"><a href="#String字符串拼接符-“-”底层原理" class="headerlink" title="String字符串拼接符 “+”底层原理 "></a><a href="https://blog.csdn.net/z55887/article/details/52473204" target="_blank" rel="noopener">String字符串拼接符 “+”底层原理 </a></h2><p><code>String d &quot;hell&quot;+&quot;o&quot;</code>在编译时就已经把d当成了hello,指向的是字符串常量池中的对象 </p>
<p><code>String c=b+&quot;o&quot;</code>和<code>b+new String(&quot;o&quot;)</code>，<strong>只要字符串拼接中有对象时，就会创建StringBuilder对象，然后用append方法拼接，最后调用StringBuilder的toString方法返回一个重新创建的字符串</strong>。 </p>
<p>当大量拼接字符串时，<code>+</code>会循环创建<code>StringBuilder</code>类 </p>
<h2 id="Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="Java中的String，StringBuilder，StringBuffer三者的区别"></a><a href="http://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">Java中的String，StringBuilder，StringBuffer三者的区别</a></h2><h3 id="总的区别"><a href="#总的区别" class="headerlink" title="总的区别"></a>总的区别</h3><p><strong>String 字符串常量</strong></p>
<p>因为<strong>String类没有append()、delete()、insert()这三个成员方法</strong>，而StringBuffer和StringBuilder都有这些方法；并不是因为它是被final修饰的，StringBuffer和StringBuilder也是被final修饰的。</p>
<p><strong>StringBuffer 字符串变量（线程安全）</strong></p>
<p>因为StringBuffer类中的大部分成员方法都被synchronized关键字修饰，而StringBuilder类没有出现synchronized关键字；</p>
<p>至于StringBuffer类中那些没有用synchronized修饰的成员方法，如insert()、indexOf()等，通过源码上的注释可以知道，它们是调用StringBuffer类的其他方法来实现同步的。注意：toString()方法也是被synchronized关键字修饰的。 </p>
<p><strong>StringBuilder 字符串变量（非线程安全）</strong> </p>
<h3 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h3><p><strong>StringBuilder &gt; StringBuffer &gt; String</strong> </p>
<p><strong>String &lt; StringBuffer：</strong> 这是因为String类是不可变的，即字符串常量，所以每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。</p>
<p><strong>StringBuffer &lt; StringBuilder：</strong></p>
<p>因为StringBuffer线程安全的特性，常常应用于多线程的程序中，为了保证多线程同步一些线程就会遇到阻塞的情况，这就使得StringBuffer的运行时间增加，从而使得运行速度减慢；而StringBuilder通常不会出现多线程的情况，所以运行时就不会被阻塞，运行速度也自然就比StringBuffer快了。 </p>
<h3 id="项目中具体在哪里用到的"><a href="#项目中具体在哪里用到的" class="headerlink" title="项目中具体在哪里用到的"></a>项目中具体在哪里用到的</h3><p><strong>1.如果要操作少量的数据用 String</strong></p>
<p>​    非循环</p>
<p><strong>2.单线程操作字符串缓冲区下操作大量数据 StringBuilder</strong></p>
<p>​    一般在转换成字符串作为输出的方法里常用，例如tostring方法，jdk的ArrayList和LinkedList的tostring方法用的就是StringBuilder进行拼接操作的。</p>
<p>​    在循环中拼接字符串时应该主动使用，否则jvm会循环创建StringBuilder来进行拼接。</p>
<p><strong>3.多线程操作字符串缓冲区下操作大量数据 StringBuffer</strong></p>
<p>​    几乎用不到</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><blockquote>
<p><a href="https://blog.csdn.net/lfh15732626246/article/details/53466339" target="_blank" rel="noopener">几种常用的IO流</a></p>
<p><a href="https://blog.csdn.net/baidu_37107022/article/details/76890019" target="_blank" rel="noopener">java IO流面试总结 </a></p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20161205160942891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="IO流"></p>
<h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><p>Java中的流是对<strong>字节序列</strong>的抽象，我们可以想象有一个水管，只不过现在流动在水管中的不再是水，而是字节序列。和水流一样，Java中的流也具有一个“流动的方向”，通常可以从中读入一个字节序列的对象被称为输入流；能够向其写入一个字节序列的对象被称为输出流。</p>
<h2 id="输入输出流的方法"><a href="#输入输出流的方法" class="headerlink" title="输入输出流的方法"></a>输入输出流的方法</h2><p><strong>InputStream里的read()返回的是什么,read(byte[] data)是什么意思,返回的是什么值</strong></p>
<p>​    <strong>read返回的是所读取的字节的int型（范围0-255）</strong></p>
<p>​    <strong>read（byte [ ] data）将读取的字节储存在这个数组，返回的就是传入数组参数个数</strong></p>
<p>​    <strong>Read  字节读取字节  字符读取字符</strong></p>
<p><strong>OutputStream里面的write()是什么意思,write(byte b[], int off, int len)这个方法里面的三个参数分别是什么意思</strong></p>
<p>​    <strong>write将指定字节传入数据源</strong></p>
<p>​    <strong>Byte b[ ]是byte数组</strong></p>
<p>​    <strong>b[off]是传入的第一个字符</strong></p>
<p>​    <strong>b[off+len-1]是传入的最后的一个字符 </strong></p>
<p>​    <strong>len是实际长度</strong></p>
<h2 id="流的关闭的注意事项"><a href="#流的关闭的注意事项" class="headerlink" title="流的关闭的注意事项"></a>流的关闭的注意事项</h2><p><strong>多个流互相调用只关闭最外层的流</strong> </p>
<p><strong>流一旦打开就必须关闭，使用close方法</strong></p>
<p><strong>放入finally语句块中（finally 语句一定会执行）</strong> </p>
<h2 id="字符流与字节流的区别"><a href="#字符流与字节流的区别" class="headerlink" title="字符流与字节流的区别"></a>字符流与字节流的区别</h2><ul>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元（大小2字节） </li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
</ul>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>InputSreamReader用于将一个字节流中的字节解码成字符</p>
<p>OutputStream用于将写入的字符编码成字节后写入一个字节流</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>默认缓冲区大小8192字节。 </p>
<p>常用方法：</p>
<ul>
<li>readLine()； BufferedReader流读取文本行</li>
<li>write(String s,int off,int len)；  BufferedWriter流把字符串s写到文件中</li>
<li>newLine();  BufferedWriter流向文件写入一个回行符</li>
</ul>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p><strong>Printwriter 可以打印各种数据类型</strong> </p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004734695-988542448.png" alt="集合框架体系图"></p>
<blockquote>
<p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7760248.html" target="_blank" rel="noopener">Java中各种集合（字符串类）的线程安全性</a></p>
</blockquote>
<h2 id="Collection与Collections的区别"><a href="#Collection与Collections的区别" class="headerlink" title="Collection与Collections的区别"></a>Collection与Collections的区别</h2><p><strong>java.util.Collection 是一个集合接口。</strong> </p>
<p><strong>java.util.Collections 是一个包装类。</strong> 是一个工具类，用于服务Collection的（例如排序，线程安全化等）。</p>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><p>主要有<strong><em>4个（前4个）</em></strong>：</p>
<ol>
<li>HashMap允许空键值（key=null）和空值（value=null），HashTable不支持空键值和空值。</li>
<li>HashMap继承自AbstractMap，HashTable继承自Dictionary。</li>
<li>HasMap去掉了HashTable的contains方法，因为contains方法和containsValue方法一摸一样。</li>
<li>HashMap线程不安全，HashTable线程安全。</li>
<li>HashMap采用快速失败机制（多线程情况下，若一个线程在另一个线程正在读的时候修改的话就会抛出<code>ConcurrentModificationException</code>从而产生fail-fast事件）</li>
</ol>
<h2 id="HashMap与ConcurrentHashMap的区别"><a href="#HashMap与ConcurrentHashMap的区别" class="headerlink" title="HashMap与ConcurrentHashMap的区别"></a>HashMap与ConcurrentHashMap的区别</h2><p>ConcurrentHashMap是线程安全的。它只会锁操作的那一段数据而不是整个<code>Map</code>都上锁。 </p>
<h2 id="如何实现HashMap的同步化"><a href="#如何实现HashMap的同步化" class="headerlink" title="如何实现HashMap的同步化"></a>如何实现HashMap的同步化</h2><p>HashMap可以通过<code>Map m = Collections.synchronizedMap(new HashMap())</code>来达到同步的效果。</p>
<p>该方法返回一个同步的Map，该Map封装了底层的HashMap的所有方法，使得底层的HashMap即使在多线程环境下也是安全的。</p>
<h2 id="ArrayList、Vector和LinkedList的区别"><a href="#ArrayList、Vector和LinkedList的区别" class="headerlink" title="ArrayList、Vector和LinkedList的区别"></a>ArrayList、Vector和LinkedList的区别</h2><ol>
<li>ArrayList和LinkedList都是线程不安全的，而Vector是线程安全的。</li>
<li>Vector默认扩容为原来的两倍（可以设置扩充容量的大小），ArrayList默认扩容为原来的1.5倍（没有设置空间扩充的方法）</li>
<li>LinkedList采用双向列表实现。ArrayList是基于动态数组的。</li>
<li>ArrayList查找效率高，LinkedList插入删除效率高。</li>
</ol>
<h2 id="HashMap的底层实现原理"><a href="#HashMap的底层实现原理" class="headerlink" title="HashMap的底层实现原理"></a>HashMap的底层实现原理</h2><blockquote>
<p><a href="https://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">HashMap实现原理分析 </a></p>
<p><a href="https://blog.csdn.net/ghsau/article/details/16890151" target="_blank" rel="noopener">HashMap深度解析(二) </a></p>
</blockquote>
<h3 id="为什么HashMap中哈希表的容量必须为2的n次幂？"><a href="#为什么HashMap中哈希表的容量必须为2的n次幂？" class="headerlink" title="为什么HashMap中哈希表的容量必须为2的n次幂？"></a>为什么HashMap中哈希表的容量必须为2的n次幂？</h3><p><strong>当容量是2^n时，h &amp; (length - 1) == h % length</strong>，它俩是等价不等效的，位运算效率非常高</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p><strong>对象序列化，将对象以二进制的形式保存在硬盘上反序列化；</strong></p>
<p><strong>将二进制的文件转化为对象读取实现serializable接口</strong></p>
<p>不想让字段放在硬盘上就加transient</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p><a href="https://www.cnblogs.com/jijijiefang/articles/7222955.html" target="_blank" rel="noopener">线程的几种状态转换</a></p>
<p><a href="https://blog.csdn.net/pange1991/article/details/53860651" target="_blank" rel="noopener">Java线程的5种状态及切换(透彻讲解) </a></p>
</blockquote>
<p><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt=""></p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是操作系统能够进行运算调度的最小单位</p>
<h2 id="Java中实现线程"><a href="#Java中实现线程" class="headerlink" title="Java中实现线程"></a>Java中实现线程</h2><ol>
<li>继承Thread</li>
<li>实现Runable接口（推荐使用，因为Java单继承耽误继承别的类）</li>
</ol>
<p>Java不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p>
<h2 id="Thread-类中的start-和-run-方法"><a href="#Thread-类中的start-和-run-方法" class="headerlink" title="Thread 类中的start() 和 run() 方法"></a>Thread 类中的start() 和 run() 方法</h2><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。 </p>
<h2 id="几个常用方法的比较"><a href="#几个常用方法的比较" class="headerlink" title="几个常用方法的比较"></a>几个常用方法的比较</h2><ol>
<li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。</li>
<li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</li>
<li>t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。</li>
<li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。</li>
<li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li>
</ol>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="线程安全问题的产生原因："><a href="#线程安全问题的产生原因：" class="headerlink" title="线程安全问题的产生原因："></a>线程安全问题的产生原因：</h3><p>​    A：是否是多线程环境</p>
<p>​    B：是否有共享数据</p>
<p>​    C：是否有多条语句操作共享数据</p>
<h3 id="多线程安全问题解决"><a href="#多线程安全问题解决" class="headerlink" title="多线程安全问题解决"></a>多线程安全问题解决</h3><p>加锁</p>
<h3 id="同步方法上的锁"><a href="#同步方法上的锁" class="headerlink" title="同步方法上的锁"></a>同步方法上的锁</h3><p>　　同步代码块使用的锁是任意对象（由使用者自己来手动的指定）。</p>
<p>　　非静态的方法上加的同步使用的锁是当前对象（当前调用这个方法的那个对象）。</p>
<p>　　静态方法上使用的锁是当前的class文件（当前这个方法所属的class文件）。</p>
<h3 id="synchronize与lock的区别"><a href="#synchronize与lock的区别" class="headerlink" title="synchronize与lock的区别"></a>synchronize与lock的区别</h3><table>
<thead>
<tr>
<th>类别</th>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>存在层次</td>
<td>Java的关键字，在jvm层面上</td>
<td>是一个类</td>
</tr>
<tr>
<td>锁的释放</td>
<td>1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁</td>
<td>在finally中必须释放锁，不然容易造成线程死锁</td>
</tr>
<tr>
<td>锁的获取</td>
<td>假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td>
<td>分情况而定，Lock有多个锁获取的方式，大致就是可以尝试获得锁，线程可以不用一直等待</td>
</tr>
<tr>
<td>锁状态</td>
<td>无法判断</td>
<td>可以判断</td>
</tr>
<tr>
<td>锁类型</td>
<td>可重入 不可中断 非公平</td>
<td>可重入 可判断 可公平（两者皆可）</td>
</tr>
<tr>
<td>性能</td>
<td>少量同步</td>
<td>大量同步</td>
</tr>
</tbody>
</table>
<h3 id="终止线程执行的两种方法"><a href="#终止线程执行的两种方法" class="headerlink" title="终止线程执行的两种方法"></a><a href="http://www.cnblogs.com/wsw-tcsygrwfqd/p/4989991.html" target="_blank" rel="noopener">终止线程执行的两种方法</a></h3><p>思路：在run方法里加一个while（flag）</p>
<h3 id="Java中各种集合（字符串类）的线程安全性"><a href="#Java中各种集合（字符串类）的线程安全性" class="headerlink" title="Java中各种集合（字符串类）的线程安全性"></a><a href="https://www.cnblogs.com/yjd_hycf_space/p/7760248.html" target="_blank" rel="noopener">Java中各种集合（字符串类）的线程安全性</a></h3><h3 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h3><p>①newSingleThreadExecutor</p>
<p>单个线程的线程池，即线程池中每次只有一个线程工作，单线程串行执行任务</p>
<p>②newFixedThreadExecutor(n)</p>
<p>固定数量的线程池，每提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列直到前面的任务完成才继续执行</p>
<p>③newCacheThreadExecutor（推荐使用）</p>
<p>可缓存线程池，<strong>当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程</strong>，当有任务来时，又智能的添加新线程来执行。</p>
<p>④newScheduleThreadExecutor</p>
<p>大小无限制的线程池，支持定时和周期性的执行线程</p>
<h3 id="有三个线程名字分别是A、B、C-每个线程只能打印自己的名字-在屏幕上顺序打印-ABC，打印10次"><a href="#有三个线程名字分别是A、B、C-每个线程只能打印自己的名字-在屏幕上顺序打印-ABC，打印10次" class="headerlink" title="有三个线程名字分别是A、B、C,每个线程只能打印自己的名字,在屏幕上顺序打印 ABC，打印10次"></a>有三个线程名字分别是A、B、C,每个线程只能打印自己的名字,在屏幕上顺序打印 ABC，打印10次</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzhennaxia;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 有三个线程名字分别是A、B、C,每个线程只能打印自己的名字,在屏幕上顺序打印 ABC，打印10次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LiBo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/5/5下午 04:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String currentThread = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThread</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentThread.equals(<span class="keyword">this</span>.getName())) &#123;</span><br><span class="line">                    System.out.print(<span class="keyword">this</span>.getName());</span><br><span class="line">                    count--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"A"</span>.equals(currentThread)) &#123;</span><br><span class="line">                        currentThread = <span class="string">"B"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"B"</span>.equals(currentThread)) &#123;</span><br><span class="line">                        currentThread = <span class="string">"C"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"C"</span>.equals(currentThread)) &#123;</span><br><span class="line">                        currentThread = <span class="string">"A"</span>;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MultiThread(<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MultiThread(<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MultiThread(<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Synchronized的用法"><a href="#Synchronized的用法" class="headerlink" title="Synchronized的用法"></a><a href="https://blog.csdn.net/luoweifu/article/details/46613015#t0" target="_blank" rel="noopener">Synchronized的用法</a></h2><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：  </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；  </li>
<li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 </li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote>
<p><a href="http://www.codeceo.com/article/thread-safe.html" target="_blank" rel="noopener">从 JVM 内存模型谈线程安全</a></p>
</blockquote>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><blockquote>
<p><a href="http://gityuan.com/2016/01/09/java-memory/" target="_blank" rel="noopener">http://gityuan.com/2016/01/09/java-memory/</a></p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E4%BA%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E4%BA%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86</a></p>
</blockquote>
<p>Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： </p>
<ol>
<li>程序计数器 </li>
<li>Java虚拟机栈 </li>
<li>本地方法栈 </li>
<li>堆 </li>
<li>方法区</li>
</ol>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525453070093&amp;di=ef28b6f2d34adc2e6eebbeded78ef13c&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.zhaolongedu.com%2Fuploads%2Fallimg%2F180103%2F1-1P103094552640.jpg" alt="Java虚拟机内存模型"></p>
<ol>
<li><p>程序计数器的特点</p>
<ol>
<li>是一块较小的存储空间</li>
<li>线程私有。每个线程都有一个程序计数器。</li>
<li>是唯一一个不会出现OutOfMemoryError的内存区域。</li>
<li>生命周期随着线程的创建而创建，随着线程的结束而死亡。</li>
</ol>
</li>
<li><p>Java虚拟机栈</p>
<ol>
<li>当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，<strong><em>栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等</em></strong></li>
<li>Java虚拟机栈是由一个个栈帧组成</li>
<li>Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。<br>a) StackOverFlowError：<br>若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。<br>b) OutOfMemoryError：<br>若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常</li>
</ol>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。</p>
</li>
<li><p>堆</p>
<ol>
<li>堆是用来存放对象的内存空间</li>
<li>堆的特点<ol>
<li>线程共享<br>整个Java虚拟机只有一个堆，所有的线程都访问同一个堆</li>
<li>在虚拟机启动时创建</li>
<li>垃圾回收的主要场所。</li>
<li>可以进一步细分为：新生代、老年代。<br>新生代又可被分为：Eden、From Survior、To Survior。<br>不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。</li>
<li>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。</li>
</ol>
</li>
</ol>
</li>
<li><p>方法区</p>
<ol>
<li><p>Java虚拟机规范中定义方法区是堆的一个逻辑部分</p>
</li>
<li><p><strong><em>方法区中存放三种数据：类信息、常量、静态变量</em></strong></p>
</li>
<li><p>方法区特点</p>
<ol>
<li><p>线程共享<br>方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。<strong>整个虚拟机中只有一个方法区</strong>。</p>
</li>
<li><p>永久代<br>方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。</p>
</li>
<li><p>内存回收效率低<br>方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。</p>
<p>对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。</p>
</li>
<li><p>Java虚拟机规范对方法区的要求比较宽松。<br>和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 </p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h2><blockquote>
<p><a href="http://www.cnblogs.com/andy-zcx/p/5522836.html" target="_blank" rel="noopener">深入理解 Java 垃圾回收机制</a></p>
</blockquote>
<ol>
<li><p>判断一个对象是否可回收</p>
<ol>
<li><p>引用计数法</p>
</li>
<li><p>可达性（根搜索算法）</p>
<p>java中可作为GC Root的对象有</p>
<ol>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象（Native对象）</li>
</ol>
</li>
</ol>
</li>
<li><p>垃圾回收算法</p>
<ol>
<li>标记-清除法</li>
<li>标记-整理法</li>
<li>复制</li>
</ol>
</li>
<li><p>分代收集</p>
<ol>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清理 或者 标记 - 整理 算法</li>
</ol>
</li>
</ol>
<h2 id="Java中类及方法的加载顺序"><a href="#Java中类及方法的加载顺序" class="headerlink" title="Java中类及方法的加载顺序"></a>Java中类及方法的加载顺序</h2><p><img src="https://img-blog.csdn.net/20160506145211579" alt=""></p>

      
    </div>

    

    
    
    

    

    

    

	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>
	
    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/03/Java后台开发技能清单/" rel="next" title="Java后台开发技能清单">
                <i class="fa fa-chevron-left"></i> Java后台开发技能清单
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/04/笔试问答/" rel="prev" title="笔试问答">
                笔试问答 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="朕" />
            
              <p class="site-author-name" itemprop="name">朕</p>
              <p class="site-description motion-element" itemprop="description">我不怕千万人阻挡，只怕自己投降</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Gzhennaxia" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-number">1.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重写和重载的区别"><span class="nav-number">1.1.</span> <span class="nav-text">重写和重载的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么重写equals方法必须重写hashcode方法"><span class="nav-number">2.</span> <span class="nav-text">为什么重写equals方法必须重写hashcode方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类的加载、连接与初始化"><span class="nav-number">3.</span> <span class="nav-text">类的加载、连接与初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java程序的初始化顺序"><span class="nav-number">3.1.</span> <span class="nav-text">Java程序的初始化顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的创建"><span class="nav-number">4.1.</span> <span class="nav-text">字符串的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-不用import"><span class="nav-number">4.2.</span> <span class="nav-text">java.lang - 不用import</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String字符串拼接符-“-”底层原理"><span class="nav-number">4.3.</span> <span class="nav-text">String字符串拼接符 “+”底层原理 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的String，StringBuilder，StringBuffer三者的区别"><span class="nav-number">4.4.</span> <span class="nav-text">Java中的String，StringBuilder，StringBuffer三者的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总的区别"><span class="nav-number">4.4.1.</span> <span class="nav-text">总的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行速度"><span class="nav-number">4.4.2.</span> <span class="nav-text">执行速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目中具体在哪里用到的"><span class="nav-number">4.4.3.</span> <span class="nav-text">项目中具体在哪里用到的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO流"><span class="nav-number">5.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是流"><span class="nav-number">5.1.</span> <span class="nav-text">什么是流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出流的方法"><span class="nav-number">5.2.</span> <span class="nav-text">输入输出流的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流的关闭的注意事项"><span class="nav-number">5.3.</span> <span class="nav-text">流的关闭的注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符流与字节流的区别"><span class="nav-number">5.4.</span> <span class="nav-text">字符流与字节流的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转换流"><span class="nav-number">5.5.</span> <span class="nav-text">转换流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲流"><span class="nav-number">5.6.</span> <span class="nav-text">缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印流"><span class="nav-number">5.7.</span> <span class="nav-text">打印流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-number">6.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection与Collections的区别"><span class="nav-number">6.1.</span> <span class="nav-text">Collection与Collections的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap与HashTable的区别"><span class="nav-number">6.2.</span> <span class="nav-text">HashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap与ConcurrentHashMap的区别"><span class="nav-number">6.3.</span> <span class="nav-text">HashMap与ConcurrentHashMap的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现HashMap的同步化"><span class="nav-number">6.4.</span> <span class="nav-text">如何实现HashMap的同步化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList、Vector和LinkedList的区别"><span class="nav-number">6.5.</span> <span class="nav-text">ArrayList、Vector和LinkedList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap的底层实现原理"><span class="nav-number">6.6.</span> <span class="nav-text">HashMap的底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么HashMap中哈希表的容量必须为2的n次幂？"><span class="nav-number">6.6.1.</span> <span class="nav-text">为什么HashMap中哈希表的容量必须为2的n次幂？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化"><span class="nav-number">7.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">8.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程"><span class="nav-number">8.1.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中实现线程"><span class="nav-number">8.2.</span> <span class="nav-text">Java中实现线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-类中的start-和-run-方法"><span class="nav-number">8.3.</span> <span class="nav-text">Thread 类中的start() 和 run() 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个常用方法的比较"><span class="nav-number">8.4.</span> <span class="nav-text">几个常用方法的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全问题"><span class="nav-number">8.5.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全问题的产生原因："><span class="nav-number">8.5.1.</span> <span class="nav-text">线程安全问题的产生原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程安全问题解决"><span class="nav-number">8.5.2.</span> <span class="nav-text">多线程安全问题解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步方法上的锁"><span class="nav-number">8.5.3.</span> <span class="nav-text">同步方法上的锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronize与lock的区别"><span class="nav-number">8.5.4.</span> <span class="nav-text">synchronize与lock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终止线程执行的两种方法"><span class="nav-number">8.5.5.</span> <span class="nav-text">终止线程执行的两种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中各种集合（字符串类）的线程安全性"><span class="nav-number">8.5.6.</span> <span class="nav-text">Java中各种集合（字符串类）的线程安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见线程池"><span class="nav-number">8.5.7.</span> <span class="nav-text">常见线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有三个线程名字分别是A、B、C-每个线程只能打印自己的名字-在屏幕上顺序打印-ABC，打印10次"><span class="nav-number">8.5.8.</span> <span class="nav-text">有三个线程名字分别是A、B、C,每个线程只能打印自己的名字,在屏幕上顺序打印 ABC，打印10次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized的用法"><span class="nav-number">8.6.</span> <span class="nav-text">Synchronized的用法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">9.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存模型"><span class="nav-number">9.1.</span> <span class="nav-text">JVM内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的垃圾回收机制"><span class="nav-number">9.2.</span> <span class="nav-text">Java的垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中类及方法的加载顺序"><span class="nav-number">9.3.</span> <span class="nav-text">Java中类及方法的加载顺序</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朕</span>

  

  
</div>



<div class="powered-by">
	<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
	  本站访客数:<span id="busuanzi_value_site_pv"></span> |
	</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">| 博客全站共45.9k字</span>
</div>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
