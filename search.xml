<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F02%2F03%2FGit%2F</url>
    <content type="text"><![CDATA[Pro Git 下载官网 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。推荐从 Git for Windows 国内下载站 下载。 安装根据安装程序一步步安装即可。 注意一下几个地方： Adjusting your PATH environment 勾选第一个选项：Use Git from Git Bash only 因为这种方式最安全。 Choosing HTTPS transport backend 勾选第一个选项：Use the OpenSSL library Configuring the terminal emulator to use with Git Bash 勾选第一个选项：Use MinTTY 其他的配置使用默认的即可。 配置 初次运行 Git 前的配置 常用命令克隆指定分支git clone -b branch_name repo_url 克隆到指定目录git clone repo_url dir_path]]></content>
      <categories>
        <category>Version Control</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F03%2FPrepare-for-spring-travel%2F</url>
    <content type="text"><![CDATA[衣食住行]]></content>
  </entry>
  <entry>
    <title><![CDATA[Software and Tools]]></title>
    <url>%2F2019%2F02%2F03%2FSoftware%20and%20Tools%2F</url>
    <content type="text"><![CDATA[Listary 一款非常强大的搜索软件 配置百度翻译设置&gt;关键字&gt;+ GUN Wget Wget for windows——优雅地实现批量下载 在线验证 yaml 格式YAML Lint 虚拟机 VMware Workstation 15 Pro+Key MySQL图形化工具 Webyog Sqlyog Ultimate_12.5.1官方最新版附注册码 XShell Xshell 6 (SSH远程终端工具) 6.0 绿色中文注册授权激活版 中文官网 maven maven下载和安装 Lombok Lombok 看这篇就够了 PDF 阅读器 sumatrapdf PotPlayer Potplayer 快捷键 视频播放器。强大的内置解码器，强大的定制能力和个性化功能。 Chrome插件Clear CacheClear your cache and browsing data with a single click of a button. SMMS 一个简单实用的图床插件 Vimium 像黑客一样！Chrome 完全键盘操作指南（原生快捷键 + Vimium 插件） Octotree 强力推荐！那些你不能错过的 GitHub 插件和工具 Save to Pocket The best way to save articles, videos and more]]></content>
      <categories>
        <category>Software</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows]]></title>
    <url>%2F2019%2F02%2F03%2FWindows%2F</url>
    <content type="text"><![CDATA[激活 win10专业版激活方法——亲测可行！！！ 快捷键Win + L：锁屏 Shift + F10：相当于鼠标右键 快速打开控制面板 Win + R 输入control.exe 回车 系统属性 Win + R 输入sysdm.cpl 回车 计算器 Win + R` 输入cacl 回车 服务 Win + R` 输入services.msc 回车 当前目录下打开控制台直接在当前目录栏中输入cmd，然后回车即可。 自动隐藏任务栏设置&gt;任务栏&gt;勾选自动隐藏任务栏]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages+Hexo+NexT]]></title>
    <url>%2F2019%2F02%2F03%2FGitHub%20Pages%2BHexo%2BNexT%2F</url>
    <content type="text"><![CDATA[环境： node.js 10.14.2 npm 6.4.1 hexo 3.8.0 NexT 6.6.0 Hexo常用命令 Hexo 最常用的几个命令 Hexo命令速记 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -s NexT 主题的使用 hexo-theme-next Theme NexT 推荐新入坑的兄弟使用第一种方式来获取NexT主题。 主题配置文件Data Files 为了以后平滑升级，使用Hexo3.0的Data Files方式 NexT-Way 在hexo/source/_data目录（没有的话新建一个）下新建next.yml文件。 把主题配置文件中的选项全部 copy 到next.yml中。 在next.yml文件中设置override选项为true。 在站点配置文件中修改theme选项为next 主题设置 开始使用 主题优化头像旋转 Hexo Next 头像圆形并旋转 注意stylus中文版参考文档之注释(Comments) 单行注释使用//,多行使用/* */ 修改/themes/next/source/css/_common/components/sidebar/sidebar-author.styl如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; opacity: hexo-config('avatar.opacity') is a 'unit' ? hexo-config('avatar.opacity') : 1; // 头像圆形样式 /* start */ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;if hexo-config('avatar.rounded') &#123;.site-author-image &#123; border-radius: 100%;&#125;&#125;if hexo-config('avatar.rotated') &#123;.site-author-image &#123; -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; -ms-transition: -ms-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;.site-author-image:hover &#123; -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); -ms-transform: rotate(360deg); transform: rotateZ(360deg);&#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125;// 头像旋转事件/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 文章底部带#号的标签 文章底部带#号的标签 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记 在每篇文章末尾统一添加“本文结束 在路径\themes\next\layout\_macro中新建passage-end-tag.swig文件,并添加以下内容： 12345&lt;div&gt;&#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;&#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout\_macro\post.swig文件，在END POST BLOCK之后， 添加以下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件next.yml,在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 主页文章加阴影 主页文章加阴影 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果.post &#123;margin-top: 60px;margin-bottom: 60px;padding: 25px;-webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);-moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 显示文章更新时间修改主题配置文件的 123post_meta: updated_at: enabled: true 要想具体显示到时分秒,则修改站点配置文件的 1date_format: YYYY-MM-DD HH:mm:ss 代码添加复制按钮 Hexo NexT主题代码块添加复制功能 下载clipboard.js 保存文件clipboard.min.js 到目录\themes\next\source\js\src 在.\themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 1234567891011121314151617/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document); 在.\themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在.\themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（&lt;/body&gt;）之前添加）： 123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 文章加密 hexo-blog-encrypt npm install --save hexo-blog-encrypt 在站点配置文件下添加如下配置： 12encrypt: enable: true 在需要加密的文章的头部添加上对应的字段，如 password, abstract, message 12345---password: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.--- 二次元看板娘 hexo-helper-live2d npm install --save hexo-helper-live2d npm install --save live2d-widget-model-wanko 向站点配置文件中添加如下配置： 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 注：在next.yml中配置时，width, height等参数不起作用。 加载条 Load bar at the top for NexT 将theme-next-pace克隆到本地一个空目录里。 删掉pace目录下的.git文件夹 将pace目录 copy 到themes/next/source/lib目录下 修改主题配置文件next.yml的pace属性值为true 显示文章浏览进度百分比在主题配置文件中修改属性sidebar下scrollpercent的值为true 文章预览在文章中使用截断标记&lt;!-- more --&gt;手动指定文章预览的内容。 评论系统Gitalk 在hexo next主题上使用gitalk Hexo NexT主题中集成gitalk评论系统 Click here to sign up for a new OAuth Application Application name： # 应用名称，随意，如gitalkHomepage URL： # 网站URL，如https://username.github.io,username是 GitHub 账户名Application description # 描述，随意，如Comment System for BlogAuthorization callback URL：# 网站URL，https://username.github.io,username是 GitHub 账户名 修改主题配置文件中的如下属性 1234567891011# Gitalk # Demo: https://gitalk.github.io# Reference: https://asdfv1929.github.io/2018/01/20/gitalk/, https://liujunzhou.cn/2018/8/10/gitalk-error/#moregitalk: enable: true github_id: username # Github repo owner repo: gitalk # Repository name to store issues. client_id: ****** # Github Application Client ID client_secret: ****** # Github Application Client Secret admin_user: gzhennaxia # GitHub repo owner and collaborators, only these guys can initialize github issues distraction_free_mode: true # Facebook-like distraction free mode Valine Comment Systems Valine Create an account or log into LeanCloud, and then click on the bottom left corner to create the application in dashboard. Go to the application you just created, select Settings -&gt; Apply Key in the lower left corner, and you will see your APP ID and APP Key. Set the value enable to true, add the obtained APP ID (appid) and APP Key (appkey), and edit other configurations in valine section in the theme config file as following: 1234567891011121314# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: ****** # your leancloud application appid appkey: ****** # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html Gitalk + Valine双评论系统在完成各自配置后对themes\next\layout\_partials\comments.swig做如下修改： Before 1234567&#123;% elseif theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt;&#123;% elseif theme.gitalk.enable %&#125; &lt;div id="gitalk-container"&gt; &lt;/div&gt; After 1234567&#123;% elseif theme.gitalk.enable %&#125; &lt;div id="gitalk-container"&gt; &lt;/div&gt; &#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125; &lt;div class="comments" id="comments"&gt; &lt;/div&gt; &#123;% endif %&#125; 自动部署 Continuous Integration 踩坑记录npm install warnings npm install warnings 12npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules/hexo-cli/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"linux","arch":"x64"&#125;) 解决方法忽略就好 Hexo g error1234567891011121314151617ERROR ENOENT: no such file or directory, open 'F:\Hexo\themes\next\layout\menu.swig'Error: ENOENT: no such file or directory, open 'F:\Hexo\themes\next\layout\menu.swig' at Object.openSync (fs.js:439:3) at Object.readFileSync (fs.js:344:35) at Object.ret.load (F:\Hexo\node_modules\swig-templates\lib\loaders\filesystem.js:59:15) at exports.Swig.compileFile (F:\Hexo\node_modules\swig-templates\lib\swig.js:740:31) at Object.eval [as tpl] (eval at precompile (F:\Hexo\node_modules\swig-templates\lib\swig.js:537:13), &lt;anonymous&gt;:7:18) at compiled (F:\Hexo\node_modules\swig-templates\lib\swig.js:664:18) at Theme._View.View._compiled.locals [as _compiled] (F:\Hexo\node_modules\hexo\lib\theme\view.js:125:48) at Theme._View.View.View.render (F:\Hexo\node_modules\hexo\lib\theme\view.js:30:15) at route.set (F:\Hexo\node_modules\hexo\lib\hexo\index.js:394:29) at tryCatcher (F:\Hexo\node_modules\bluebird\js\release\util.js:16:23) at F:\Hexo\node_modules\bluebird\js\release\method.js:15:34 at RouteStream._read (F:\Hexo\node_modules\hexo\lib\hexo\router.js:134:3) at RouteStream.Readable.read (_stream_readable.js:452:10) at resume_ (_stream_readable.js:899:12) at process._tickCallback (internal/process/next_tick.js:63:19) 场景再现从releases下载的 NexT 主题，然后再通过修改目录名为next的方式使用该主题的时候，生成文件的时候报的错。 报错原因未知 解决方法 Wget for windows——优雅地实现批量下载 换用命令行下载的方式就不会报这个错了。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Unique Pig]]></title>
    <url>%2F2019%2F02%2F03%2FA-Unique-Pig%2F</url>
    <content type="text"><![CDATA[感悟整体的感悟是我还没达到能读这类全都是观点堆积起来的书，太多理解不了的地方，很多书中涉及的东西都不了解，读不懂，所以现阶段不喜欢这类精选集的书，或者说还不适合读这类书。 作者王小波（1952-1997），生于北京，1984年赴美匹兹堡大学东亚研究中心求学，2年后获得硕士学位。1988年回国，先后在北京大学，中国人民大学任教。1992年9月辞去教职，做自由撰稿人。1997年4月11日病逝于北京，年仅45岁。 这本书里除了说那只猪的片段感觉挺有趣的，其他篇章基本全都是观点性的文章，比较严肃。这本书没发现他的有趣，真不该选这一本来作为我读他的第一本书。 摘录 知识另有一种作用，它可以使你生活在过去、未来和现在，使你的生活变得更充实、更有趣。 我已经四十岁了，除了这只猪，还没见过谁敢于如此无视对生活的设置。相反，我倒见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。因为这个原故，我一直怀念这只特立独行的猪。 什么叫失败？也许可以说，人去做一件事情，没有达到预期的目的，这就是失败。 只有那些安于自己限度之内的生活的人才总数“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。 明天，既不应是把日历翻过去就是的明天，但是，也不应当是日历翻不到的明天。 这个人的美酒佳肴，就是那个人的穿肠毒药。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The world owes you nothing]]></title>
    <url>%2F2019%2F01%2F27%2FThe-world-owes-you-nothing%2F</url>
    <content type="text"><![CDATA[感想总体的感觉是应该不会再读第二遍吧，主要是越来越排斥标题很吸睛的帖子或文章。可能是我先入为主了吧。 文章全部节选自作者公众号的文章，描述的都是当今社会上热点的话题，但都是描述，然后作者自己的感想，这类文章大多读完后只能是你赞同或反对作者的观点，如果反对的话可能更能促发深度思考些，但这本书带给我的启发性并不大，很多都是都知道的道理，虽然作者有一些角度还行，但像历史这种角度，不够深的话可能说服力确实不够。 有一个最讨厌的点是每篇文章都会抽出来一段乍一听很吸引人的句子放在开头，然后再文章中又出现，有的甚至出现好几次，读到的时候有点烦。 吸睛的文章堆砌成书真的不好，读着读着容易疲劳。 这本书没有我想摘录的句子，不指定为什么，提不起兴趣。 读到最后的后序时还好一些，作者显得还比较谦虚些的样子。我不希望我是这样的态度，我希望我能抱有“取其精华弃其糟粕”的态度来阅读。 作者慧超，本名吴会超。一名公关，【思维补丁】公众号作者。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alive]]></title>
    <url>%2F2019%2F01%2F22%2FAlive%2F</url>
    <content type="text"><![CDATA[简述作者余华，1960年出生于浙江杭州，后来随父母迁居海盐县。中学毕业后，因父母是医生，余华曾当过牙医，五年后弃医从文，从此开始文学创作生涯。 时代背景从国民党统治后期到解放战争、土改运动，再到大炼钢铁运动，自然灾害时期等。 感受最近看的几本书里最好的一本，感触良多，还特意把同名电影看了一遍。最后几十页是一口气全部读完的，停不下来，就一下子看完了。 记忆尤新的是作者在麦田新版自序里写他为何用第一人称的角度写。 《活着》里的福贵经历了多余常人的苦难，如果从旁观者的角度，福贵的一生除了苦难还是苦难，其他什么都没有；可是当福贵从自己的角度出发，来讲述自己的一生时，他苦难的经历里立刻充满了幸福和欢乐，他相信自己的妻子是世界上最好的妻子，他相信自己的子女也是世界上最好的子女，还有他的女婿他的外孙，还有那头也叫福贵的老牛，还有曾经一起生活过的朋友们，还有生活的点点滴滴…… 从第一人称的角度出发，能过感受到福贵在讲述自己的一生时的心态，传达出与自身命运握手言和的人生态度。 开始读的时候我一直以为余华就是那个收录民谣的知青，而福贵的一生是真真实实存在的，直到读到后序才看到说这是本小说，立刻开始佩服余华出色的文笔，竟能写的如此生动现实，有血有肉。 每当读到描述福贵又要失去一位亲人之前的那段氛围的时候就极度紧张，心里也在祈祷着不要再让福贵经历接下来的苦难了，看到福贵饱受离人之苦，几度欲哭无泪。 书中的福贵一家人每个都富有血肉，善良淳朴。忠贞的家珍，懂事的有庆，体贴的凤霞，憨厚的二喜，机灵的外孙。有这么一个温暖的家庭，虽然遭遇各种苦难，但处处都能体会到家庭的温暖，令人感动。 电影随故事情节有所改动，但主体方向一致。巩俐太美了，独属于那个年代女人的美。演员都是老戏骨，演技精湛，神态很契合小说中的人物形象。最难忘的是巩俐的美和那个插曲。 摘录 人是为了活着本身而活着的，而不是为了活着之外的任何事物而活着 为什么丑恶的事物总在身边，而美好的事物却远在海角 人类无法忍受太多的真实 他是那种能够看到自己过去模样的人，它可以准确地看到在积极年轻时走路的姿态，甚至可以看到自己是如何衰老的 只要人活得高兴，就 不怕穷 这下可得好好活了 一个人和他命运之间的友情，这是最为感人的友情，因为他们互相感激，同时也互相仇恨；他们谁也无法抛弃对方，同时谁也没有理由抱怨对方 生活时一个人对自己经历的感受，而幸存往往是旁观者对别人经历的看法 人的体验和欲望hi有想象和理解，会取消所有不同的界限，会让一个人从他人的经历里感受到自己的命运 生活是属于每个人自己的感受，不属于任何别人的看法 回想这个福贵时，时常觉得他不是一个小说中的人物，二十我生活中曾经出现过的一位朋友]]></content>
      <categories>
        <category>Rading</category>
      </categories>
      <tags>
        <tag>Rading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1027]]></title>
    <url>%2F2019%2F01%2F19%2FPAT-B1027%2F</url>
    <content type="text"><![CDATA[设 h 为三角形的高度 一个三角形需要 * 的个数 s = 1 + 3 + 5 + … + (2h -1) = 2h^2 一个沙漏需要 2h^2 - 1 个 * 将沙漏的输出看作一个二位数组 arr[2h-1][2h-1] 用两层for循环来打印，i为行下标，j为列下标。 则空格所再的点满足i &lt; j &amp;&amp; i + j &lt; 2h - 2 || i &gt; j &amp;&amp; i + j &gt; 2h -2 i = j 和 i + j = 2h - 2 以二位坐标轴显示就是以2h - 2为边长的正方形的两个对角线。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Miracles in Namiya General Store]]></title>
    <url>%2F2019%2F01%2F17%2FMiracles-in-Namiya-General-Store%2F</url>
    <content type="text"><![CDATA[感悟因为先看了电影，而且是中国版的，然后才看的书。有了先入为主的感觉，读的时候满脑子都是回顾电影的情节。读关于翔太，郭也，幸平他们三个在店里投信取信的时候有种侦探小说的紧张感，可能是因为读的时间刚好是在夜深人静或是黎明拂晓的缘故，气氛给的足。 有些小节会直接转换故事主角，以为排版出错了。读完后才知道一个个故事联系很紧密，通过解忧杂货店的时光穿梭情节让所有故事情节连接起来形成一个闭环。貌似所有这类小说或者电影都在努力将故事线连成环，目前不知道该怎么描述这种手法。 发现书与电影的好像有这样一个区别。电影的主角儿就是翔太，郭也，幸平；而看书的时候每切换一个故事就有每个故事的主角。可能是因为书上每个故事都会描写自己主角的心理活动，而电影转换场景后没有太多表现主角心里活动的情节。 每个故事都很温暖，对于任何问题，浪矢都认真的给出自己的回答。这种暖心的态度，让人觉得自己给浪矢写信也能得到这种温柔以对的态度。从大学时代就很想能交一个笔友之类的，就想在这个世界有一个只有通过文字交往的朋友，肆无忌惮的吐露心声。可是到现在也没能实现这个愿望，听朋友说有类网站好像就是能写信给全世界的人，但还没尝试过，挺想试一试的。 关于烦恼，每个人都有无情物尽的事值得烦恼，我也一样，但如果能有个智者给出解答是件多么幸福的事，或许能有个倾听的也是极其幸福的事。也如浪矢所言，每个咨询者其实都有自己的答案。关于烦恼的答案终究还是要通过自身的仔细思考来给出答案，倾听者可能是促使和帮助我们自己认真思考的人，不要随便的将烦恼抛到一边不理会，或许有些徒劳的烦恼应该被直接抛弃吧。 摘录 其实所有纠结做选择的人心里早就有了答案，咨询只是想得到内心所倾向的选择。最终的所谓命运 还是自己一步步走出来的。 人与人之间情断义绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。 人的心声是绝对不能无视的。 人与人之间的羁绊是何等脆弱。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Skin]]></title>
    <url>%2F2019%2F01%2F14%2FSkin%2F</url>
    <content type="text"><![CDATA[感受这是一本自传体散文集，讲述作者以往的经历。 苦难总是会感动人，想起同样的高中时期家里发生的变故，虽然没有像作者那样严重，但苦难本不应该拿来比较。没有真正的感同身受，每个人都经历着自己的苦难，我无法对他人的苦难做到“身历其境”的地步，也不奢求观客的“无微不至”。让我佩服的是哪些将苦难转化为动力的能力，每个人都有苦难，但不是每个人都有能力吸收苦难的力量，并转换为自身的能量。 但当总觉得作者在评论别人的时候给人一种对比的感觉，确实不是很舒服。每种生活方式可能都应该得到尊重，我不知道到底哪些东西可以对比，或许只有实物的对比会更加安心一些。 不过读书本该取其精华去其糟粕，奇怪的是精华，糟粕没有什么标准，因人而异。写写读后感也是简单的理一理思绪。 作者蔡崇达是个新闻行业从业者。 摘抄 我不相信成熟能让我们接受任何东西，成熟只是让我们更能自欺欺人。——文中引用他一个朋友的话 当你坐在一个人对面，听他开口说话，看得到各种复杂、精密的境况和命运，如何最终雕刻出这样的性格、思想、做法、长相，这才是理解。 路过我们生命的每个人，都参与了我们，并最终成了我们本身。 每个读者只能督导已然存在于他内心的东西。书籍只不过是一种光学仪器，帮助读者发现自己的内心。——马塞尔·普鲁斯特 有生命力的地方在于浑浊。 用想象喂大的过度膨胀的理想幻想。 最离奇的理想所需要的建筑素材就是一个个庸常而枯燥的努力。 梦想原来是卑微的执着。 不合时宜的东西，如果自己虚弱，终究会成为人们嘲笑的对象，但有力量了，或坚持久了，或许反而能成为众人追捧的魅力和个性。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use of PotPlayer]]></title>
    <url>%2F2019%2F01%2F10%2FUse-of-PotPlayer%2F</url>
    <content type="text"><![CDATA[快捷键 Ctrl + Enter 全屏拉伸]]></content>
      <categories>
        <category>Softs</category>
        <category>Video</category>
      </categories>
      <tags>
        <tag>PotPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[No Longer Human]]></title>
    <url>%2F2019%2F01%2F10%2FNo-Longer-Human%2F</url>
    <content type="text"><![CDATA[总体感想读完整本书，整体上有两个感觉。1. 太丧。2. 印刷质量真差。 无赖派大师，听起来很厉害的样子，我以为并不像字面那样负面，查了才知道，真的是很负能量的派别。 无赖派指的是太平洋战争结束后的一九四六年到一九四八年间活跃于日本文坛的一个重要作家流派。但是严格来讲，这一派的作家并没有像其它派别的作家那样组成文艺团体或出同人杂志，只是因为在社会秩序混乱和价值体系崩溃的战后那个特殊年代，他们的作品风格正好呈现出相同的特征和倾向，才被日本评论界和文学界统一冠上了无赖派的头衔。 所谓无赖派就是指作家有着反抗权威的意识，对生活采取自嘲和自虐的态度，专写病态和阴郁的东西，具有颓废倾向。 读完后简直了，真的是太自虐、病态、抑郁了。刚好开始看这本书的时候正碰上我最低谷的时候，感情的伤还未愈合，又新增考研二战失败的疤。看到一半就看不洗去了，也是这个月开始做新一年各种计划的时候，想硬着头皮把它快快读完算了。 查了历史背景后再反观本书，有增加了一份替活在战后混乱年代的人们感到悲哀的情绪。 文采上并不觉得有什么特别突出的地方，可能是因为在没有了解具体历史背景的情况下读的，所以没有仔细体会文字背后的深意。读完之后我甚至没有一句印象深刻的话，只留有一种极度颓废的感觉，再就别无其他了。 回过头再看的时候，发现书背面那些名家推荐的理由写的很中肯。 他的痛苦在于它用心看着漆黑的世界。 ——鲁迅 作者太宰治一生充满了传奇色彩，出身豪门，师从名师。五度自杀，四度殉情未遂，三十九岁时与最后一位情人投水自尽。极度的自尊心和容易受伤的感受性构成了太宰治一生的性格基调，这样的性格的确太过于纯粹和脆弱。 摘录 我不相信神的爱，只相信神的惩罚。 只是一切都将逝去。 回首往昔，我的人生充斥着耻辱。 生而为人，对不起 ——《二十世纪棋手》 就算可以相信地狱，也怎么也无法相信天国的存在。 所谓的世间，不就是个人吗？ 人是绝对不会服从于他人的。 我的不幸乃是一个人缺乏拒绝能力的不幸。 就像玩扑克牌一样，一旦把负的全都收齐了，也就变成了正的。 在行善时，必须随时心存歉意。因为没有什么比行善更刺伤人的了。——瓦莱里 人活在这世上，真是件不容易的事，到处都有枷锁来束缚住你，哪怕是稍微动一下，也会冒出血来。 希望我能清晰又糊涂的过一生。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Study Notes of Linux]]></title>
    <url>%2F2019%2F01%2F04%2FStudy-Notes-of-Linux%2F</url>
    <content type="text"><![CDATA[命令ip addr查看IP地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[TenSquare]]></title>
    <url>%2F2019%2F01%2F03%2FTenSquare%2F</url>
    <content type="text"><![CDATA[什么是微服务架构 软件开发中对架构、构架、结构、框架的理解 架构 Architecture ​ 架构不是软件，而是关于软件如何设计的重要策略。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中。 ​ 软件架构是指构成一个软件系统核心（主体、基础）结构的组成元素，以及这些核心组成元素之间的相互依赖、交互、协作等关系。一个软件架构（模型）是动静结合的，既包含了核心元素之间的静态结构（static structural）关系，也包含了它们之间的动态行为（dynamic behavioral）关系。 框架 Framework ​ 框架是半成品。典型地，框架是系统或子系统的半成品。 小节 ​ 框架技术和架构技术的出现，都是为了解决软件系统日益复杂所带来的困难而采取“分而治之”思维的结果—–先大局后局部，就出现了架构；先通用后专用，就出现了框架。 ​ 架构是问题的抽象解决方案，它关注大局而忽略细节；而框架是通用半成品，还必须根据具体需求进一步定制开发才能变成应用系统。 微服务微服务是一种架构风格 微服务的目的是有效的拆分应用，实现敏捷开发和部署 。 把需要搭建成服务的功能制作成镜像，然后把镜像做成容器，微服务就是同类容器的集合。 spring cloud实现微服务之间的通信。 UML 统一建模语言简介 UML建模的要点总结(一） UML用例建模解析 UML教程_w3cschool 介绍​ UML（Unified Modeling Language），也称统一建模语言或标准建模语言。是用来做软件建模的。用于表达软件的操作，对象等信息。 UML 是一种 Language（语言）UML 是一种 Modeling（建模）LanguageUML 是 Unified（统一）Modeling Language PowerDesigner PowerDesigner - 维基百科，自由的百科全书 为传统的软件开发周期管理提供业务分析和规范的数据库设计解决方案。 RESTful 理解RESTful架构 RESTful API 最佳实践 restcookbook.com ​ REST，即 Representational State Transfer 的缩写。阮大大对这个词组的翻译是”表现层状态转化“。 ​ 一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 安全性和幂等性 HTTP方法的幂等性与安全性 ​ RestFul service 架构是基于 http 协议的。Http 有两个非常重要的特性，安全性和幂等性。 安全，幂等 安全性: 请求一次或多次, 不会改变实例的表现形式. 重点强调无副作用. 幂等性: 请求一次或多次, 响应结果相同. 重点强调副作用的一致性. 增删改查，三个不安全，三个幂等 Function idempotent safe description GET YES YES 获取实例 HEAD YES YES 获取响应头 OPTIONS YES YES 获取支持的请求方式 TRACE YES YES 追踪查看最终的请求 PUT YES NO 全量覆盖某个实例 POST NO NO 创建新实例 PATCH NO NO 修改实例的某些属性 DELETE YES NO 删除某个实例 Docker命令 docker images systemctl start docker docker run -di –name=tensquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7 docker ps -a 分布式ID生成器Twitter 的 SnowFlake（雪花）算法。 snowflake Twitter-Snowflake，64位自增ID算法详解 Twitter Snowflake算法详解 jpa 原生sql 语句 12@Query(value = "SELECT * FROM tb_problem, tb_pl WHERE id = problemid AND labelid = ? AND reply = 0 ORDER BY createtime DESC", nativeQuery = true)public List&lt;Problem&gt; waitlist(String labelid, Pageable pageable); jpa @Modifying spring boot data redis80% 都用的是 redisTemplate.opsForValue() Spring Cache @EnableCaching @Cacheable(value = “gathering”, key = “#id”) @CacheEvict(value = “gathering”, key = “#id”) 需要过期时间使用redis，不需要过期时间使用spring cache 单点登录并没有共享session，分布式的单点登录最流行的是JWT（GWT?），CAS也是一种，但是是有状态的（服务的要存储登录信息） qq登录后，qq音乐等都默认也是登录的，这就是单点登录 MongoDB为大数据而生 非关系型数据库中最像关系型数据库的数据库 关系型数据库与非关系型数据库的区别：关系型数据库就是表与表之间有关系（1：1 ，（靠主外键）1：n，（靠主外键）n:n（靠中间表））。 数据库选型原因： mongodb的客户端与服务器是二合一的。 默认端口是27017 逐渐名必须为 _id emp表，树形结构 _id 一般都是手动指定，不要用自动生成。 IDEActrl + alt + v Java原生操作mogodb 1234567891011121314151617public static void main(String[] args)&#123; // 连接服务器 MongoClient client = new MongoClient("192.168.235.128"); // 得到要操作的数据库 MongoDatebase spitdb = client.getDatabase("spitdb"); // 得到要操作的集合 MongoCollection spit = spitdb.getCollection("spit"); // 得到集合中所有的文档 FindIterable&lt;Document&gt; documents = spit.find(); // 遍历数据 for(Document document:documents)&#123; System.out.println("内容："+document.getString("content")); System.out.println("用户ID："+document.getString("userid")); System.out.println("访问量："+document.getString("visits")); &#125; client.close();&#125; 12345678910111213141516public static void main(String[] args)&#123; MongoClient client = new MongoClient("192.168.235.128"); MongoDatebase spitdb = client.getDatabase("spitdb"); MongoCollection spit = spitdb.getCollection("spit"); // 封装查询条件，值查询用户id为1013的 // BasicDBObject bson = new BasicDBObject("userid", "1013"); // 封装查询条件，查询访问量大于1000的 find(&#123;visits:&#123;$gt:1000&#125;&#125;) BasicDBObject bson = new BasicDBObject("visits", new BasicDBObject("$gt", 1000)); FindIterable&lt;Document&gt; documents = spit.find(bson); for(Document document:documents)&#123; System.out.println("内容："+document.getString("content")); System.out.println("用户ID："+document.getString("userid")); System.out.println("访问量："+document.getString("visits")); &#125; client.close();&#125; 12345678910111213public static void main(String[] args)&#123; MongoClient client = new MongoClient("192.168.235.128"); MongoDatebase spitdb = client.getDatabase("spitdb"); MongoCollection spit = spitdb.getCollection("spit"); // 插入文档 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("content", "lalalalallala"); map.put("userid", "1029"); map.put("visits", 1249); Document document = new Document(map); FindIterable&lt;Document&gt; documents = spit.insert(document); client.close();&#125; Spring Data MongoDBidea 切换窗口快捷键：alt + 左右方向键 数据库 逻辑主外键。公司基本上不会真正使用物理主外键 避免 * 的出现，避免全表扫描 @Autowired 与 @Resource的区别@Autowired默认按类型查找，类型找不到会按名称找。可以通过@Quligier()来指定按名称查找 @Resource默认按名称查找，（未指定name属性时）找不到按类型查找。 分布式搜索引擎ElasticSearchHead插件IK分词器使用SpringDataElasticsearch完成搜索微服务的开发使用logstash完成mysql与Elasticsearch的同步工作搜索分两大类：搜索引擎（百度，谷歌），站内搜索（淘宝，京东） cnpm里没有grunt ik分词器，为了兼容不同系统，一般自定义词条时要加空行 Linux命令CentOs命令 vi shift+zz reboot docker docker exec -it tensquare_es /bin/bash docker ps ik tensquare_es:/usr/share/elasticsearch/plugins 挂载 服务器系统调优 修改/etc/security/limits.conf ，追加内容 soft nofile 65536 hard nofile 65536nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制修改/etc/sysctl.conf，追加内容vm.max_map_count=655360限制一个进程可以拥有的VMA(虚拟内存区域)的数量执行下面命令 修改内核参数马上生效sysctl ‐p elasticsearch solr lucene 倒排索引 消息中间件速度 Kafka&gt;RabbitMQ&gt;ActiveMQ 安全 ActiveMQ&gt;RabbitMQ&gt;Kafka kafka用在大数据中。 rabbitmq有交换机的概念，activemq没有 spring boot @Runwith（） @SpringBootTest（） @RabbitLisener @RabbitHandler RoutingKey # * 匹配规则 rabbitmq直连模式，分列模式，主题模式 org.apache.commons.lang3.RandomStringUtils 12// 生成6位随机数String checkcode = RandomStringUtils.randomNumeric(6); 阿里云发短信 Maven导入本地jar包 12@Autowiredprivate Environment env; SHA算法（啥算法），MD5算法（妈的5算法） BCrypt 加密算法 认证 就是登录，就是告诉系统你是谁。 认证后才进行授权。 只使用spring security的加密算法。 12345678910111213141516171819/** * 安全配置类 */@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter&#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; // authorizeRequests()：所有security全注解是实现形式的开端，表示开始说明需要的权限 // 需要的权限分为两部分，第一部分时拦截的路径，第二部分是访问该路径所需要的权限。 // antMatchers：拦截的路径，permitAll：任何权限都可以访问，直接放行所有。 // .and().csrf().disable()：固定写法， 表示使csrf拦截失效。 http .authorizeRequests() .antMatchers("/**").permitAll() .anyRequest().authenticated() .and().csrf().disable(); &#125;&#125; 使用spring而不是spring boot时有一个原则：自己写的类用注解，框架的类用配置文件。 web.xml时web工程的入口。 web.xml就是为了初始化servlet容器。 spring boot强就强在省了一个web.xml 讲义第六章.2 常见的认证机制（即登录机制） 有状态登录：服务端要存登录信息，就是有状态登录 cookie在pc端浏览器里有，在移动端是没有的。 签名算法：HS256 用户 USER 角色 role 权限 permission 用户和角色是多对多，角色和权限是多对多。 12@Autowiredprivate HttpServletRequest request; quartz 定时任务，默认是多线程，但公司里都是用单线程。 如果没有在规定时间执行完，可以将concurrent属性改为false，使得下次任务必须等上次任务执行完后再执行。 七子表达式，即Cron表达式，共7位，周和日不能同时出现。 单点登录，CAS, SSO 单点登录与有无状态之间的区别 eureka 实现服务之间的通信。 feign 实现服务之间的调用。 dependencyManager 锁版本 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; eureka.instance.prefer-ip-address=true 服务器各服务之间跨域访问 @FeignClient(“”) 应用名不能有下划线。 feign接口 @PaathVariable 必须加name属性。 @IdClass(Friend.class) 公司一般再使用第三方提供的技术，比如利用阿里云发短信等，由于异常无法把控，所以使用消息队列异步调用的方式。 嵌套子查询效率特别低，公司中一般不允许出现，一般都会使用连接查询替代，或者使用EXITS关键字 POI报表导入导出，apache poi，excel 转成 csv 格式poi处理更快。 相关账号虚拟机账号：root 密码：itcast 数据库账号：root 密码：root]]></content>
  </entry>
  <entry>
    <title><![CDATA[Comments]]></title>
    <url>%2F2019%2F01%2F03%2FComments%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[How to Down Up a Plan]]></title>
    <url>%2F2019%2F01%2F02%2FHow-to-Down-Up-a-Plan%2F</url>
    <content type="text"><![CDATA[为什么要制定计划 这样制定计划 让你的效率翻倍 【人生规划局 VOL.02】构建你的计划与时间管理系统 计划没有变化快，为什么还要定计划？ 清楚自己要做什么 清楚事情的进展情况 让自己的时间得以有效利用 计划的分类主要分为两大类 固定时间计划 如日计划，周计划，月计划…… 关键事务计划 如项目计划等…… 制定计划的原则 [方法论] 如何设定目标，如何制定计划？ SMART原则： Specific（具体的） Measurable（可度量的） Achievable（可实现的） Relevant（相关的） Time-bound（时间可控的） 模板 链接：https://pan.baidu.com/s/1Sxb8lLL4QSXOeNRYOZy7cA提取码：x3w1 制定计划的流程 罗列要做的事情 确定重点事宜 分配时间 计划的检查与调整日计划一般中午和晚上各检查一次，周计划则1-2天检查一次 为什么完不成计划 你！为什么总是完不成计划！ 为什么制定的计划总是实现不了？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记]]></title>
    <url>%2F2018%2F12%2F25%2FStudy-Notes-of-Redis%2F</url>
    <content type="text"><![CDATA[简介 Redis-GitHbu 什么是Redis有哪些公司在使用RedisGitHub, Twitter, Stackoverflow, Alibaba, 百度，微博，美团，搜狐 Redis的八大特性 速度快 支持持久化 存在多种数据结构 支持多种语言 功能丰富 简单（代码量小，使用方便） 主从复制 高可用，分布式 速度快官方给的指标是10w OPS（每秒十万次读写） 这么快的原因： 数据存放在内存中 使用C语言编写（大约五万行代码），C语言离操作系统较近 线程模型为单线程 持久化Redis所有数据保存在内存中，对数据的更新将异步的保存到磁盘上。 多种数据结构五大数据结构： Strings Hash Tables Linked Lists Sets Sorted Sets 其他新结构： BitMaps: 位图（本质是字符串，可以实现类似布隆过滤器的功能） HyperLogLog：超小内存唯一值计数（本质是字符串） GEO：地理信息定位（本质是有序集合，Redis-3.2后提供） 支持多种客户端语言Java，PHP，python，Ruby，Lua，nodejs 功能丰富 发布订阅模式 Lua脚本 事务 pipeline（提高客户端并发效率） 典型应用场景 缓存系统 计数器（微博的转发数，评论数以及视频网站的播放数等） 消息队列系统 排行榜 社交网络（粉丝数，关注数，共同关注数） 实时系统（垃圾邮件处理系统，布隆过滤器） 安装RedisRedis安装Linux系统下安装Redis1234567891011# 1. 下载$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz# 2. 解压缩$ tar xzf redis-5.0.3.tar.gz# 3. 建立一个软连接$ In -s redis-5.0.3 redis$ cd redis-5.0.3# 4. 编译$ make# 5. 安装$ make install 可执行文件说明 可执行文件 说明 redis-server Redis服务器 redis-cli Redis命令行客户端 redis-benchmark Redis性能测试工具 redis-check-aof AOF文件修复工具 redis-check-dump RDB文件修复工具 redis-sentinel Sentinel服务器（2.8以后） 三种启动方法最简启动直接使用redis-server 动态参数启动1redis-server --port 6380 # 默认端口是6379 配置文件启动1redis-server configPath 验证方法123ps -ef|grep redisnetstat -antpl|grep redisredis-cli -h ip -p port ping 比较 生产环境推荐配置启动 单机多实例配置文件可以用端口区分开 简单的客户端连接连接1234redis-cli -h 10.10.79.150 -p 6384pingset hello worldget hello 返回值 状态回复（如ping返回PONG） 错误回复（如(error) WRONGTYPE Operation against） 整数回复（如incr hello回复(integer) 1） 字符串回复（如get hello回复&quot;world&quot;） 多行字符串回复（如mget hello foo返回&quot;world&quot; &quot;bar&quot;） Redis常用配置 属性 说明 daemonize 是否是守护进程（no默认\ yes推荐） port Redis对外端口号，默认为63797379对应手机按键上MERZ对应的号码，MERZ取自意大利歌女Alessia Merz的名字 logfile Redis系统日志 dir Redis工作目录 Redis API通用命令 keys eg：keys * 遍历所有的key 怎么用： ​ 热备从节点 ​ scan dbsize 计算key的总数 exists key 检查key是否存在，存在返回1，否则返回0 del key [key …] 删除指定key-value，成功返回1，否则返回0 expire key seconds ttl key查看key剩余的过期时间 persist key去掉key的过期时间 type key 返回key的类型（string，hash，list，set，zset，none） 命令 时间复杂度 keys O(n) dbsize O(1) del O(1) exists O(1) expire O(1) type O(1) 数据结构和内部编码内部编码 字符串键值结构 key value hello world counter 1 bits \ 1\ 0\ 1\ 1\ 1\ 0\ 1\ {“prodduct”:{“id”: “3242”“name”: “test423”}} Value up to 512MB，up to 100k is recommended 场景 缓存 计数器 分布式锁 命令123456# 1. 获取key对应的value O(1)get key# 2. 设置key-value O(1)set key value# 3. 删除key-value O(1)del key 12345678# 1. key自增1，如果key不存在，自增后get（key）=1 O(1)incr key# 2. key自减1，如果key不存在，自减后get（key）=-1 O(1)decr key# 3. key自增k，如果key不存在，自增后get（key）=k O(1)incrby key k# 4. key自减k，如果key不存在，自减后get（key）=-k O(1)decrby key k 123456# 1. 不管key是否存在，都设置 O(1)set key value# 2. key不存在，才设置 O(1)setnx key value# 3. key存在，才设置 O(1)set key value xx 1234# 1. 批量获取key，原子操作 O(n)mget key1 key2 key3...# 2. 批量设置key-value O(n)mset key1 value1 key2 vlaue2 key3 value3 n次get = n次网络时间 + n次命令时间 1次mget = 1次网络时间 + n次命令时间 123456# 1. set key newvalue并返回旧的value O(1)getset key newvalue# 2. 将value追加到旧的value O(1)append key value# 3. 返回字符串的长度（注意中文） O(1)strlen key 123456# 1. 增加key对应的值3.5 O(1)incrbyfloat key 3.5# 2. 获取字符串指定下标范围内的值 O(1)getrange key start end# 3. 设置指定下标范围内对应的值 O(1)setrange key index value 复杂度总结 命令 含义 复杂度 set key value 是指key-value O(1) get key 获取key-value O(1) del key 删除key-value O(1) setnx setxx 根据key是否存在设置key-value O(1) Incr decr 计数 O(1) mget mset 批量操作key-value O(n) 实战 记录网站每个用户个人主页的访问量？ 1incr userid:pageview 缓存视频的基本信息（数据源在MySQL中）伪代码 123456789101112public VideoInfo get(long id)&#123; String redisKey = redisPrefix + id; VideoInfo videoInfo = redis.get(redisKey); if(videoInfo == null)&#123; videoInfo = mysql.get(id); if(videoInfo != null)&#123; //序列化 redis.set(redisKey, serialize(videoInfo)); &#125; &#125; return videoInfo;&#125; 分布式计数器 incr id (原子操作) Hash键值结构 key field value user:1:info nameageDate Ronaldo32239 特点 是一个value为Map的Map field不能相同，value可以相同 API所有以哈希为结构的命令都是以H开头的。 123456# 1. 获取hash key对应的field的value O(1)hget key field# 2. 设置hash key对应field的value O(1)hset key field value# 3. 删除hash key对应field的value O(1)hdel key field 1234# 1. 判断hash key是否有field O(1)hexists key field# 2. 获取hash key field的数量 O(1)hlen key 1234# 1. 批量获取hash key的一批field对应的值 O(n)hmget key field1 field2... fieldN# 2. 批量设置hash key的一批field value O(n)hmset key field1 value1 field2 value2...fieldN valueN 123456# 1. 返回hash key对应所有的field和value O(n)hgetall key# 2. 返回hash key对应所有field的value O(n)hvals key# 3. 返回hash key对应多有field O(n)hkeys key 123456# 1. 设置hash key对应field的value（若field已存在，则失败） O(1)hsetnx key field value# 2. hash key对应的filed的value自增intCounter O(1)hincrby key field intCounter# 3. hincrby浮点数版 O(1)hincrbyfloat key field floatCounter 复杂度总结 命令 复杂度 hget hset hdel O(1) hexists O(1) hincrby O(1) hgetall hvals hkeys O(n) hmget hmset O(n) 列表特点 有序（根据插入顺序得到遍历顺序） 可以重复 左右两边都可以插入和弹出 API列表的API都以L开头 增123456# 1. 从列表右端插入值 O(1)rpush key value1 value2 ... valueN# 2. 从列表左端插入值 O(1)lpush key value1 value2 ... valueN# 3. 在list指定的值前|后插入newValue O(n)linsert key before|after value newValue 删1234# 1. 从列表左侧弹出一个item O(1)lpop key# 2. 从列表右侧弹出一个item O(1)rpop key 12345# 3. 根据count值，从列表中删除所有value相等的项 O(n)# （1）count&gt;0，从左到右，删除最多count个value相等的项# （2）count&lt;0，从右到左，删除最多Math。abs（count）个value相等的项# （3）count=0，删除所有value相等的项lrem key count value 123# 4. 按照索引范围修剪列表 O(n)# 如ltrime listkey 1 4 是指删除除了下标为1-4（包括1和4）其他项ltrim key start end 查1234# 1. 获取列表指定索引范围所有item O(n)# 如lrange listKey 0 2获取的是下标0-2（包括0和2）的项# 再如lrange listKey 1 -1获取的是下标1-（len-1）的项lrange key start end 123# 2. 获取列表指定索引的item O(n)# 如lindex listkye -1 取到的是最后一个元素lindex key index 12# 3. 获取列表长度 O(1)llen key 改12# 1. 设置列表指定索引值为newValue O(n)lset key index newValue 其他1234# 1. lpop阻塞版本，timeout是阻塞超时时间，timeout=0为永远不阻塞 O(1)blpop key timeout# 2. rpop阻塞版本，timeout是阻塞超时时间，timeout=0为永远不阻塞 O(1)brpop key timeout TIPS LPUSH + LPOP = Stack LPUSH + RPOP = Queue LPUSH + LTRIM = Capped Collection LPUSH + BRPOP = Message Queue 实战 TimeLine 实战 记录网站每个用户个人主页的访问量 1hincrby user:1:info pageview count 缓存视频的基本信息（数据源在mysql中）伪代码 123456789101112public VideoInfo get(long id)&#123; String redisKey = redisPrefix + id; Map&lt;String, String&gt; hashMap = redis.hgetAll(redisKey); VideoInfo videoInfo = transferMapToVideo(hashMap); if(videoInfo == null)&#123; videoInfo = mysql.get(id); if(videoInfo != null)&#123; redis.hmset(redisKey, transferVideoToMap(videoInfo)); &#125; &#125; return videoInfo;&#125; 单线程架构Redis在同一时刻只会执行一条命令 单线程为什么这么快 纯内存 非阻塞IO 避免线程切换和竞态消耗 拒绝长（慢）命令 ​ keys, flushall, flushdb, slow lua script, mutil/exec, operate big value(collection) 其实不是单线程 fysnc file descriptor close file descriptor Redis客户端Java客户端：Jedis获取Jedis 添加Maven依赖 123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; Jedis直连（TCP连接） 123Jedis jedis = new Jedis("127.0.0.1", 6379);jedis.set("hello","world");String value = jedis.get("hello"); Jedis(String host, int port, int connectionTimeout, int soTimeout) host : Redis节点所在机器的IP port : Redis节点的端口 connectionTimeout : 客户端连接超时时间（内部使用socket技术） soTimeout : 客户端读写超时时间 Jedis基本使用Jedis连接池使用简单使用123456789101112131415161718// 初始化Jedis连接池，通常来讲JedisPool是单例的。GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();JedisPool jedisPool = new JedisPool(poolConfig, "127.0.0.1", 6379);Jedis jedis = null;try&#123; // 1. 从连接池获取jedis对象 jedis = jedisPool.getResource(); // 2. 执行操作 jedis.set("hello", "world");&#125; catch (Exception e)&#123; e.printStackTrance();&#125; finally &#123; if(jedis != null)&#123; // 如果使用JedisPool，close操作不是关闭连接，二十代表归还连接池。 jedis.close(); &#125;&#125; 优点 缺点 直连 - 简单方便- 适用于少量长期连接的场景 - 存在每次新建/关闭TCP开销- 资源无法控制，存在连接泄露的可能- Jedis对象线程不安全 连接池 - Jedis预先生成，降低开销使用- 连接池的形式保护和控制资源的使用 相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题。 python客户端：redis-py源码安装 Redis-clients-python 12345wget https://github.com/andymccurdy/redis-py/archive/3.0.0.zipunzip redis-3.0.0.zipcd redis-3.0.0# 安装redis-pysudo python setup.py install 简单使用1234567import redisclient = redis.StrictRedis(host='127.0.0.1', port=6379)key = "hello"setResult = client.set(key, "python-redis")print setResultvalue = client.get(key)print "key:" + key + ", value:" + value Go客户端 1234567891011121314151617c,err := redis.Dial("tcp", "127.0.0.1:6379")if err != nil&#123; fmt.Println(err) return&#125;defer c.Close()v, err := c.Do("SET", "hello", "world")if err != nil&#123; fmt.Println(err) return&#125;fmt.Println(v)v, err = redis.String(c.Do("GET", "hello"))if err != nil &#123; fmt.Println(err) return&#125; 瑞士军刀Redis慢查询生命周期 慢查询发生在第三阶段 客户端超时不一定是慢查询导致的，慢查询只是导致客户端超时的一个可能因素 两个配置slowlog-max-len 先进先出队列 固定长度 保存在内存内 slowlog-log-slower-than 慢查询阈值（单位：微妙，1毫秒等于1000微秒） slowlog-log-slower-than=0，记录所有命令 slowlog-log-slower-than&lt;0，不记录任何命令 配置方法 默认值 config get slowlog-max-len = 128 config get slowlog-log-slower-than = 10000 修改配置文件后重启（适用于未启动时） 动态配置 config set slowlog-max-len 1000 config set slowlog-log-slower-than 1000 三个命令 slowlog get [n] ：获取慢查询队列 slowlog len ：获取慢查询队列长度 slowlog reset ：清空慢查询队列 运维经验 slowlog-max-len不要是指过大，默认10ms，通常是指1ms slowlog-log-slower-than不要设置太小，通常设置1000左右 理解命令生命周期 定期持久化慢查询 pipeline什么是流水线流水线就是一次网络连接里传输一批命令，节省网络传输时间 命令 N个命令操作 1次pipeline 时间 n次网络 + n次命令 1次网络 + n次命令 数据量 1条命令 n条命令 注意： Redis的命令时间是微秒级别。 pipeline每次条数要控制（网络）。 客户端实现 pipeline-Jedis12345// before pipelineJedis jedis = new jedis("127.0.0.1", 6379);for (int i = 0; i &lt; 10000; i++)&#123; jedis.hset("hashkey:" + i, "field" + i, "value" + i);&#125; 123456789// after pipelineJedis jedis = new jedis("127.0.0.1", 6379);for (int i = 0; i &lt; 100; i++)&#123; Pipeline pipeline = jedis.pipelined(); for(int j = i*100; j &lt; (i+1)*100; j++)&#123; pipeline.hset("hashkey:" + j, "field" + j, "value" + j); &#125; pipeline.syncAndReturnAll();&#125; 与原生M操作做对比M操作是原子操作，pipeline是非原子操作。 使用建议 注意每次pipeline携带数据量 pipeline每次只能作用在一个Redis节点上 M操作与pipeline区别 发布订阅角色 发布者（publisher） 订阅者（subscriber） 频道（channel） 模型Redis server中有各个频道。 发布者向频道中发布消息 订阅者收到其所订阅频道的消息，只能收到订阅时刻之后的消息，之前的收不到。 需要注意的是，redis没有消息堆积的能力。 APIpublish1publish channel message eg: 12redis&gt; publish sohu:tv "hello world"(integer) 3 # 订阅者个数 subscribe1subscribe [channel] # 一个或多个 unsubscribe1unsubcribe [channle] # 一个或多个 其他 12345678910# 1. 订阅模式psubscribe [pattern]# 2. 推定指定的模式punsubscribe [pattern]# 3. 列出至少有一个订阅者的频道pubsub channels# 4. 列出给定频道的订阅者数量pubsub numsub [channel]# 5. 列出被订阅模式的数量pubsub numpat 发布订阅与消息队列发布订阅是所有订阅者可以收到所有的消息 消息队列是订阅者要进行消息抢夺，一条消息只有一个订阅者能够抢到。 Bitmap位图 b i g 01100010 01101001 01100111 相关命令12345678910# 1. 给位图指定索引设置值setbit key offset value# 2. 获取位图指定索引的值getbit key offset# 3. 获取位图指定范围（start到end，单位为字节，如果不指定就是获取全部）位值为1的个数bitcount key [start end]# 4. 做多个Bitmap的and（交集）、or（并集）、not（非）、xor（抑或）操作并将结果保存在destkey中bitop op destkey key [key...]# 5. 计算位图指定范围（start到end，单位为字节，如果不指定就是取全部）第一个偏移量对应的值等于targetBit的位置bitpos key targetBit [start][end] 独立用户统计 使用set和Bitmap 总共1亿用户，每日5千万独立访问。 数据类型 每个userid只用空间 需要存储的用户量 全部内存量 set 32位（假设userid用的是整型，实际很多网站用的是长整型） 50，000，000 32位*50，000，000=100MB Bitmap 1位 100，000，000 12.5MB 一天 一个月 一年 set 200M 6G 72G Bitmap 12.5M 375M 4.5G 如果只有10万对立用户：| 数据类型 | 每个userid占用空间 | 需要存储的用户量 | 全部内存量 || ——– | —————— | —————- | ———————- || set | 32位 | 1,000,000 | 32位1,000,000=4MB || Bitmap | 1位 | 100,000,000 | 1位100,000,000=12.5MB | 使用经验 type=string，最大512MB 注意setbit时的偏移量，可能有较大耗时 位图不是绝对好。 HyperLogLog是否是新的数据结构 基于 HyperLogLog 算法：极小空间完成独立数量统计。 本质还是字符串 三个命令 向 hyperloglog 添加元素 1pfadd key element [element ...] 计算 hyperloglog 的独立总数 1pfcount key [key ...] 合并多个 hyperloglog 1pfmerge destkey sourcekey [sourcekey ...] 内存消耗使用经验 存在错误率（0.81%） 无法取出单条数据 GEOGEO是什么GEO(地理信息定位)：存储经纬度，计算两地距离，范围计算等。 5个城市经纬度 城市 经度 纬度 北京 116.28 39.55 天津 117.12 39.08 石家庄 114.29 38.02 唐山 118.01 39.38 保定 115.29 38.51 相关命令123456789# 1. 添加地理位置信息geo key longitude latitude member [longitude latitude member ...]# 2. 获取地理位置信息geopos key member [member ...]# 3. 获取两个地理位置的距离# unit: m(米)、km(千米)、mi(英里)、ft(尺)geodist key member1 member2 [unit]# 4. 获取指定位置范围内的地理位置信息集合georadius 相关说明 since 3.2+ type geoKey = zset 没有删除 API：zrem key member 持久化持久化的作用（1）什么是持久化 redis 所有数据保存在内存中，对数据的更新将异步的保存到磁盘上。 （2）持久化的实现方式 快照 MySQL Dump Redis RDB 写日志 MySQL Binlog Hbase Hlog Redis AOF RDB（1）什么是RDB ​ redis 通过命令创建 RDB 文件（二进制）保存在硬盘中。当 redis 重启时通过命令将 RDB 文件载入到内存。实质是一个复制媒介。 （2）触发机制-主要三种方式 save（同步） 新文件将会替换老文件 复杂度位 O(n) bgsave（异步） 利用 Linux fork() 异步执行 文件策略及复杂度与 save 相同 | 命令 | save | bgsave || —— | —————- | ——————- || IO类型 | 同步 | 异步 || 阻塞 | 是 | 是（阻塞发生在fork) || 复杂度 | O(n) | O(n) || 优点 | 不会消耗额外内存 | 不阻塞客户端命令 || 缺点 | 阻塞客户端命令 | 需要fork，消耗内存 | 自动 redis 提供了 save 配置 | 配置 | seconds | changes || —- | ——- | ——- || save | 900 | 1 || save | 300 | 10 || save | 60 | 10000 | 满足任意一个条件，redis 会自动创建（bgsave）RDB 文件 默认配置： 12345678save 900 1save 300 10save 60 10000dbfiename dump.rdbdir ./stop-writes-on-bgsave-error yesrdbcompression yesrdbcheksum yes 最佳配置： 12345dbfilename dump-$&#123;port&#125;.rdbdir /bigdiskpathstop-writes-on-bgsave-error yesrdbcompression yesrdbcheksum yes （3）触发机制-不容忽视方式 1. 全量复制 2. debug reload 3. shutdown （4）总结 1. RDB是 Redis 内存到硬盘的快照，用于持久化。 2. save 通常会阻塞 Redis 3. bgsave 不会阻塞 Redis，但是会 fork 新进程。 4. save 自动配置满足任意一个条件就会被执行。 AOFRDB 现存问题 耗时，耗性能 O(n): 耗时 fork(): 消耗内存，copy-on-write 策略 Disk I/O: IO 性能 不可控，丢失数据 什么是 AOF每执行一条命令，就将该命令写入到 AOF 日志文件中。 AOF 三种策略（1）always ​ 每条写命令都会出发刷新，将缓冲区的命令日志刷新到 AOF 文件中。 （2）everysec ​ 每秒（默认值）刷新一次 （3）no ​ 由操作系统决定什么时候刷新。 命令 always everysec no 优点 不丢失数据 每秒一次 fsync 丢失一秒数据 不用管 缺点 IO 开销较大，一般的 sata 盘只有几百 TPS 丢失1秒数据 不可控 AOF 重写 原生 AOF AOF 重写 set hello worldset hello javaset hello heheincr counterincr counterrpush mylist arpush mylist brpush mylist c过期数据 set hello heheset counter 2rpush mylist a b c AOF 重写的作用： 减少磁盘占用量 加速恢复速度 AOF 重写的两种实现方式 berewriteaof AOF 重写配置 | 配置名 | 含义 || ————————— | ———————- || autoaof-rewrite-min-size | AOF 文件重写需要的尺寸 || auto-aof-rewrite-percentage | AOF 文件增长率 | | 统计名 | 含义 || —————- | ————————————– || aof_current_size | AOF 当前尺寸（单位：字节） || aof_base_size | AOF 上次启动和重写的尺寸（单位：字节） | 自动触发时机： aof_current_size &gt; auto-aof-rewrite-min-size aof_current_size - aof_base_size / aof_base_size &gt; auto-aof-rewrite-percentage AOF 重写流程 常用配置： 1234567appendonly yesappendfilename "appendonly-$&#123;port&#125;.aof"appendfsync everysecdir /bigdiskpathno-appendfsync-on-rewrite yesauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb RDB 和 AOF 的抉择RDB 和 AOF 比较 命令 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 轻重 重 轻 RDB 最佳策略 “关” 集中管理 主从，从开 AOF 最佳策略 ”开“：缓存和存储 AOF 重写集中管理 everysec 最佳策略 小分片 缓存或者存储 监控（硬盘、内存、负载、网络） 足够的内存 开发运维常见问题fork 操作 同步操作 与内存量息息相关：内存越大，耗时越长（与机器类型有关） info: latest_fork_usec 查询上一次 fork 的时间 如何改善fork 优先使用物理机或者高效支持 fork 操作的虚拟化技术 控制 Redis 实例最大可用内存：maxmemory 合理配置 Linux 内存分配策略：vm.overcommit_memory = 1 降低 fork 频率：例如放宽 AOF 重写自动触发时机，不必要的全量复制 进程外开销子进程开销和优化 CPU： 开销：RDB 和 AOF 文件生成，属于 CPU 密集型 优化：不做 CPU 绑定，不和 CPU 密集型部署 内存： 开销：fork 内存开销，copy-on-write。 优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 硬盘 开销：AOF 和 RDB 文件写入，可以结合 iostat，iotop 分析 优化： 不要和高硬盘负责服务部署在一起：存储服务、消息队列等 no-appendfsync-on-rewrite = yes 根据写入量决定磁盘类型：例如 ssd 单机多实例持久化文件目录可以考虑分盘 AOF追加阻塞 AOF 阻塞定位 ​ Reids 日志： ​ Asynchronous AOF fsync is taking too long (disk is busy?). ​ Writing the AOF buffer without waiting for fsync to complete,this may slow down Redis. ​ info Persistence: ​ … ​ aof_delayed_fsync: 100 ​ … 单机多实例部署Redis 复制的原理与优化什么是主从复制（1）单机有什么问题？ ​ 机器故障 ​ 容量瓶颈 ​ QPS 瓶颈 （2）作用 ​ 数据副本 ​ 扩展读性能 复制的配置两种实现方式 slaveof 命令 配置 12slaveof ip portslave-read-only yes 全量复制和部分复制查看 run_id 1redis-cli -p 6379 info server | grep run 查看偏移量 1redis-cli -p 6379 info replication 全量复制开销： bgsave 时间 RDB文件网络传输时间 从节点清空数据时间 从节点加载 RDB 的时间 可能的 AOF 重写时间 故障处理开发运维常见问题 读写分离 将读流量分摊到从节点 可能遇到的问题： 复制数据延迟 读到过期数据 从节点故障 主从配置不一致 规避全量复制 第一次不可避免 系欸但运行 ID 不匹配 主节点重启 故障转移 复制积压缓冲区不足 网络中断，部分复制无法满足 增大复制缓冲区配置 rel_backlog_size，网络“增强”。 规避复制风暴 单主节点复制风暴 问题：主节点重启，多从节点复制 解决：更换复制拓扑 单机器复制风暴 机器宕机后，大量全量复制 主节点分散多机器 Redis Sentinel主从复制高可用存在的问题 手动故障转移 写能力和存储能力受限 架构说明客户端不直接访问 redis，而是通过 sentinel 来访问。由 sentinel 来负责主从节点的管理。 安装配置sentinel 的默认端口为 26379 配置开启主从节点 配置开启 sentinel 监控主节点（sentinel 是特殊的 redis） 客户端连接请求相应流程 jedis 123456789101112JedisSentinelPool sentinelPool = new JedisSentinelPool(masterName, sentinelSet, poolConfig, timeout);Jedis jedis = null;try &#123; jedis = redisSentinelPool.getResource(); // jedis command&#125; catch (Exception e)&#123; logger.error(e.getMessage(), e);&#125; finally &#123; if (jedis != null)&#123; jedis.close(); &#125;&#125; redis-py 实现原理常见开发运维问题Redis Cluster呼唤集群 超高并发量需求 超大数据量需求 数据分布顺序分布 哈希分布 节点取余 使用多倍扩容降低迁移率 一致性哈希 顺时针取余 只影响邻近节点 扩容后会存在负载不均衡的情况 虚拟槽 每个槽映射一个数据子集 良好的哈希函数：例如 CRC16 服务端管理节点、槽、数据：例如 Redis Cluster 分布方式 特点 典型产品 哈希分布 数据分散度高键值分布业务无关无法顺序访问支持批量操作 一致性哈希 MemcacheRedis Cluster 顺序分布 数据分散度易倾斜键值业务相关可顺序访问不支持批量操作 BigTableHBase 搭建集群集群伸缩客户端路由集群原理开发运维常见问题Redis Cluster 架构 节点 meet 指派槽 复制 Redis Cluster 特性 复制 高可用 分片 两种安装方式原生命令安装 配置开启节点 1234567port $&#123;port&#125;daemonize yesdir "/opt/redis/data"dbfilename "dump-$&#123;port&#125;.rdb"logfile "$&#123;port&#125;.log"cluster-enabled yescluster-config-file nodes-$&#123;port&#125;.conf meet 1cluster meet ip port 指派槽 1cluster addslots slot [slot ...] 分配主从关系 1cluster replicate node-id 官方工具安装 链接：https://pan.baidu.com/s/1Y0_Aq8UOzIDoqluORSuCww提取码：5r0v]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
