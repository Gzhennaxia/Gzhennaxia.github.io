<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Unique Pig</title>
    <url>/2019/02/03/A-Unique-Pig/</url>
    <content><![CDATA[<img data-src="https://img30.360buyimg.com/ebookadmin/jfs/t7813/286/2504563183/410924/273a8d24/59afcf3bN98be78ec.jpg" width="100%"/>

<a id="more"></a>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>整体的感悟是我还没达到能读这类全都是观点堆积起来的书，太多理解不了的地方，很多书中涉及的东西都不了解，读不懂，所以现阶段不喜欢这类精选集的书，或者说还不适合读这类书。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>王小波（1952-1997），生于北京，1984年赴美匹兹堡大学东亚研究中心求学，2年后获得硕士学位。1988年回国，先后在北京大学，中国人民大学任教。1992年9月辞去教职，做自由撰稿人。1997年4月11日病逝于北京，年仅45岁。</p>
<p>这本书里除了说那只猪的片段感觉挺有趣的，其他篇章基本全都是观点性的文章，比较严肃。这本书没发现他的有趣，真不该选这一本来作为我读他的第一本书。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>知识另有一种作用，它可以使你生活在过去、未来和现在，使你的生活变得更充实、更有趣。</li>
<li>我已经四十岁了，除了这只猪，还没见过谁敢于如此<strong>无视对生活的设置</strong>。相反，我倒见过很多想要设置别人生活的人，还有<strong>对被设置的生活安之若素</strong>的人。因为这个原故，我一直怀念这只特立独行的猪。</li>
<li>什么叫失败？也许可以说，人去做一件事情，没有达到预期的目的，这就是失败。</li>
<li>只有那些安于自己限度之内的生活的人才总数“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。</li>
<li>明天，既不应是把日历翻过去就是的明天，但是，也不应当是日历翻不到的明天。</li>
<li>这个人的美酒佳肴，就是那个人的穿肠毒药。</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Birthday ShenZhen Weekend Tour</title>
    <url>/2020/08/27/2020-Birthday-ShenZhen-Weekend-Tour/</url>
    <content><![CDATA[<img data-src="https://www.incimages.com/uploaded_files/image/1920x1080/getty_483183993_2000133320009280267_371857.jpg" width="100%"/>

<a id="more"></a>

<iframe  width='100%' height='700' frameBorder='0' src='https://libo9527.github.io/static/map/amap/20200829-30/all/index.html'>
</iframe>

<h2 id="梧桐山"><a href="#梧桐山" class="headerlink" title="梧桐山"></a>梧桐山</h2><p><img data-src="/post_image/image-20200827181034689.png" alt="image-20200827181034689"></p>
<p><img data-src="https://ci.xiaohongshu.com/4fd8dfd5-7ab4-533e-a490-7a084225b01a?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/fa527100-277f-3456-8079-54863f6dfdc0?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/5cf77af1-8f4e-3a86-b3c7-9e3f756059ba?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/769c110c-f5b5-373d-acd6-ff7377244d9c?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/cd41bcf6-95c4-3023-9325-eb83bac514f8?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/2cdfbfed-82fb-3ae3-be73-cefb7158f27e?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/89699805-678b-3d66-b3af-935d24f4202c?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/99566802-8f6e-3add-b00f-b8034473f126?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/572e82a0-634a-3c73-8dd3-62b98c34fdfe?imageView2/2/w/540/format/jpg" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/66a50844-9e52-543b-92f7-4604e244e6fd?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/0bb6be78-462b-372a-8c1a-1099db589cef?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/d61f896a-5ba1-324c-be76-a53553fe3a2e?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/edb0114d-0811-3fc8-8ac6-ee06373e4b80?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/01835502-de4d-319c-9758-da1096cf1a64?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/4723e77b-f5de-3654-9fe6-6ce03ec23f47?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/8d059553-9db0-3cd0-893a-64e09970758a?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/197ffffd-654f-3158-9fe8-f0b26ee9b7ea?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/191f6817-5494-3f14-a345-8932ee0a5c5b?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/8dd9e66e-df68-340a-8609-82e44cff15b1?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/9ae515b6-1a7f-36b0-80c6-7950ab79041e?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<h2 id="东湖公园"><a href="#东湖公园" class="headerlink" title="东湖公园"></a>东湖公园</h2><p><img data-src="https://ci.xiaohongshu.com/35b00e4b-20f0-3de8-b539-9f77090caf39?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/78f11fa7-771e-364c-8f59-87009b6d3761?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<h3 id="废弃游乐场"><a href="#废弃游乐场" class="headerlink" title="废弃游乐场"></a>废弃游乐场</h3><p><img data-src="https://ci.xiaohongshu.com/4ceaafe0-f982-38e5-a8b4-8dd956100430?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/952e5d5b-0d97-3561-9a96-0d567d052a08?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/b33c17a2-21fd-388a-90dc-b0b3c0af1737?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/fc342251-f473-3865-8cbf-797e84b674a6?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/be37879a-3731-3126-8d9e-29c7aeadd973?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/e32c2ef2-0152-3e45-acd7-4922289c8ddc?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/be5bf332-7e2f-3e09-b7ce-2ad16ad5393e?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<p><img data-src="https://ci.xiaohongshu.com/bde5af3e-b809-3e92-8b2f-a6018f65361e?imageView2/2/w/1080/format/jpg/q/75" alt=""></p>
<h2 id="东部华侨城"><a href="#东部华侨城" class="headerlink" title="东部华侨城"></a>东部华侨城</h2><blockquote>
<p><a href="http://www.octeast.com/index.html" target="_blank" rel="noopener">http://www.octeast.com/index.html</a></p>
</blockquote>
<p><img data-src="/post_image/image-20200827181305748.png" alt="image-20200827181305748"></p>
<h3 id="大峡谷"><a href="#大峡谷" class="headerlink" title="大峡谷"></a>大峡谷</h3><ol>
<li>木质小火车</li>
<li>激流勇进</li>
<li>云霄飞车</li>
<li>小火车</li>
<li>缆车</li>
<li>火鸟山谷</li>
<li>海德菲尔小镇</li>
</ol>
<p>大梅沙海滨公园</p>
<p><img data-src="/post_image/image-20200827181457133.png" alt="image-20200827181457133"></p>
<p>仙湖植物园</p>
<p><img data-src="/post_image/image-20200827181722500.png" alt="image-20200827181722500"></p>
<p>小梅沙</p>
<p><img data-src="/post_image/image-20200827190316092.png" alt="image-20200827190316092"></p>
<p>中英街</p>
<p><img data-src="/post_image/image-20200827190431922.png" alt="image-20200827190431922"></p>
<h2 id="行李"><a href="#行李" class="headerlink" title="行李"></a>行李</h2><ol>
<li>纸巾</li>
<li>身份证</li>
<li>花露水</li>
<li>防晒霜</li>
<li>泳衣、拖鞋</li>
<li>小程序“在盐田”网上预约办理边防证，到中英街现场在自动打印机上就可以打处边防证，免得排队。</li>
<li>水+功能饮料+冰冻</li>
<li>硬币，存储柜用</li>
<li>毛巾、换洗衣物</li>
<li>一次性雨衣</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Alive</title>
    <url>/2019/01/22/Alive/</url>
    <content><![CDATA[<img data-src="https://07.imgmini.eastday.com/mobile/20180525/20180525012422_4090d61f4efa84651c9e753b32a784bc_1.jpeg" width="100%"/>

<a id="more"></a>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h3><p>余华，1960年出生于浙江杭州，后来随父母迁居海盐县。中学毕业后，因父母是医生，余华曾当过牙医，五年后弃医从文，从此开始文学创作生涯。</p>
<h3 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h3><p>从国民党统治后期到解放战争、土改运动，再到大炼钢铁运动，自然灾害时期等。</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>最近看的几本书里最好的一本，感触良多，还特意把同名电影看了一遍。最后几十页是一口气全部读完的，停不下来，就一下子看完了。</p>
<p>记忆尤新的是作者在麦田新版自序里写他为何用第一人称的角度写。</p>
<blockquote>
<p>《活着》里的福贵经历了多余常人的苦难，如果从旁观者的角度，福贵的一生除了苦难还是苦难，其他什么都没有；可是当福贵从自己的角度出发，来讲述自己的一生时，他苦难的经历里立刻充满了幸福和欢乐，他相信自己的妻子是世界上最好的妻子，他相信自己的子女也是世界上最好的子女，还有他的女婿他的外孙，还有那头也叫福贵的老牛，还有曾经一起生活过的朋友们，还有生活的点点滴滴……</p>
</blockquote>
<p>从第一人称的角度出发，能过感受到福贵在讲述自己的一生时的心态，传达出与自身命运握手言和的人生态度。</p>
<p>开始读的时候我一直以为余华就是那个收录民谣的知青，而福贵的一生是真真实实存在的，直到读到后序才看到说这是本小说，立刻开始佩服余华出色的文笔，竟能写的如此生动现实，有血有肉。</p>
<p>每当读到描述福贵又要失去一位亲人之前的那段氛围的时候就极度紧张，心里也在祈祷着不要再让福贵经历接下来的苦难了，看到福贵饱受离人之苦，几度欲哭无泪。</p>
<p>书中的福贵一家人每个都富有血肉，善良淳朴。忠贞的家珍，懂事的有庆，体贴的凤霞，憨厚的二喜，机灵的外孙。有这么一个温暖的家庭，虽然遭遇各种苦难，但处处都能体会到家庭的温暖，令人感动。</p>
<p>电影随故事情节有所改动，但主体方向一致。巩俐太美了，独属于那个年代女人的美。演员都是老戏骨，演技精湛，神态很契合小说中的人物形象。最难忘的是巩俐的美和那个插曲。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>人是为了活着本身而活着的，而不是为了活着之外的任何事物而活着</li>
<li>为什么丑恶的事物总在身边，而美好的事物却远在海角</li>
<li>人类无法忍受太多的真实</li>
<li>他是那种能够看到自己过去模样的人，它可以准确地看到在积极年轻时走路的姿态，甚至可以看到自己是如何衰老的</li>
<li>只要人活得高兴，就 不怕穷</li>
<li>这下可得好好活了</li>
<li>一个人和他命运之间的友情，这是最为感人的友情，因为他们互相感激，同时也互相仇恨；他们谁也无法抛弃对方，同时谁也没有理由抱怨对方</li>
<li>生活时一个人对自己经历的感受，而幸存往往是旁观者对别人经历的看法</li>
<li>人的体验和欲望hi有想象和理解，会取消所有不同的界限，会让一个人从他人的经历里感受到自己的命运</li>
<li>生活是属于每个人自己的感受，不属于任何别人的看法</li>
<li>回想这个福贵时，时常觉得他不是一个小说中的人物，二十我生活中曾经出现过的一位朋友</li>
</ul>
]]></content>
      <categories>
        <category>Rading</category>
      </categories>
      <tags>
        <tag>Rading</tag>
      </tags>
  </entry>
  <entry>
    <title>Brother</title>
    <url>/2019/04/08/Brother/</url>
    <content><![CDATA[<img data-src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=438575d418ce36d3a204843602c85dba/0824ab18972bd4072dca5af376899e510fb309aa.jpg" width="100%"/>

<a id="more"></a>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>这是一本余华的长篇小说，分上下两部，跟一本字典一样厚。主人公是一对兄弟，上部讲的是两兄弟少年时期的悲惨经历，下部讲的是两兄弟成年后命运的对比，应该说是用差不多对比的方式讲述不同的性格造就的截然不同的人生。整个时代背景是文革加上改革开放初期一共四十年。</p>
<p>很多情节和手法在他其他的小说里已经见过了，比如说关于粪坑的死法，《活着》里老地主也是类似的在粪缸上拉屎摔下来死掉的，《兄弟》里李光的父亲说掉进粪坑里淹死的；再如丝厂，《李三观卖血记》中的李三观和《兄弟》里的李兰都是在丝厂上班。虽然情节相似，但人物不同，同样的场景因为人物的不同发生的故事也不同，所以并不会感到特别的重复，难道是余华无意费神修改这些东西。</p>
<p>小说中还是有很多情节有点超出正规价值观的范围，并不能算离奇或者说变态，其实人性这东西，本来就存在它黑暗的一面，无所谓好坏，仔细想想又在情理之中，就是豆瓣书评中有个说的那样，意料之外情理之中。</p>
<p>李光头的性格开朗，做事灵活，信守承诺，看待事物总是往好的一面想，这也预示着他在之后事业的飞光腾达，扬帆远航。反观宋钢的性格，他为人忠厚老实，善良体贴，和他的父亲一样知书达理，但唯唯诺诺，做事死板，该有主见的时候没有主见，该听取别人的建议的时候又倔强坚持自我。这也同样预示着他之后的命运多舛，生活拮据。从小看大的俗话是很灵验的，毕竟性格真的是决定命运啊，但性格无谓优劣，只要能够认清自己的性格，安于当下的生活也是可以过的很幸福。</p>
<p>环境造人，性格造世。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><blockquote>
<p>余华，1960年4月3日生于浙江杭州，作家。3岁时随父母迁至海盐，在海盐读完小学和中学。曾从事5年牙医工作，1983年开始写作。其作品被翻译成二十多种文字，在近三十个国家出版。曾获意大利格林扎纳-卡佛文学奖、法国文学和艺术骑士勋章、中华图书特殊贡献奖等。代表作品有《活着》《许三观卖血记》《兄弟》《在细雨中呼喊》《第七天》等。    ——百科</p>
</blockquote>
<p>余华的作品几乎都是写文革时期的事情。文化大革命时1966年5月至1976年10月，而余华就说在这个环境里长大的，环境造就了个人的性格，而性格又影响着个人的成长。所以才使得他对文革的热衷历久弥新吧。</p>
<p>感觉他对比喻对手法掌控的很好，很多比喻惟妙惟肖，很贴合，很传神。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>李光头明白了自己虽然臭名昭著，可自己是一块臭豆腐，闻起来臭，吃起来香。</li>
<li>宋凡平说：”太阳没有了，还有月亮。”</li>
<li>李光头心想要是阳光像肉丝一样可以吃，风像肉汤一样可以喝就好了。</li>
<li>李兰无限深情地看着桌子、凳子和柜子，无限深情地看着墙壁和窗户，无限深情地看着屋顶的蜘蛛网和桌上的灰尘，她看来看去的眼睛像是海绵在吸水那样。</li>
<li>这就是人世间，有一个人走向死亡，可是无限眷恋晚霞映照下的生活；另两个人寻欢作乐，可是不知道落日的余晖有多么的美丽。</li>
<li>命里只有八分米、走遍天下未满升。</li>
<li>“李光头，你以前对我说过：就算天翻地覆慨而慷了，我们还是兄弟；现在我要对你说：就是生离死别了，我们还是兄弟。”</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Build Your Blog with GitHub Pages+Hexo+NexT</title>
    <url>/2018/12/15/Build-Your-Blog-with-GitHub-Pages-Hexo-NexT/</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2018/12/26/5c231d3ac8a4c.jpg" width="100%"/>

<a id="more"></a>

<blockquote>
<p>环境：<br>Windows 10，x64<br>node.js v10.14.2<br>npm 6.5.0</p>
</blockquote>
<h2 id="GitHub-创建-Github-Pages-项目"><a href="#GitHub-创建-Github-Pages-项目" class="headerlink" title="GitHub 创建 Github Pages 项目"></a>GitHub 创建 Github Pages 项目</h2><p>创建一个名称为<code>username.github.io</code>的新仓库。username 为你的 GitHub 用户名。</p>
<h2 id="搭建Hexo环境"><a href="#搭建Hexo环境" class="headerlink" title="搭建Hexo环境"></a>搭建Hexo环境</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p><a href="https://www.zhihu.com/question/33578075" target="_blank" rel="noopener">Node.js是用来做什么的？ - 知乎</a></p>
</blockquote>
<p><strong>Node.js</strong>是一个 JavaScript 运行环境。</p>
<h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>去<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a>下载对应版本</p>
<p>下载完后双击傻瓜式安装即可</p>
<p>安装完后<strong>win+R</strong> 输入<strong>cmd</strong>打开终端，然后输入<code>node -v</code>即可查看Node版本</p>
<h3 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>npm是Node.js的包管理工具</p>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143450141843488beddae2a1044cab5acb5125baf0882000" target="_blank" rel="noopener">npm安装 - 安装Node.js和npm - 廖雪峰的官方网站</a></p>
<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装完Node.js以后npm已经顺带被安装了。</p>
<p>命令行输入<code>npm -v</code>即可查看npm版本信息。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>新建一个空文件夹，在该目录下右键选择<code>Git Bash Here</code>（需要安装<a href="https://git-scm.com/book/zh/v2/起步-安装-Git" target="_blank" rel="noopener">Git客户端</a>）</p>
<p>执行命令（需要注意的是该命令必须在空目录下执行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h2><blockquote>
<p>Hexo 生成的静态文件统一存放在 public 目录下，其余的文件都是 hexo 用来生成静态网页的。</p>
<p>为了能够适应不同环境(不同主机、不同系统、甚至在 GitHub 网页端操作等)，可以利用 Travis-CI/Gitlab-CI 对 Hexo 博客项目进行<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">持续集成</a>。</p>
</blockquote>
<div class="tabs" id="continuous-integration"><ul class="nav-tabs"><li class="tab active"><a href="#continuous-integration-1">NextT 7.7.1</a></li><li class="tab"><a href="#continuous-integration-2">NextT 5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="continuous-integration-1"><blockquote>
</blockquote>
<p><strong>Travis-CI 的配置文件<code>.travis.yml</code></strong></p>
<div class="tabs" id="travis.yml"><ul class="nav-tabs"><li class="tab active"><a href="#travis.yml-1">我的</a></li><li class="tab"><a href="#travis.yml-2">NexT 的</a></li></ul><div class="tab-content"><div class="tab-pane active" id="travis.yml-1"><figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="comment">#sudo: required # 需要 sudo 权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># addons：插件</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line">  <span class="comment"># 高级打包工具（英語：Advanced Packaging Tools，缩写为APT）是Debian及其衍生的Linux软件包管理器。</span></span><br><span class="line">  <span class="attr">apt:</span></span><br><span class="line">    <span class="attr">packages:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nasm</span> <span class="comment"># Netwide Assembler （简称 NASM）是一款基于英特尔 x86 架构的汇编与反汇编工具。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">node</span> <span class="comment"># node: 指定 Node.js 版本为 latest stable Node.js release</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只监测 source 分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="literal">false</span> <span class="comment"># 克隆深度</span></span><br><span class="line">  <span class="attr">submodules:</span> <span class="literal">false</span> <span class="comment"># Travis CI 默认情况下会克隆Git子模块</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">apt:</span> <span class="literal">true</span> <span class="comment"># 缓存 apt 依赖</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules 目录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="comment"># Git Config</span></span><br><span class="line">  <span class="comment"># 将 Git 子模块中的字符串 'git@github.com:' 替换为 'https://github.com/'</span></span><br><span class="line">  <span class="comment"># https://man.linuxde.net/sed</span></span><br><span class="line"><span class="comment">#  - sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules</span></span><br><span class="line">  <span class="comment"># 配置 Git 用户名</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"gzhennaxia"</span></span><br><span class="line">  <span class="comment"># 配置 Git 邮件</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"gzhennaxia@163.com"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Restore last modified time</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">ls-files</span> <span class="string">-z</span> <span class="string">|</span> <span class="string">while</span> <span class="string">read</span> <span class="string">-d</span> <span class="string">''</span> <span class="string">path;</span> <span class="string">do</span> <span class="string">touch</span> <span class="string">-d</span> <span class="string">"$(git log -1 --format="</span><span class="string">@%ct"</span></span><br><span class="line">  <span class="string">"$path"</span><span class="string">)"</span> <span class="string">"$path"</span><span class="string">;</span> <span class="string">done</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Submodules</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--recursive</span> <span class="string">--remote</span> <span class="string">--init</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">--branch=master</span> <span class="string">--single-branch</span> <span class="string">https://github.com/Gzhennaxia/Gzhennaxia.github.io.git</span></span><br><span class="line">  <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_token:</span> <span class="string">$GH_TOKEN</span>  <span class="comment"># Set in the settings page of your repository, as a secure variable</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">source</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span> <span class="comment"># 要发布到 GitHub Pages 的目录</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="travis.yml-2"><blockquote>
<p><a href="https://theme-next.org/docs/getting-started/deployment#Continuous-Integration" target="_blank" rel="noopener">Continuous-Integration | NexT</a></p>
</blockquote>
<div class="note info">
            <p>根据 NexT 的配置没能成功，所以只是将过程中了解到的配置含义标注了一下</p>
          </div>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span> <span class="comment"># Ubuntu 版本代号 https://zh.wikipedia.org/wiki/Ubuntu%E5%8F%91%E8%A1%8C%E7%89%88%E5%88%97%E8%A1%A8</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span> <span class="comment"># 需要 sudo 权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># addons：插件</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"> <span class="comment"># 添加 ssh 主机</span></span><br><span class="line"> <span class="attr">ssh_known_hosts:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">github.com</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">git.coding.net</span></span><br><span class="line"> <span class="comment"># 高级打包工具（英語：Advanced Packaging Tools，缩写为APT）是Debian及其衍生的Linux软件包管理器。</span></span><br><span class="line"> <span class="attr">apt:</span></span><br><span class="line">   <span class="attr">packages:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">nasm</span> <span class="comment"># Netwide Assembler （简称 NASM）是一款基于英特尔 x86 架构的汇编与反汇编工具。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">global:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">TZ=Asia/Tokyo</span> <span class="comment"># Tokyo：东京，Asia/Tokyo：日本标准时区</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">node</span> <span class="comment"># node: 指定 Node.js 版本为 latest stable Node.js release</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只监测 source 分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"> <span class="attr">only:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line"> <span class="attr">depth:</span> <span class="literal">false</span> <span class="comment"># 克隆深度</span></span><br><span class="line"> <span class="attr">submodules:</span> <span class="literal">false</span> <span class="comment"># Travis CI 默认情况下会克隆Git子模块</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"> <span class="attr">apt:</span> <span class="literal">true</span> <span class="comment"># 缓存 apt 依赖</span></span><br><span class="line"> <span class="attr">directories:</span> </span><br><span class="line">   <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 缓存 node_modules 目录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"> <span class="comment"># Git Config</span></span><br><span class="line"> <span class="comment"># 将 Git 子模块文件中的字符串 'git@github.com:' 替换为 'https://github.com/'</span></span><br><span class="line"> <span class="comment"># https://man.linuxde.net/sed</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">'s/git@github.com:/https:\/\/github.com\//'</span> <span class="string">.gitmodules</span></span><br><span class="line"> <span class="comment"># 配置 Git 用户名</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"YOUR-GITHUB-NAME"</span></span><br><span class="line">  <span class="comment"># 配置 Git 邮件</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"YOUR-EMAIL"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># Restore last modified time</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">"git ls-files -z | while read -d '' path; do touch -d \"$(git log -1 --format=\"@%ct\" \"$path\")\" \"$path\"; done"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># Submodules</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--recursive</span> <span class="string">--remote</span> <span class="string">--init</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># Deploy history</span></span><br><span class="line"> <span class="comment"># 将上次部署的内容(master 分支的 top commit)克隆到 .deploy_git</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">--branch=master</span> <span class="string">--single-branch</span> <span class="string">YOUR-BLOG-REPO</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># SSH Setup</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="string">-K</span> <span class="string">$encrypted_693585a97b8c_key</span> <span class="string">-iv</span> <span class="string">$encrypted_693585a97b8c_iv</span> <span class="string">-in</span> <span class="string">deploy_key.enc</span> <span class="string">-out</span> <span class="string">deploy_key</span> <span class="string">-d</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">eval</span> <span class="string">"$(ssh-agent -s)"</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">./deploy_key</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">ssh-add</span> <span class="string">./deploy_key</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure></div></div></div></div><div class="tab-pane" id="continuous-integration-2"><p><strong>远程仓库创建hexo分支对hexo源码进行版本控制</strong></p>
<ol>
<li><p>将远程仓库clone到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建本地分支hexo并切换到该分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地仓库里的文件清空（除了<code>.git</code>文件），替换为hexo源码文件（即<code>hexo init</code>生成的那些文件）。</p>
</li>
<li><p>添加并提交到本地仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "提交信息"</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并提交到远程hexo分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>GitHub生成Access Token</strong></p>
<p>头像&gt;Settings&gt;Developer settings&gt;Personal access tokens</p>
<p>点击Generate new token生成一个token</p>
<p><img data-src="https://i.loli.net/2018/12/15/5c14c217c5fb9.jpg" alt="img"></p>
<p>注意：token生成后只又一次查看的机会，一定要保存好，否则要删掉重新生成</p>
<p><strong>设置Travis-CI</strong></p>
<p>使用GitHub账号登录<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a></p>
<p><img data-src="https://i.loli.net/2018/12/15/5c14c08f2392e.jpg" alt="img"></p>
<p>点击Settings，将GitHub生成的token添加到里面</p>
<p><img data-src="https://i.loli.net/2018/12/15/5c14c305516b7.jpg" alt="img"></p>
<p><strong>hexo源码仓库中添加Travis-CI的配置文件<code>.travis.yml</code></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span>  <span class="comment">#设置语言</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span>  <span class="comment">#设置相应的版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 开始构建</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span>  <span class="comment">#统一构建环境和博客配置的时区, 防止文章时间错误</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span>  <span class="comment">#配置Hexo环境</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">cl</span>  <span class="comment">#清除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span>  <span class="comment">#生成</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://$&#123;GH_REF&#125;</span> <span class="string">.deploy_git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">../</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mv</span> <span class="string">.deploy_git/.git/</span> <span class="string">./public/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"username"</span>  <span class="comment">#github用户名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"email@xxx.com"</span>  <span class="comment">#邮箱</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Travis CI Auto Builder at `date +"</span><span class="string">%Y-%m-%d</span> <span class="string">%H:%M"`"</span>  <span class="comment">#提交时的说明</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span>  <span class="comment">#GH_TOKEN是在Travis中配置Token的名称</span></span><br><span class="line"><span class="comment">## 结束构建</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span>  <span class="comment">#只监测master之外新增的hexo分支</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">global:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/username/username.github.io.git</span>  <span class="comment">#设置GH_REF</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span>  <span class="comment">#缓存特定目录, 加快构建速度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理图</p>
<p><img data-src="https://i.loli.net/2018/12/25/5c219ecc93bcd.png" alt="img"></p>
</blockquote></div></div></div>

<h2 id="主题升级"><a href="#主题升级" class="headerlink" title="主题升级"></a>主题升级</h2><blockquote>
<p>为了更平滑的升级 NexT 主题，推荐使用 <a href="https://theme-next.org/docs/getting-started/data-files" target="_blank" rel="noopener">Hexo-Way</a></p>
</blockquote>
<div class="tabs" id="upgrade-theme"><ul class="nav-tabs"><li class="tab active"><a href="#upgrade-theme-1">Developer-Way</a></li><li class="tab"><a href="#upgrade-theme-2">Hexo-Way</a></li><li class="tab"><a href="#upgrade-theme-3">NexT-Way</a></li></ul><div class="tab-content"><div class="tab-pane active" id="upgrade-theme-1"><div class="note ">
            <p>使用 <code>Hexo-Way</code> 的话，每次对站点配置文件的改动，需要重新执行 <code>Hexo s</code> 才能预览结果。但 NexT 是有热部署的，启动后直接刷新即可。但是采用 <code>NexT-Way</code> 的话，更新主题时，关于自定义的改动（除了主题配置文件以外的文件的改动）还是需要解决合并冲突的。所以还不如就全部通过合并冲突来解决。</p>
          </div>

<p>直接在主题目录下执行 <code>git pull</code>，在 <code>WebStrom</code> 等 IDE 中解决冲突即可。IDE 对合并冲突都有很好的支持。</p></div><div class="tab-pane" id="upgrade-theme-2"><div class="note info">
            <p>如果使用 <code>Hexo-Way</code> 方式，那关于 <code>favicon</code> <code>avatar</code> 等配置在本地环境中会失效(因为路径问题)，但不影响线上效果。</p>
          </div>

<ol>
<li><p>确保不存在 <code>/source/_data/next.yml</code> 文件</p>
</li>
<li><p>站点配置文件中添加 <code>theme_config</code> 属性</p>
</li>
<li><p>将需要的配置从主题配置文件中 Copy 到该属性下。</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># Sidebar Avatar</span></span><br><span class="line">  <span class="attr">avatar:</span></span><br><span class="line">    <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">    <span class="comment">#  url: #/images/avatar.gif</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">    <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">    <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">    <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>想要升级时，只需在终端里切到 <code>themes/next</code> 目录下，执行 <code>git pull</code> 命令，并将需要改动的配置 Copy 到站点配置文件中即可。</p></div><div class="tab-pane" id="upgrade-theme-3"><blockquote>
<p><a href="https://theme-next.org/docs/getting-started/data-files" target="_blank" rel="noopener">Date File</a></p>
</blockquote></div></div></div>

<h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h2><blockquote>
<p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a></p>
</blockquote>
<h3 id="网页图标"><a href="#网页图标" class="headerlink" title="网页图标"></a>网页图标</h3><blockquote>
<p><a href="https://theme-next.org/docs/getting-started/#Configuring-Favicon" target="_blank" rel="noopener">Configuring Favicon | NexT</a></p>
</blockquote>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="attr">android_manifest:</span> <span class="string">/images/manifest.json</span></span><br><span class="line">  <span class="attr">ms_browserconfig:</span> <span class="string">/images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<h3 id="头像旋转"><a href="#头像旋转" class="headerlink" title="头像旋转"></a>头像旋转</h3><div class="tabs" id="avatar"><ul class="nav-tabs"><li class="tab active"><a href="#avatar-1">NexT 7.7.1</a></li><li class="tab"><a href="#avatar-2">NexT 5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="avatar-1"><blockquote>
<p><a href="https://theme-next.org/docs/getting-started/#Configuring-Avatar" target="_blank" rel="noopener">Configuring-Avatar | NexT</a></p>
<p><a href="https://favicon.io/" target="_blank" rel="noopener">The ultimate favicon generator</a></p>
</blockquote>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="avatar-2"><blockquote>
<p><a href="http://www.iooeo.com/2017/07/20/Hexo-Next-头像圆形并旋转/" target="_blank" rel="noopener">Hexo Next 头像圆形并旋转</a></p>
</blockquote>
<p>注意<a href="https://www.zhangxinxu.com/jq/stylus/comments.php" target="_blank" rel="noopener">stylus中文版参考文档之注释(Comments)</a></p>
<p>单行注释使用<code>//</code>,多行使用<code>/* */</code></p>
<p>修改<code>/themes/next/source/css/_common/components/sidebar/sidebar-author.styl</code>如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="built_in">hexo-config</span>(<span class="string">'avatar.opacity'</span>) is a <span class="string">'unit'</span> ? <span class="built_in">hexo-config</span>(<span class="string">'avatar.opacity'</span>) : <span class="number">1</span>;</span><br><span class="line">  // 头像圆形样式</span><br><span class="line">  <span class="comment">/* start */</span></span><br><span class="line">  <span class="selector-tag">border-radius</span>: 50%</span><br><span class="line">  <span class="selector-tag">webkit-transition</span>: 1<span class="selector-class">.4s</span> <span class="selector-tag">all</span>;</span><br><span class="line">  <span class="selector-tag">moz-transition</span>: 1<span class="selector-class">.4s</span> <span class="selector-tag">all</span>;</span><br><span class="line">  <span class="selector-tag">ms-transition</span>: 1<span class="selector-class">.4s</span> <span class="selector-tag">all</span>;</span><br><span class="line">  <span class="selector-tag">transition</span>: 1<span class="selector-class">.4s</span> <span class="selector-tag">all</span>;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if hexo-config('avatar.rounded') &#123;</span><br><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if hexo-config('avatar.rotated') &#123;</span><br><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-ms-transition</span>: -ms-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-image</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-name</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: $site-author-name-margin;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-author-name-align;</span><br><span class="line">  <span class="attribute">color</span>: $site-author-name-color;</span><br><span class="line">  <span class="attribute">font-weight</span>: $site-author-name-weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-description</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: $site-description-margin-top;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-description-align;</span><br><span class="line">  <span class="attribute">font-size</span>: $site-description-font-size;</span><br><span class="line">  <span class="attribute">color</span>: $site-description-color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 头像旋转事件</span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  <span class="attribute">webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="文章预览"><a href="#文章预览" class="headerlink" title="文章预览"></a>文章预览</h3><blockquote>
<p><a href="http://theme-next.iissnan.com/faqs.html#read-more" target="_blank" rel="noopener">如何设置「阅读全文」？</a></p>
</blockquote>
<h4 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h4><ol>
<li><p>关闭<strong>主体配置文件</strong>中的<code>Automatically Excerpt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Automatically excerpt description <span class="keyword">in</span> homepage as preamble text.</span></span><br><span class="line">excerpt_description: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please use &lt;!-- more --&gt; <span class="keyword">in</span> the post to control excerpt accurately.</span></span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>手动截断标签</code>上只放一张图片即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![NexT](https://i.loli.net/2018/12/26/5c231d3ac8a4c.jpg)</span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><blockquote>
<p><a href="https://ryanluoxu.github.io/2017/11/27/Hexo-Next-添加-Gitment-评论系统/" target="_blank" rel="noopener">Hexo-Next 添加 Gitment 评论系统</a></p>
<p><a href="https://xiaotiandi.github.io/publicBlog/2018-09-19-d196c9ad.html" target="_blank" rel="noopener">hexo博客配置-添加评论系统-gitment和valine-需注册</a></p>
<p><a href="https://meesong.github.io/StaticBlog/2017/NexT+Gitment/" target="_blank" rel="noopener">为 hexo NexT 添加 Gitment 评论插件</a></p>
<p><a href="https://github.com/gitalk/gitalk/wiki/在hexo-next主题上使用gitalk" target="_blank" rel="noopener">在hexo next主题上使用gitalk</a></p>
<p><a href="https://www.bluelzy.com/articles/use_valine_for_your_blog.html" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p>
</blockquote>
<p><img data-src="https://i.loli.net/2018/12/17/5c171d0e2a281.jpg" alt="img"></p>
<p><img data-src="https://i.loli.net/2018/12/17/5c171f261cf6c.jpg" alt="img"></p>
<p>由于gitment长期未维护,所有最后使用gitalk,之后可以增加其他三方的评论插件更加灵活.</p>
<p>如需取消某个 页面/文章 的评论，在 md 文件的 <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">front-matter </a>中增加 <code>comments: false</code></p>
<h3 id="自定义内建标签"><a href="#自定义内建标签" class="headerlink" title="自定义内建标签"></a>自定义内建标签</h3><blockquote>
<p><a href="https://blog.rmiao.top/hexo-fold-block/" target="_blank" rel="noopener">Hexo next博客添加折叠块功能添加折叠代码块</a></p>
</blockquote>
<h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><blockquote>
<p><a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener"><strong>theme-next-pace</strong></a></p>
</blockquote>
<h3 id="自定义页面样式"><a href="#自定义页面样式" class="headerlink" title="自定义页面样式"></a>自定义页面样式</h3><blockquote>
<p><a href="http://www.cduyzh.com/hexo-settings-3/" target="_blank" rel="noopener">2017年最新基于hexo搭建个人免费博客——自定义页面样式一</a></p>
<p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#优化-网页样式布局" target="_blank" rel="noopener">优化 网页样式布局</a></p>
</blockquote>
<h4 id="调整文章元信息区域离文章主体的间距"><a href="#调整文章元信息区域离文章主体的间距" class="headerlink" title="调整文章元信息区域离文章主体的间距"></a>调整文章元信息区域离文章主体的间距</h4><p>一般文章都会添加<code>description</code>和一张图片作为封面，但元信息离正文太远视野上不舒服，故做如下调整。</p>
<p><img data-src="https://i.loli.net/2018/12/26/5c23347219069.jpg" alt="Before"></p>
<div class="tabs" id="posts-expand"><ul class="nav-tabs"><li class="tab active"><a href="#posts-expand-1">NexT 7.7.1</a></li><li class="tab"><a href="#posts-expand-2">NexT 5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="posts-expand-1"><p>修改<code>themes/next/source/css/_schemes/Mist/_posts-expand.styl</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// before</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.home</span> &#123;</span><br><span class="line"></span><br><span class="line">  .post-meta &#123;</span><br><span class="line">    <span class="selector-tag">margin</span>: 5<span class="selector-tag">px</span> 0 20<span class="selector-tag">px</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// before</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.home</span> &#123;</span><br><span class="line"></span><br><span class="line">  .post-meta &#123;</span><br><span class="line">    <span class="selector-tag">margin</span>: 5<span class="selector-tag">px</span> 0 10<span class="selector-tag">px</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="posts-expand-2"><p>修改<code>themes\next\source\css\_common\components\post\post-meta.styl</code>如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// before</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>



<p>修改<code>themes\next\source\css\_common\components\post\post-meta.styl</code>如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// before</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在 Next.7 中，上述文件及改动如下</p>
<p><code>themes/next/source/css/_schemes/Mist/_posts-expand.styl</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// before</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.home</span> &#123;</span><br><span class="line"></span><br><span class="line">  .post-meta &#123;</span><br><span class="line">    <span class="selector-tag">margin</span>: 5<span class="selector-tag">px</span> 0 20<span class="selector-tag">px</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// before</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.home</span> &#123;</span><br><span class="line"></span><br><span class="line">  .post-meta &#123;</span><br><span class="line">    <span class="selector-tag">margin</span>: 5<span class="selector-tag">px</span> 0 10<span class="selector-tag">px</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="显示文章更新时间"><a href="#显示文章更新时间" class="headerlink" title="显示文章更新时间"></a>显示文章更新时间</h3><blockquote>
<p><a href="https://blog.csdn.net/ganzhilin520/article/details/79053399" target="_blank" rel="noopener">hexo添加文章更新时间</a></p>
</blockquote>
<p>修改主题配置文件的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">updated_at:</span> </span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>要想具体显示到时分秒,则修改站点配置文件的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure>

<h3 id="复制代码按钮"><a href="#复制代码按钮" class="headerlink" title="复制代码按钮"></a>复制代码按钮</h3><blockquote>
<p><a href="https://www.ofind.cn/blog/HEXO/HEXO优化之（二）-添加复制功能.html" target="_blank" rel="noopener">HEXO优化之（二）—-添加复制功能</a></p>
<p><a href="http://www.missfli.com/2018/06/19/github-hexo-next-08.html" target="_blank" rel="noopener">Hexo NexT主题代码块添加复制功能</a></p>
</blockquote>
<h3 id="显示当前浏览进度"><a href="#显示当前浏览进度" class="headerlink" title="显示当前浏览进度"></a>显示当前浏览进度</h3><blockquote>
<p><a href="https://www.jianshu.com/p/3ff20be8574c" target="_blank" rel="noopener">7.浏览页面的时候显示当前浏览进度</a></p>
</blockquote>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><blockquote>
<p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/#添加背景图" target="_blank" rel="noopener">添加背景图</a></p>
</blockquote>
<h3 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h3><blockquote>
<p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">hexo-blog-encrypt</a></p>
</blockquote>
<p>注意实在<strong>站点配置文件</strong>中添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="给文章添加密码："><a href="#给文章添加密码：" class="headerlink" title="给文章添加密码："></a>给文章添加密码：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hello</span> <span class="string">world</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016</span><span class="number">-03</span><span class="number">-30</span> <span class="number">21</span><span class="string">:18:02</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">fdsfadsfa</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">fdsafsdaf</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">Mike</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">Welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">blog,</span> <span class="string">enter</span> <span class="string">password</span> <span class="string">to</span> <span class="string">read.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">Welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">blog,</span> <span class="string">enter</span> <span class="string">password</span> <span class="string">to</span> <span class="string">read.</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<ul>
<li>password: 是该博客加密使用的密码</li>
<li>abstract: 是该博客的摘要，会显示在博客的列表页</li>
<li>message: 这个是博客查看时，密码输入框上面的描述性文字</li>
</ul>
<h3 id="二次元看板娘"><a href="#二次元看板娘" class="headerlink" title="二次元看板娘"></a>二次元看板娘</h3><blockquote>
<p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">hexo-helper-live2d</a></p>
</blockquote>
<h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><blockquote>
<p><a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">theme-next/<strong>hexo-generator-searchdb</strong></a></p>
</blockquote>
<ol>
<li><p><code>npm install hexo-generator-searchdb --save</code></p>
</li>
<li><p><strong>站点配置文件</strong>中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主题配置文件</strong>中打开如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="文章置顶-置顶标签"><a href="#文章置顶-置顶标签" class="headerlink" title="文章置顶+置顶标签"></a>文章置顶+置顶标签</h3><blockquote>
<p><a href="https://blog.csdn.net/qwerty200696/article/details/79010629" target="_blank" rel="noopener">hexo博客优化之文章置顶+置顶标签</a></p>
<p><a href="https://github.mayuxiao.com/swig.zh-CN/docs/index.html#comments" target="_blank" rel="noopener">Swig » 文档 » 注释</a></p>
</blockquote>
<ol>
<li><p>使用插件<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">hexo-generator-index-pin-top</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-generator-index</span> <span class="string">--save</span></span><br><span class="line"><span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-index-pin-top</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code></p>
</li>
<li><p><code>/blog/themes/next/layout/_macro</code> 目录下的<code>post.swig</code>文件，定位到``标签下，做如下修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-meta"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            &#123;% set date_diff = date(post.date) != date(post.updated) %&#125;</span><br><span class="line">            &#123;% set time_diff = time(post.date) != time(post.updated) %&#125;</span><br><span class="line">            &#123;% set datetime_diff = date_diff or time_diff %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;# 置顶标签 #&#125;</span><br><span class="line">            &#123;% if post.top %&#125;</span><br><span class="line">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">FFC0CB</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">            &#123;# 置顶标签 #&#125;</span><br><span class="line">            ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/20641764" target="_blank" rel="noopener">“知识共享”（CC协议）简单介绍</a></p>
</blockquote>
<div class="tabs" id="creative-commons"><ul class="nav-tabs"><li class="tab active"><a href="#creative-commons-1">NetT 7.7.1</a></li><li class="tab"><a href="#creative-commons-2">NetT 5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="creative-commons-1"><blockquote>
<p><a href="https://theme-next.org/docs/theme-settings/#Creative-Commons" target="_blank" rel="noopener">Creative Commons | NexT</a></p>
</blockquote></div><div class="tab-pane" id="creative-commons-2"><ol>
<li><p>修改<strong>主题配置文件</strong>中如下配置：</p>
<figure class="highlight yaml"><figcaption><span>\source\_data</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<strong>站点配置文件</strong>中如下配置：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://username.github.io</span></span><br></pre></td></tr></table></figure>

</li>
</ol></div></div></div>

<h3 id="首页隐藏指定文章"><a href="#首页隐藏指定文章" class="headerlink" title="首页隐藏指定文章"></a>首页隐藏指定文章</h3><div class="tabs" id="hide"><ul class="nav-tabs"><li class="tab active"><a href="#hide-1">使用 hexo-hide-posts 插件</a></li><li class="tab"><a href="#hide-2">修改 index.swig 文件</a></li></ul><div class="tab-content"><div class="tab-pane active" id="hide-1"><blockquote>
<p><a href="https://printempw.github.io/hexo-plugin-to-make-posts-sage-unlisted/" target="_blank" rel="noopener">为 Hexo 博客添加隐藏文章功能</a></p>
<p><a href="https://vanchchen.github.io/p/7587.html" target="_blank" rel="noopener">如何优雅的隐藏 Hexo 博客文章</a></p>
</blockquote></div><div class="tab-pane" id="hide-2"><blockquote>
<p><a href="https://blog.csdn.net/m0_37323771/article/details/80672271" target="_blank" rel="noopener">Hexo 设置首页隐藏指定文章</a></p>
</blockquote>
<ol>
<li><p>对主题 index.swig 文件做如下修改</p>
<figure class="highlight swift"><figcaption><span>Hexo\themes\next\layout</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> post <span class="keyword">in</span> page.posts %&#125;</span><br><span class="line">    &#123;# 首页隐藏指定文章 #&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> post.hidden != <span class="literal">true</span> %&#125;</span><br><span class="line">        &#123;&#123; post_template.render(post, <span class="literal">true</span>) &#125;&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;# 首页隐藏指定文章 #&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要首页隐藏的文章 front-matter 中添加 <code>hidden: true</code></p>
</li>
</ol></div></div></div>

<h3 id="Emoji-表情"><a href="#Emoji-表情" class="headerlink" title="Emoji 表情"></a>Emoji 表情</h3><blockquote>
<p><a href="https://chaxiaoniu.oschina.io/2017/07/10/HexoAddEmoji/" target="_blank" rel="noopener">Hexo中添加emoji表情</a></p>
<p>Hexo默认采用 <a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a> 这个渲染器，但其不支持插件扩展。还有一个支持插件扩展的是 <a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">hexo-renderer-markdown-it</a>，可以使用 <a href="https://github.com/markdown-it/markdown-it-emoji" target="_blank" rel="noopener">markdwon-it-emoji</a> 插件来支持 emoji。</p>
</blockquote>
<ol>
<li><p>替换渲染器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>markdown-it-emoji</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i markdown-it-emoji --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>站点配置文件添加 markdown-it 配置</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">## hexo-renderer-markdown-it</span></span><br><span class="line"><span class="comment">## Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">'“”‘’'</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span>  <span class="comment">## add emoji</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">'v'</span></span><br><span class="line">    <span class="comment"># If `true`, creates an anchor tag with a permalink besides the heading.</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="comment"># The symbol used to make the permalink</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">¶</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<p>在 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">EMOJI CHEAT SHEET</a> 中找你想要的表情，点击即可复制。😄</p>
</li>
</ol>
<h3 id="文件下载功能"><a href="#文件下载功能" class="headerlink" title="文件下载功能"></a>文件下载功能</h3><ol>
<li>在 <code>source</code> 目录下，新建 <code>download</code> 目录</li>
<li>通过诸如 <code>[点击下载 xxx.pdf](/download/xxx.pdf)</code> 这样的链接，提供下载功能。</li>
</ol>
<h3 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h3><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件 ｜ Hexo</a></p>
<p><a href="https://theme-next.org/docs/tag-plugins/" target="_blank" rel="noopener">标签插件| NexT</a></p>
<p><a href="https://jinnsjj.github.io/uncategorized/hexo-next-note/" target="_blank" rel="noopener">在hexo-NexT中插入note提示块</a></p>
</blockquote>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a><a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">Note</a></h4><div class="note default">
            <p>default 提示块标签</p>
          </div>

<div class="note primary">
            <p>primary 提示块标签</p>
          </div>

<div class="note success">
            <p>success 提示块标签</p>
          </div>

<div class="note info">
            <p>info 提示块标签</p>
          </div>

<div class="note warning">
            <p>warning 提示块标签</p>
          </div>

<div class="note danger">
            <p>danger 提示块标签</p>
          </div>

<p>主题配置文件中修改风格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Note tag (bs-callout)</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">flat</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a><a href="https://theme-next.org/docs/tag-plugins/tabs" target="_blank" rel="noopener">Tabs</a></h4><div class="tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#first-unique-name-1">First unique name 1</a></li><li class="tab"><a href="#first-unique-name-2">First unique name 2</a></li><li class="tab"><a href="#first-unique-name-3">First unique name 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs First unique name %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="填坑记录"><a href="#填坑记录" class="headerlink" title="填坑记录"></a>填坑记录</h2><h3 id="选用主题后页面空白"><a href="#选用主题后页面空白" class="headerlink" title="选用主题后页面空白"></a>选用主题后页面空白</h3><p>原因：themes目录下主题相关文件未正确提交到远程仓库</p>
<p>解决：</p>
<ol>
<li>删除主题目录下的<code>.git</code>目录和<code>.gitignore</code>文件</li>
<li><code>git rm --cached 主题目录</code></li>
<li><code>git add 主题目录</code></li>
<li><code>git push</code></li>
</ol>
<h3 id="命令-hexo-d-无反应"><a href="#命令-hexo-d-无反应" class="headerlink" title="命令 hexo d 无反应"></a>命令 <code>hexo d</code> 无反应</h3><p>原因：站点配置文件中关于部署的部分没有配置</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>

<p>解决方法：补充相关配置</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Gzhennaxia/Gzhennaxia.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="命令-hexo-d-报错：ERROR-Deployer-not-found-git"><a href="#命令-hexo-d-报错：ERROR-Deployer-not-found-git" class="headerlink" title="命令 hexo d 报错：ERROR Deployer not found: git"></a>命令 <code>hexo d</code> 报错：<code>ERROR Deployer not found: git</code></h3><p>原因：没安装<code>hexo-deployer-git</code>插件</p>
<p>解决方法：安装<code>hexo-deployer-git</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">布局</a></p>
</blockquote>
<p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th align="left">布局</th>
<th align="left">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">post</td>
<td align="left">source/_posts</td>
</tr>
<tr>
<td align="left">page</td>
<td align="left">source</td>
</tr>
<tr>
<td align="left">draft</td>
<td align="left">source/_drafts</td>
</tr>
</tbody></table>
<h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><p>Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立文章时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo publish [layout] &lt;filename&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p><code>hexo new</code>命令新建文章时会将特殊字符（空格、加号等）转化为<code>-</code></p>
<p>eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="string">"GitHub Pages+Hexo+NexT"</span></span></span><br><span class="line">INFO  Created: E:\xxx\Hexo\source\_posts\GitHub-Pages-Hexo-NexT.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>publish</code>命令发布草稿时需要用<strong>文件名</strong>，而不是文章标题</p>
<p>eg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo publish post GitHub-Pages-Hexo-NexT <span class="comment"># post可以省略，因为layout默认就是post</span></span></span><br><span class="line">INFO  Published: E:\Github\Hexo\source\_posts\GitHub-Pages-Hexo-NexT.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件名为空时默认发布第一篇草稿</p>
<p>eg：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo publish post .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo publish post <span class="string">""</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html#代码块" target="_blank" rel="noopener"><strong>指定语言，附加说明和网址</strong></a></p>
<ol>
<li><p>Hexo 格式</p>
<p>代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:java title http:<span class="comment">//www.baidu.com link test %&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p>样式：</p>
<p><img data-src="https://i.loli.net/2019/01/04/5c2ec9c02da97.jpg" alt="img"></p>
</li>
<li><p>Markdown 格式</p>
<p>代码：</p>
<figure class="highlight java"><figcaption><span>title</span><a href="http://www.baidu.com" target="_blank" rel="noopener">link test</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式：</p>
<p><img data-src="https://i.loli.net/2019/01/04/5c2ec9c02da97.jpg" alt="img"></p>
</li>
</ol>
<h3 id="引用站内文章"><a href="#引用站内文章" class="headerlink" title="引用站内文章"></a>引用站内文章</h3><blockquote>
<p><a href="https://www.jibing57.com/2017/10/30/how-to-use-post-link-on-hexo/" target="_blank" rel="noopener">Hexo引用站内文章</a></p>
</blockquote>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4>   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% post_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>slug</p>
<p>_posts 文件夹下需要引用的文章的 markdown 文件的名字，不带后缀</p>
</li>
<li><p>title</p>
<p>链接显示的文字</p>
</li>
</ul>
<h4 id="eg："><a href="#eg：" class="headerlink" title="eg："></a>eg：</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% post_link <span class="type">Comments</span> 留言板 %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p><a href="https://libo9527.github.io/2019/01/03/Comments/" target="_blank" rel="noopener">留言板</a></p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><blockquote>
<p><a href="https://www.jianshu.com/p/c5d333e6353c" target="_blank" rel="noopener">next主题的模板引擎swig语法介绍</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Bath</title>
    <url>/2020/02/23/Bath/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Third warning: This content is personal, please skip it." data-whm="Fourth warning: This content is personal, please skip it."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Warning again: This content is personal, please skip it." /><label>Warning again: This content is personal, please skip it.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5df3fa3f4ce2706000cf1a311cb9230080750ad006c5acbfb02510ebca4ae7d3">584a38899169f1fa8f2a81f6311dcde5a22a81e97cc358eda02c635ef74a90dca68287dafd891385a187d215f21af552ca71209eea5ffc742094255d55a99fe15978e2f9d8e39d643eb0f0a8fdbc9d83bf06ef23f600c2da88f53122f1cccdadfae19461451da688b124c9b12b08b7b3e400f8f975c2bff63c0863c6087bf551328e9de21876a6524b24d93775d90f36488be9c2e38e65723a5cce6869274a5f8c5230cde5a882e02b669b6e73d74ecdf871b5231bafe39010867ed5ce3af51d9d88c6d328a3a0e14b53ea904d9b9ca331ff07bebbe75451fe0d8e80ddb9665e885db8a5235b445dc5c7c8468be83c232671273d26fd287939532ba3e4d0d3d9b33b1d385f4cc4d608d0bafd6349a7348ea2f5996476cd66114505175d98207c475d5e6180f19e88ae44f589e961c27b307e19441becc3a440cd2edf0144711112e465dc2a4760dcb68aa55696940eeb0fc3cd03e044bbd8529fa019f02db1ff685023477cc3e33dc68ce747864deb350de604f1efa6c7daa262ac02976f647ca87972e1f46c811f95ccb65f2d1c027684ef2ce7be452f3c9c29d6a058aba7f35288b7908119558c238be9ebc693812dccb3f1abe690d1c15e6531d4cad6cb2761fced03a44b2591c2f8e99f92c2ffbf4e81bb99bb0295c7a988a39d879bca248beef23c2f6f3e877b71a8184f720274c8aa8db724a03e44028d72d822f646650084407700abaa73fd2ea796c68e5f38133d90895509f96d2a842997dacfe17550f69624a17a5ab23b53cc7db009d3daf159be37ff13fd30a621a4ca7613a380619a0e5b9b9d9fd6fde302e180883e690da4ce65b2209d0c08900dfa2b2a390ee57dbb91856aaf55eeb9a1fde5ffbbcc015471a33e555468c7fd653b00fa2281039297b25952304987094cadae2acfc46ea13d7424d8d59de1a9bac9a3a50018e5435084bc69a90e8e0ae40bc815770ae33988d5d3aaf0443b402f30a7b2c9fef8c619b8c28543950470be1dcde7fb49c925a7cef110322ef40acbd90e214a5fab7e6a62a3b5deb5d62b7c1f55cf1fffb90c1cf8404a4a9bb8fa48540a2540779c085570af866c83ad1905fd3e95fc6b19bf11b6ac2eb07b8b2439a535fe33f3b9ed97f22b508814154d0ff7e0d0e5f9c6a5dab5133acafb3f5ed37e99dd653219dc82250d8d9e2ae20d510027b9cd824c4d90c6dc7bc00f6532660d78e2fa1ef7f2301ca2dd133e1f0dffe313d331b6144bf32397bf56fe90c66a606fb0364722cd9479abe78b86ea0df2f222a12e9cfb714cc60172a0e976af25fbc8e7d04d335f887bc03493b10f45c28712ddd760d692acd529e5d51be4d4d7fccc02b865ed436bce149862358d9b56cd079921f3e839fde48a91c571462582870e3339ad4a12639f428c0d5048d34ea325dbd5d04f93f4349f99c58020c1dd5a99a917945123db14898a76776b127321bf28f67d4da47ed6b953bf4e1949cb5292cdffe1834e45fa8fad366d9c3d1c7a7e07d2ff8c1012843b942a063ddb00a2064493c01ce54fc6c719a7b86e9e86d0522aba9280c2f339b3357acbe1989b5af9f9d4aa821ea3ac5747498c7216f8df13baba4f85a96f1fb10a96895f4be7912fbc178a3278b9b6c9b5d9aaf43ff8fc2762d242ba038a0d481ce2efe68212c4901fd5c512c58f9386d0a0d5ee5c2ebc4339f21b4a2efa0a2fd2d7d3a8bfafd03bef81ed2a248be7c1c23e8f781b1b4ff133b6aaa73dc7b86e6403cdb6f91d0211d3fc6d6b80d3e610d5b0c09ad3ed3ec04ed0c72aaf50394f05db8889e3fc44f33998731388abf9efafbbcc681cdc7e30c459355a2addde1cb6891447308dfd026c6fb7a68953262762366ffb695fb92ec7fc5f545318cafa23c7ec8e88ef7bfde519714aa561a9d84ba5d0ce1e5f5f4768acfd4dd195ee11771072df543359f7ca355687f0f8423f32299e5a91b39b95513ba21243ee18929f38ff00f2b4bcaa16aa7fc47d8f2bb1ec89d231d14c63d9c4b209a630fa757afd53b445c11ea4d7a4f5ce7a194efd69d878ac64e713cb3651cce4c298230d773d316e04bc4b4e6c0c6d81bd5aaf60e3b119a6a6326767577de05da21f6733997ba6b76a37be09ba7eb3bc89fa342cfe64a8d6298ee8bbf1a9ba4b63e6299ba85dfa72fafc47bf5cce7d64fe0ee8628f3e4265d49a3b2fc45bd8bcc1e1b2ffc0b8fbbbbaf270e8155b7b676bb023801e05301dd7ffc731d963794b7c2d7a4894ad4d64e4e94101e11ac28aeee544a5f9944561cf4fc8260daa459b07932f659f73f853980b6c229cee80e9b29db5dc2cc32f501fc6159f09efcdfe59b82449e04e705d035d4ee48d6ca923367a5489cc7b13100349f11d48c7d4f5a90c4701e47eb4eceefbaa218fa583437c4f110fc56af863aea9d344e090cde975dc7271f17716d85007f669cf47aeeb56126c37f1fec8aee1fd7ba267f8da28a854ecb72466b8ca63a599ee64af07594d322e5529d83fc02285fa922cab4400edd666fb652e6fd6aaffadf0b6393398bfae5bd2cdb2a02ce9f70fd620e5194b714a558e2267cc2b946798f050814ced0c3f08b22cedddc9b50b0a8b1240e6e9762db765a31a2c90baa0ac56a6a36e63a864e2ec74722723dd1ceec42b8b1787e1ad7e3c12c605fd7a98c2332e9dec1861d1b4f85477ac4c49945be69855d06372451d9f5f89c1351b27953aff67b759ba63cdbc4953e2271f6a9a47517a6fe8085093c6798b25a40250fe68b7b2089582db035be3ab5bdad84d7b60ed120628fa88580e7c867b7e38d965313d1d28c82505c060f0aca48b9d58889c2e1ccbbae274d83c2d530a4379437b1263124961da55bfe03f2dfde552aa8e7e3ffa0a096cb00db368fc49b9f3c84ce4855d43854b238105b51a6e14afe9b5eac9d24be14d31650a0b7b84f501c61c33f5129b43981f9be530d96bb68a3b9b44aa9257dcbd099e1b04ddc3003f04540e038138cd631e090f21df8c7f32b4fd2b24a8cca4b347d235c6577d542b464d08527c4d08fbc6cb56d68d75f8511e0d18998c9a2613bc8ffd0aa05798ea83add4d66c0c2bfcb73964095218fadd56b6b7acefc45da76b4b10213d165b1526216fcc0e7fc69f9c156084b4aa40ebb7b13426b29b6c8462ef716973cd4e37a204607a04a510a1ffb5b495c20039728bc00762196929e4291f33ab82d10f1ed22ec9fe51963b0f08c3d1dcfe68ed9fff232eda863f4ef360bc04fe8be0611e56740b46ffeae43d2685002e06b164662656194b3917c1c308a007ea52b2384afd407a3a4f0631ae77ae6d614e667b4ab793cc2ab8e47d0c62b0c04afef5407b8dc0bb8bc4f8f1c60541791d5ec7841cbd10afcc70d4e79d7146ee418037207d7fbeb3fb0ac4528eb331657146a563655f54b16b8a6e1ae6273f1f934ea408bdcad9aa9264b8045d8ae3eb8e6276656a7243ec2c490a746ad13e92317d0719170a81866ee7f79aeec4b08b57872c83c7f6596bf4c6200125e231233b0846981927b7c71efa6b26e6ec99de4a5d3cc273bf4fb9e86a1915e9dd353b3ff69fd6d8feeed4092b489a5fcd1582bd762473620a8c613536827e437784bbca08a57e24357598bbd587ef5417f01f8076f58569357a5e00e04cce82914743079493576110411c41a8b9aa4a57571769e6391766481d31db020a2949135295f3eaab03c65cad08486dfd58c15fcd7ab2facb35d1537d9fed18a47329f67aa770178c9d5f4a419c32454b7872e483437bfc16a8c30f595c104f2c9f199368fb9d131d8374c10c8de4780113b93148d49cf90938005323ad048d9cb34048a1a041ff79393fad235f7d50211a4884843fc6f50807e96539f31add0e2c0fbb83f231a6bec1ee93100e2b30a3392a00a4ade40067cf52eb8d3eb6bffff0e024c5c7523db34835fd73ff6ce5d2ad6b5aa783ef325a474568a633ff3fa80a808ef4f577942be88d2df1dcb5b3197ac545e3853b7e5f3f93a5b8c9602ec9ad31beaba0c1dcb9f724a796355f7f45d8a75b45497dac0465899906cdcd1ef109d053e0735dbc14e7bdca180826823e5988d53a0a4a4b8ed8f65a683cce2a139db8049f5236730b83f52f8fda64e462243f6922ccb473e47cffe29250d3d5a8df900f0e219721b6c99a1cb6afc4184713f8e0a0bf85b1d749d47b0cd0c16336a2bbf3b01c793f904ddbe38d7dc36a39193a690baef06f712c618d853196e25f17e1dfd2e4c6e7737fa5ba15f808d9da3a1937c61f189c6814dd403321f14f14e877366642b5042a3c010f241f52b65f2167e1010f274e2692d94559d55e496c3a9e179385746797943e71686ff2dcdb57c3b4f5047c5938555a7bf062f5eaf15d0f2fd1e652493af323d56383adc2e1f5980ad2212de9bece5d4971f00833edd3a418d0d1698f21e927f4358d633a7b168e84adc3806adcfd7030dd31bfd6e1a3a9b3d87860b75ab4176beaf227e84709e67a0062da01b38e3c5bfed4bce57a54221ac801ee1b17a96ba45a0a4459073741edb2bfe73e7a95031ab5dc466293bb9e936fd4bea93fc424b59344b709db6d96a48f2f5b9c0868e90495faebd0d85e4fb54a763072fcf9714135030ead07cec76b34172e0de4b1c2b066fe5a5f3fd8271612b11e3f9acefc227eb3e7fd4a71061a2604d3a5b5605c77075840072ffba0aa3837c7b86bdc3e380d4681b4b2720bcf7f9967a3034f28a262fd7db0974f45bb17d612cb90c33fa0b5ad25ccaae62793037e4757a0f975b9af260d490a9b196b1bd086df246e2d10bb5908e59a7d9fe7602e749cbd97fecfbb5a8398290f7a13828f13927f38c40115ec45921d4ed33f3d948e0f98c93dece7fca3d052cdf9d425cf98a794f0ccf1f66c53851f8ec39c4db30cf0f9bf067c94816c65d60c9cff5f85c9ac36af895bbac8b67e17a9d13a384cd7adae460591c3928a5cc2ac1d770268fb4ffd9ab0a1504633243ed0b666f23f254a96547ae5d0f656ba77cbbde3650cf44f3ed36a6d14ca8a119e6471af4915bd53e45bb69741df69abeb1cb0dee8666c57bc391dd7ef1fb875df84ccb9eeaf9274ff0fad65c74f6a32a256602b3c1fd849b546f9cc34833bc196ae45f8a1919f22e2d2a24132876cd80b31d90b6f435430a30542123d7beb306497efdab869850f9834f593b2e4b58b071c52b2d409aa958ed416423cde324ac0c9a2265353d4b63f001a451f03f2a884181526cf7ca976a80554eb166cf5e124ac9821a9c0c2ee6ba37b0c0a964e74e2540ab56300ea592c39b931b04f2071ef88b441b23b625d79361eed43edc5b96d3841275116d67c05784eb5504cdc368e06b65b06d0c247a98aeb988a345e34125b9674f3140b81f6af95bbdc9e44629f18d10915826bacd396dbad3ed9b3c441b4</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
        <category>Good Habits</category>
        <category>Bath</category>
      </categories>
  </entry>
  <entry>
    <title>Breakfast</title>
    <url>/2020/02/24/Breakfast/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Third warning: This content is personal, please skip it." data-whm="Fourth warning: This content is personal, please skip it."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Warning again: This content is personal, please skip it." /><label>Warning again: This content is personal, please skip it.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="56c8f437b6577d87cb73cce2f315e9211460cf963d75668d407ef0e5bba94404">be7ac66aa8a0988149df2046ebdd79bb392d060d4f87a5e3a0f992fd6405f50a20a1be812fd5a23877b7897b8b6e596b4d4194f779d33b13a2e1e4325ef3df57acece7656a4bd3beb6aa01ddf6dd40c7b12650af20dcb0dee75fbb0ae08074fab25d5bdc0cc0ca0c43f2cd7d5f81604043765f2e788c0bddce54f8e4898fea9d879cf5b9de827305bc7b0b7b45c37bed99e3debeb6d1ef01f03c0a3aad96741f7a799ef62475297c7919cf38b512abc708d085787958e258dc25ec84ec26d07a7af2f55d20463d47b1cfa10aa100bbd7a4f1163c719945e7dde476847259a6c5055960dbfddff983637b60495c2a8fa6903cf194a58007553e43637695fdd3dfab0e545db326edb6f6635e87e22d74e9e70d1a678c03886a9fb3b3e9f45bd6b7acd65e5c897eb3959a4f7a8f876b082227d52634712efc868b9646242aef0cf0aab95e441094d1093e15dadf46753a7c547226aa87930d25f3ca7bc3a8efa2511cb08d268a3106efe62990502d887b0a400cf79930615171838d74592e561b9c190690d9dad655a78d082b7ffcec1c2d84818241b0afb5c202481f0e58676c1dc03380fbb785e7394a71f8a1ff23d0b13009aeff7436f02d0df2d18733e206a8921d3898b8e374852430f810e3f2edb5f002d177c56fd02ded58f34a862ce94833d8c3d8545ddf0c0d3096df717f136151ff0f0dc14a11885fbe5db347b92af176dfdf470effe76aee5c2621ddfd4d247da6389bca80a73d3a8fceb088dabe41c01bc7a7543a45296d903aaf2fa7278a865850dadd26de9bb3498828fa58ad2c3ab55d03f71279827cf4f3bc38812a61adcf11ed0d35f9464cb0fc47dadc877161467341ab7ff051cc8016ba37962e317c804da865a9ff13762883cfd2dcaf3452d16378823ae79269e20818c876e0b923f6e41e545a62af753748c51f54ec99a73fedafc4c1397468a59e0b1143f7326b4b59eefcc4d80b7501c3dc0148d8ea75f1fdf436eda7acd0003b7af268c85eaacdd11ad59096e7c877c2907a5e1b89475afa7042dc00ba9009cce00183c927c28c7035600de7aa18e8c9a861738bb48174762401104dd66cccdc32a28eaba7fe3bd8a63d03195ae3063acdd7a92e18b6ed517911565038b0618df956b44c15e08fb31bab634ba647b8a4406a8c7901a9a94a6ee4db883cfc765d381176878bce687ce9f81ce72d86eeb5e29190fba921828695e6b73c67bf494b6161b9b9a502a21445d26f5776eb13b0e1c13044f8ab0417ce287a0b52c6b3715209890583c086f6a92f6bfc4549712bebd1e0329b8b2b458d4e7e0fd6d6536e5916e63f5cd2d4a45d512ed29f4d90ef3632ad6786f4859b6476e645a063caa34446846ba230c27314980ff68ed3ae0a9e45efb668394b1fa7d11691a5953698c83df1c0cd0d3d29d5fa49143ed28a339779958f05fdef4a6bfbc17243bbff2534f3dec502187985c5f7a8b64bc445cc475d1a17854c752a2a5884988686ca4ed59d89b93233c5ad0adaecec5c0ae39bb5921504961903079cc5a1fe19e019cb5f3b11d75f36486647f90bb3ab750dab4f2a8485bb7d833f5fdfd1b59f166895447c3b6b170e9604a5b5c32a8fa7758ef5df822e8ed7bb2e17e08b61e5771d99ad36779cdb9e5285544c48bc1407e58f55673a10cd1f59d72e8ba0526086741135fdeaa232103f96e4b92b10fae072be749a5064a01d84e41093377bde5824bf96f420eb31baa940b0580c12b390660356ea55ee840b8f592f6a6e0b770bf5798df2faa3a1c13ce0d3605ebc7273d47211a6e8f54b8ce97dca642f52b72dd30385174068e19238691a63f81f03fac9907b65140cff954c90493cb7fc75cc45c8f8ec9c8519db4a53ace897972426c89e189c8805c592ca5778e61bc3f1152054217a42be58b5b096891d101d72d1f25baa08be46f0998f744047bbced05b8f63ab705685e1bfc35339d101925ac8e82de7a82d15048fa03c36393eed3f19e575b9ca663dc69de6ce3bd778e935824d67d1db8641cf3c6f3efb17f304c6fc51cf4aec5b0053426dc3f7b4aeff4ab319b3176add2e8d178b56a20f0ec55ce74dd4d5c1ce8fad977ebcab1748e9249342a26c077eee230a467f8ded0b6f454c93bb1ede217824232268f80ab2190a3e8ead7b4ad2d494766e2dc22a9a6d5d978a848c8940bbfb947a92d6d93d135b4661b5357dba0ba8cddb03112b01ed2c497eaa28f6808a121dd8fa89f75d9b27821242e19658b6c000b4c894d1bdcd748bcba7279620781c5d5858c25c3a58f66b53c36604ea3911e4f940967db5f776056aa0e0128743df851871816e711ae0f433f28340f8d7d613ea18ec45d342390cfa901c99f1771270edff9867c0b9a216244361662709d59a41d2bc181dd1b57f88b20eb74499054683f9b2ca7282c49f77e07a1cc58abdec7f381c6f4248185b226b7403ac2232c2105989a860b38f24cf8416189942bfa834ad5f6b759b7f79e452cc188e4eae23b59c31050b375a0556cff411f302c0c76fdaced8add860789f1a1ef39605181321e2c4c626ea348cb1237a77cdf6286f91fb2c6a49a60a7edcea142140b86fe0f1d1adfe73e415950fce75d35c28697ca63737e4839405c198575a1257ae12a7dcfbf73ee1a9e74dee4de4344c336d6dcdd5a623a7ec6ec75eff6ea2273ebee7f94822dc8afa837ca01365fb32b69bfa952397c86feb91ebcd62b3257ad9fe06d11b7f84f6fc222d159b4150f671451312462ea2bf478b5c2c4043844d14392af5d1f4b98cc7adf4579d87638072295307a78eeaa97acd3bdb6357c2abc38204fe93b66fc7453a68acdecb39589a93957ee4134caac22458fd329ccfff885319dd16d30d22110f70d9ad70360397fccafa5764db8a2db9dac891b59b0fcfe42a86d45b6e84baabac10079adf5469c6f7884235cf239045491e66af276a89185ed9eddd254a517b2d582b0563c947e65659ca65871cf06c6aa327a683121d7af012d3c4ef6be81620b866554816baa858ee1cf3f054a0798a2ee3bc485e36e347767f9bec3f5abcd6117f32371ef5436b5ec341457396dad7f5dbb2e6a58b086440e4f5650932d9943b9c299582ef7f3354f36c59fae1cc11bb00dbece37ccf6d132185e3653dd2aa0a3b3f5e9bdff604e0ea25c2ee211a469af64d8ae6182bc836156533b5dce039e64ad6c2a61c29d9af034b959e20ee5625ebb6f14db166516f3b0f6125961f40db8f9326b6ebeb010f98354b0ba8aabc67b97296f20499543ad96d6474ef002f17947958e791cf71921fd7daf058396876309757be2938df994d67bb5db733d322067a65fe571f49d4b6834892938d8e134f331d73fe9e3dfa4c8fb582817a0b10dd0046dfb8387c977fa1e1b6a50f367792d47111c1515cfbd842f93a03433efdb90e613e4db89dbd35f34839d945dae2330d78b11d82980f4c43c25e186782029806fadde0b8cd7e694011fe71cf46d3e027e4b2386eacac2dc1b6224ff508a1c090d77012d0d97ca06c09f41a2feabca7279befcb127da9e95dfa0da401a288151bbeb26205f65b3cdfde525b1b220d0be6f8c4d1770f6f1b53cd32fdfcd8be990db4cabecf89b7313ebae47a04cfa1a630974f6ab925963de0e9a69b73da4512e22f91ab926dec79537715be07b8ed26b941002a313b9dff1a3d7d05f7023fb7474eb2aea8225bc0c9d08d8fbea9ac5354fd7d676d11faee6a6e4140f8e48c30ed1a7c5d474725b72449a1a5f573c6a456b69677b532b40085c22479dae7d38a03b686eecfa6992d572aa2a6d0aba48b18e3a993a8d112354ba57ba15f5962eda34070e8fae259f06c2f0e53c16e5c351a159b2320259b8d7c2a9f9bd5600908e2a6e40fc13dad35765f7182361ee44f16b7a09e896a7a074ba45cc635bf5f3d7da9ea81baceae47d796da966bd4598b74a8a5c6d02c3a6a904a825f82e5b7a180745059f98b2a06d95bc15f109286c9b2320410a9d22de80606b9edeb2ae3eb314a616d703f0bbc628e4d3f2cf572477a93ce02f30c32efae29246f41b148607c69b89ac8ef1d7a9010ac2057fcaa2673d9cef7f59bfc01de209da03c9817139fa398396bee861fc21c6a474d77da012c31e0488c90b2650cb66507654080d7b208ab744cc09a8c32f2354bcb9dcad34f18506e7195652fddba1752596ecbba735af5d4085048ff3eb8cd0e7501e18ff19d9cc0c9eaaa9c1c41008ee4ccbebb87576fdba48f6adaf2a4f7dd583b5d39c18baffa969d09758b2f4275998d59d9fcc6ebab080e8819fb2442b63423bbf63b0d4f7d5aa3c56ab85d94d88ed758246c68062d7b91bed06dc6a6f55eb33dd4fdd9f07d0e2751ae0cc17e153d07bf4458c659fb933ff08c864d1dd0cad088d2d81a80cdf6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
        <category>Good Habits</category>
        <category>Breakfast</category>
      </categories>
  </entry>
  <entry>
    <title>Calibre</title>
    <url>/2020/02/26/Calibre/</url>
    <content><![CDATA[<img data-src="https://calibre-ebook.com/resources/img/home-feature.jpg" width="100%"/>

<a id="more"></a>

<blockquote>
<p>calibre是一个自由开源的电子书软件套装，可以用来组织、存放、以及管理电子书，支持大多数的电子书格式。同时也支持与许多流行的电子书阅读器进行同步，并可能在DRM的限制下转换电子书的格式。——<a href="https://zh.wikipedia.org/zh/Calibre" target="_blank" rel="noopener">calibre - 维基百科，自由的百科全书</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Softwares</category>
        <category>eBook</category>
      </categories>
      <tags>
        <tag>eBook</tag>
      </tags>
  </entry>
  <entry>
    <title>Comments</title>
    <url>/2019/01/03/Comments/</url>
    <content><![CDATA[<img data-src="https://www.sandovalcountynm.gov/wp-content/uploads/2018/07/Public-Comment-1031x644.jpg" width="100%"/>

<a id="more"></a>

]]></content>
  </entry>
  <entry>
    <title>Career Planning</title>
    <url>/2020/03/16/Career-Planning/</url>
    <content><![CDATA[<img data-src="https://leverageedu.com/blog/wp-content/uploads/2019/09/Career-Planning-and-Development.png" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://www.zhihu.com/question/19911890" target="_blank" rel="noopener">怎样进行职业规划？ - 知乎</a></p>
</blockquote>
<h2 id="认识自己"><a href="#认识自己" class="headerlink" title="认识自己"></a>认识自己</h2><h3 id="职业测评"><a href="#职业测评" class="headerlink" title="职业测评"></a>职业测评</h3><p>MBTI、九型、霍兰德都可以，这些</p>
<h2 id="认识行业"><a href="#认识行业" class="headerlink" title="认识行业"></a>认识行业</h2><h2 id="认知职业类型"><a href="#认知职业类型" class="headerlink" title="认知职业类型"></a>认知职业类型</h2><h2 id="选择行业和职业"><a href="#选择行业和职业" class="headerlink" title="选择行业和职业"></a>选择行业和职业</h2><h2 id="确定并拆分职业目标"><a href="#确定并拆分职业目标" class="headerlink" title="确定并拆分职业目标"></a>确定并拆分职业目标</h2><h2 id="梳理计划并执行"><a href="#梳理计划并执行" class="headerlink" title="梳理计划并执行"></a>梳理计划并执行</h2><blockquote>
<p><a href="https://www.bpteach.com/2019-08-05-career-planting/" target="_blank" rel="noopener">普通人如何做好职业规划？职业规划的5大步骤（职场必备） - 半 …</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Chronicle of a Blood Merchant</title>
    <url>/2019/02/24/Chronicle-of-a-Blood-Merchant/</url>
    <content><![CDATA[<img data-src="http://www.bandubb.com/wp-content/uploads/2018/05/qqsrx-1525493481-2.jpeg" width="100%"/>

<a id="more"></a>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>越来越喜欢余华的书了，一种很朴实的感觉。还是小说看起来轻松些，其他类型的书看起来会很累。故事总是能打动我。可能受《活着》的影响，读这本的小说的时候，在很多节点以为又要发生生离死别的悲剧，很紧张，不希望有太多生离死别，尽管总要面对，但能晚就尽量晚一些吧，就当我在逃避吧。</p>
<p>书中的情节有时候感觉很快，转眼间许三观就结婚了、生了三个儿子了、闹饥荒了、文革了…… 章节很多，但有些章节篇幅却很少。</p>
<p>小说里的人物都很善良淳朴，许三观的四叔、第一次带许三观卖血的阿方和跟龙、身在异乡时送他热茶和盐的河边老百姓、搭顺路船时的两兄弟…… 整体氛围还算是温情的。</p>
<p>越是接近生活的故事越是能打动现在的我，就像离校园时光越远越深觉自己的平庸一样。果然艺术来源于生活啊！</p>
<p>看了余华的这两三本后就把他剩余的作品也买了几本，不要放过一个这么喜欢的作家啊！</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>生活和时间总是转瞬即逝，而文学却是历久弥新。</li>
<li>马提亚儿说：”回忆过去的生活，无异于再活一次。” 写作和阅读其实都是在敲响回忆之门，或者说都是为了再活一次。</li>
<li>脸上的肌肉像是伸懒腰似的展开。</li>
<li>你们听着，这道菜是专给三乐做的，只准三乐一个人吞口水，你们要是吞上口水，就是说你们在抢三乐的红烧肉吃。你们的菜在后面，先让三乐吃得心里踏实了，我再给你们做。</li>
<li>有谁敢再说一乐不是我亲生儿子，我就和谁动刀子。</li>
<li>我刚才哭是以为一乐死了，现在哭是看到一乐还活着……</li>
<li>海涅说：”死亡是凉爽的夜晚。“海涅也赞美了死亡，因为”生活是痛苦的白天“，除此之外，海涅也知道死亡是唯一的平等。</li>
<li>精通了日积月累的意义。</li>
<li>我对那些故事没有统治权，即使是我自己写下的故事，一旦写完，它就不再属于我，我只是被他们选中来完成这样的工作。</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Cry in the drizzle</title>
    <url>/2019/03/07/Cry-in-the-drizzle/</url>
    <content><![CDATA[<img data-src="http://103.6.6.66/upload/mall/productImages/18/12/9787530217962.jpg" width="100%"/>

<a id="more"></a>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>不知道在所有的小说里都是这样，余华的小说里总会有一些我很讨厌的人物，讨厌到甚至不相信这类人的存在。像《细雨》中的孙广才这种，怎么能自私到这种地步，不可相信，还有他的一些行为举止，摸未过门的儿媳屁股这种简直是不可理喻。孙广才之后被孙广平割了一只耳朵，最后是酒醉后死在了村口的粪坑里。还有像主人公的祖母在一个夜里在树下睡着后被一条野狗吃了，令人毛骨悚然的情节。</p>
<p>我发现余华的小说里总是喜欢家内有三个男丁，许三观有三个儿子，孙广才也有三个儿子，只是描述的视角不同，《买血计》是从许三观的视角书写的，而《细雨》是从二儿子孙光林的视角出发的。</p>
<p>网评中这一段蛮喜欢的。</p>
<blockquote>
<p>“1965年的时候，一个孩子开始了对黑夜不可名状的恐惧。”——余华轻而易举地将我带入他的叙述语境。面对“1965年”，书中的“我”具备了回忆的可能性和必须性。以“孩子”孩子的目光张望以往的生活——似乎表明了作家的叙述内蓄天马行空的幻想的张力。对黑夜的不可名状感，则预示着这部长篇弥漫着无边无际的神秘和压抑的黑暗。加缪曾言“一本书的结局已经寓于它的开头部分”，他指的是那些心思巧织的作品。   ——<a href="https://www.douban.com/people/zhaolei/" target="_blank" rel="noopener">石头</a></p>
</blockquote>
<p>书中关于鲁鲁之后的故事再没过多的叙述，蛮喜欢鲁鲁这个角色的，小小年纪有着超乎那个年纪的聪明和性格，又有着这个年纪该有的简单与纯真。双手环抱“敌人”，任他捶打撕咬，忍痛坚持不松手，但可以为解除他的小书包的危险而放弃反抗，很真实，小孩真的是很在乎他内心在乎的人，事和物的。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>一九六五年的时候，一个孩子开始了对黑夜不可名状的恐惧。</li>
<li>屋檐滴水所显示的，是寂静的存在，我的逐渐入睡，是对雨中水滴的逐渐遗忘。</li>
<li>再也没有比孤独的无依无靠的呼喊声更让人战栗了，在雨中空旷的黑夜里。</li>
<li>阳光那时候似乎更像是温和的颜色涂抹在我们身上，而不是耀眼的光芒。</li>
<li>回想中的往事已被抽去了当初的情绪，只剩下了外壳。</li>
<li>我们并不是生活在土地上，事实上我们生活在时间里。田野、街道、河流、房屋是我们置身时间之中的伙伴。时间将我们推移向前或者向后，并且改变着我们的模样。</li>
<li>我的弟弟不小心走出了时间。他一旦脱离时间便固定下来，我们则在时间的推移下继续前行。孙光明将会看着时间带走了他周围的人和周围的景色。我看到了这样的真实场景：生者将死者埋葬以后，死者便永远躺在那里，而生者继续走动。这真实的场景是时间给予依然浪迹在现实里的人的暗示。</li>
<li>音乐是从语言消失的地方开始的。</li>
<li>有时我也会因为寂寞而难以忍受空虚的折磨，但我宁愿以这样的方式来维护自己的自尊，也不愿以耻辱为代价去换取那种表面的朋友。</li>
<li>恐惧和颤抖是人的至善。</li>
<li>我越来越清楚自己干些什么时，对自己的指责在生理的诱惑面前开始显得力不从心。</li>
<li>总之当我们凶狠地对待这个世界时，这个世界突然变得温文尔雅了。</li>
<li>我知道想象和希望对于他的重要和必须，事实上对于我也同样如此。</li>
<li>生命在面对消亡时，展现了对往昔的无限依恋。</li>
<li>我突然发现了逃跑的意义，它使惩罚变得遥远，同时又延伸了快乐。</li>
<li>她站在生与死的界线上，同时被两者抛弃。</li>
<li>过早的自由使他像扛着沉重的行李一样，扛着自己的命运，在纷繁的街道上趔趔趄趄不知去向。</li>
<li>当慢慢的人生长途走向尾声的时候，财富荣耀也成为身外之物，记忆却显得极为珍贵。</li>
</ul>
]]></content>
      <categories>
        <category>Rading</category>
      </categories>
      <tags>
        <tag>Rading</tag>
      </tags>
  </entry>
  <entry>
    <title>Ein Hund namens Money</title>
    <url>/2020/03/04/Ein-Hund-namens-Money/</url>
    <content><![CDATA[<img data-src="https://i.ytimg.com/vi/iCqgPEnWvyw/maxresdefault.jpg" width="100%"/>

<a id="more"></a>

<style lang="css">
    .annotation-label-wapper {
        display: flex;
        justify-content: space-between;
        padding: 0 15px;
        border-top: 1px solid #eee;
    }
    .annotation-label-pos {
        margin: 6px 0;
        font-size: 0.6em;
        padding: 0 4px;
        border-radius: 5px;
        background-color: #ccc;
    }
</style>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><blockquote>
<p>博多·舍费尔 1960年9月10日出生在德国科隆，16岁时移民美国。代表作《小狗钱钱 》。——<a href="https://baike.baidu.com/item/博多·舍费尔/9869587" target="_blank" rel="noopener">博多·舍费尔_百度百科</a></p>
</blockquote>
<ul>
<li><p>中文名：博多·舍费尔</p>
</li>
<li><p>外文名：Bodo Schaefer</p>
<p>Bodo Schaefer</p>
</li>
<li><p>国  籍：美国</p>
</li>
<li><p>出生地：德国</p>
</li>
<li><p>出生日期：1960年</p>
</li>
<li><p>重要事件：创立了“我们未来的孩子”基金</p>
</li>
<li><p>代表作品：《小狗钱钱》《小狗钱钱2》</p>
</li>
<li><p>影  响：欧洲第一金钱教练</p>
</li>
</ul>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="小狗钱钱1"><a href="#小狗钱钱1" class="headerlink" title="小狗钱钱1"></a>小狗钱钱1</h3><h4 id="第七章-在金先生家"><a href="#第七章-在金先生家" class="headerlink" title="第七章　在金先生家"></a>第七章　在金先生家</h4><div class="annotation-label-wapper">
    <div>2020年02月27日 06:09</div>
    <div title="epubcfi(/6/30[id145]!/4/86/1,:48,:100)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>他向我解释道：“吉娅，<span style="color: #FECF0B">大多数人都是这么想的，我曾经也这么想。可是请你告诉我，你为什么不能因为做了一件自己喜欢的事情而挣到钱呢？</span>”</p>
          </div>

<p>吉雅因为金先生要给她“钱钱”的照顾飞而生气，说“我愿意照顾钱钱是因为我一见到它就喜欢上了它，而不是为了挣什么钱。”，但金先生却告诉她这是她应得的。</p>
<p>对于我们喜欢的事物，我们总是情愿不计回报的付出，甚至会觉得与金钱相提并论会显得庸俗不堪，但其实金钱的本质本来就是用来衡量价值大小的。</p>
<p>比如，生活中有些时候我帮了别人一个小忙，别人为了感谢给我发个红包什么的，我会很不好意思收这个红包，认为别人是不想欠这个人情。但其实换个思路，这个时候是可以大大方方的收下这个红包的。一方面这是你付出的合理回报，另一方面如果别人不想欠你人情，你也没有必要留着这份人情，你情我愿下的人情才弥足珍贵。</p>
<p>再者，我们生活工作的目标不都是希望从事自己喜欢的行业，也希望能有较好的物质生活，两者结合起来不是更好吗，如果从这个角度想，是不是小时候因为不情愿把自己喜欢的事情和金钱相提并论这种思维方式，导致了我们一开始就没有将喜好作为以后从事的工作的参考标准，而工作之后又总是抱怨当前的工作并不是自己真心喜欢的行业呢？</p>
<div class="annotation-label-wapper">
    <div>2020年02月27日 06:12</div>
    <div title="epubcfi(/6/30[id145]!/4/114/1,:16,:23)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>“我讲这个故事就是为了告诉你，‘<span style="color: #FECF0B">不要杀死你的鹅</span>’。”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年02月27日 06:15</div>
    <div title="epubcfi(/6/30[id145]!/4/124/1,:30,:60)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>金先生慢悠悠地说，“<span style="color: #FECF0B">鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。</span>”</p>
          </div>

<p>故事讲的是一只能下金蛋的鹅，农夫最后杀了鹅，从此再也得不到金蛋了。</p>
<p>鹅对应的是本金，金蛋对应的是利息。不要杀死你的鹅，就是说不要动你的本金。作者在书中倡导应该将自己收入的一部分作为理财的本金，并且一般情况下都不要动用自己的本金，以保证它能够产生持续的收益。</p>
<div class="annotation-label-wapper">
    <div>2020年02月27日 06:21</div>
    <div title="epubcfi(/6/30[id145]!/4/168/1,:7,:59)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>金先生答道：“<span style="color: #FECF0B">越是把注意力放在疼痛上，我就越会觉得疼。谈论疼痛就像给植物施肥一样。所以我很多年以前就改掉了抱怨的习惯。</span>”</p>
          </div>

<p>这里为了说不应该抱怨时，举的病痛的例子，较真的话举例不是很恰当。因为我觉得谈论疼痛和抱怨还是有区别的。</p>
<p>所以就分开理解吧，病痛时尽量分散自己的注意力；而遇到不公的事时尽量控制自己的情绪，可以抱怨，但不要只停留在抱怨，而应该多思考哪些实际行动能改善这种情况，努力寻找解决问题的办法更重要。</p>
<h4 id="第八章-陶穆太太"><a href="#第八章-陶穆太太" class="headerlink" title="第八章　陶穆太太"></a>第八章　陶穆太太</h4><div class="annotation-label-wapper">
    <div>2020年02月27日 06:44</div>
    <div title="epubcfi(/6/34[id143]!/4/104/1,:72,:76)" class="annotation-label-pos">POS</div>
</div>
<div class="note no-icon">
            <p>威利在场一点儿也不能增加我们的安全感，它是最胆小的一只，只会<span style="color: #33D42D">亦步亦趋</span>地跟着莫尼卡。</p>
          </div>

<blockquote>
<p>亦步亦趋，汉语成语，读音为yì bù yì qū，比喻由于缺乏主张，以别人为准；或为了讨好，事事模仿或追随别人。出自《<a href="https://baike.baidu.com/item/庄子/2451694" target="_blank" rel="noopener">庄子</a>·<a href="https://baike.baidu.com/item/田子方" target="_blank" rel="noopener">田子方</a>》。</p>
<p>《庄子·田子方》：“夫子步亦步，夫子趋亦趋，夫子驰亦驰，夫子奔逸绝尘，而回瞠若乎后矣。”</p>
<p>【近义词】邯郸学步、东施效颦、如法炮制<br>【反义词】独具匠心、独树一帜、别具一格</p>
</blockquote>
<h4 id="第十章-在地下室里"><a href="#第十章-在地下室里" class="headerlink" title="第十章　在地下室里"></a>第十章　在地下室里</h4><div class="annotation-label-wapper">
    <div>2020年02月27日 06:52</div>
    <div title="epubcfi(/6/36[id142]!/4/30/1,:39,:60)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #3CA3FF">诺克斯堡的军事基地是美国储藏黄金的地下金库</span>，这一点我早就知道了。</p>
          </div>

<blockquote>
<p><strong>诺克斯堡</strong>（<strong>Fort Knox</strong>）是<a href="https://zh.wikipedia.org/wiki/美国陆军" target="_blank" rel="noopener">美国陆军</a>的一处基地，位于<a href="https://zh.wikipedia.org/wiki/肯塔基州" target="_blank" rel="noopener">肯塔基州</a><a href="https://zh.wikipedia.org/wiki/布利特縣_(肯塔基州)" target="_blank" rel="noopener">布利特县</a>、<a href="https://zh.wikipedia.org/wiki/哈丁县_(肯塔基州)" target="_blank" rel="noopener">哈丁县</a>和<a href="https://zh.wikipedia.org/wiki/米德县_(肯塔基州)" target="_blank" rel="noopener">米德县</a>境内，面积约441<a href="https://zh.wikipedia.org/wiki/平方公里" target="_blank" rel="noopener">平方公里</a>。</p>
<p>美国陆军征兵司令部、美国陆军预备军官训练团、<a href="https://zh.wikipedia.org/w/index.php?title=乔治·巴顿将军纪念馆&action=edit&redlink=1" target="_blank" rel="noopener">乔治·巴顿将军纪念馆</a>和储放美国<a href="https://zh.wikipedia.org/wiki/国库" target="_blank" rel="noopener">国库</a>黄金的<a href="https://zh.wikipedia.org/w/index.php?title=美国金库&action=edit&redlink=1" target="_blank" rel="noopener">美国金库</a>等机构均位于该地。亦曾为美国陆军装甲中心、美国陆军装甲学校所在地。</p>
<p><a href="http://www.360doc.com/content/13/0703/08/12446589_297273844.shtml" target="_blank" rel="noopener">世界上最大的黄金储备库——诺克斯堡 - 360doc个人图书馆</a></p>
</blockquote>
<h4 id="第十一章-爸爸妈妈不明白"><a href="#第十一章-爸爸妈妈不明白" class="headerlink" title="第十一章　爸爸妈妈不明白"></a>第十一章　爸爸妈妈不明白</h4><div class="annotation-label-wapper">
    <div>2020年02月27日 07:04</div>
    <div title="epubcfi(/6/38[id141]!/4/10/1,:29,:49)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>我们聪明的历史老师常说一句话，看来他说的是正确的，他说：“<span style="color: #FECF0B">幸运其实只是充分准备加上努力工作的结果。</span>”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年02月28日 06:17</div>
    <div title="epubcfi(/6/38[id141]!/4/112/1,:60,:78)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>是怎么说的来着……噢，对了，他说‘<span style="color: #FECF0B">笨人只有一次好运，聪明人永远都有好运</span>’。</p>
          </div>

<p>吉雅的同学羡慕她那么幸运，遇上了那么惊险刺激的事情(抓小偷)。</p>
<p>因为吉雅准备了梦想储蓄罐，所以她努力工作挣钱，因为她工作的很努力，所以汉内坎普先生把她推荐给陶穆太太（小偷在偷陶穆太太的金库），所以她很幸运的遇到了抓小偷这件惊险的事情。</p>
<p><strong>因为</strong>准备的很充分，工作的很努力，<strong>所以</strong>很幸运！只管充分的准备，努力的工作，结果自然就是幸运的。</p>
<div class="annotation-label-wapper">
    <div>2020年02月27日 07:07</div>
    <div title="epubcfi(/6/38[id141]!/4/30/1,:88,:118)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>因为汉内坎普先生跟我说过，<span style="color: #FECF0B">勇敢的人也会害怕，一个人虽然害怕却仍然敢于前进，这才叫勇敢。</span></p>
          </div>

<p>吉雅在她的“成功日记”里写下她觉得她很勇敢，因为她在面对小偷的时候，虽然害怕，但是她勇敢保卫了陶穆太太的财务(她在黑暗中怒吼“把你的脏手拿开！这是属于一个老太太的！”）</p>
<div class="annotation-label-wapper">
    <div>2020年02月28日 06:11</div>
    <div title="epubcfi(/6/38[id141]!/4/58/1,:19,:55)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>不过，马塞尔告诉了我一个重要的原则：“<span style="color: #FECF0B">你干的活最多只值报酬的一半，另一半报酬源于你的想法和实施这个想法的勇气。</span>”</p>
          </div>

<p>吉雅让莫尼卡去遛狗，然后分给她一半的钱。因为莫尼卡没有想过帮别人遛狗来挣钱，也不敢向陌生人搭话问有没有活干，但吉雅却想到了这样的主意，并勇敢地付出实践。</p>
<p>想法和付诸实践的勇气同样具有价值，同样应该获得报酬！</p>
<div class="annotation-label-wapper">
    <div>2020年02月28日 06:18</div>
    <div title="epubcfi(/6/38[id141]!/4/120/1,:1,:23)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>“<span style="color: #FECF0B">一个人挣钱的多少是和他的自信心联系在一起的。</span>“另外，他的精力究竟是集中在自己的能力范围之内，还是放到了他力所不能及的事情上，这也是很重要的一点。<span style="color: #FECF0B">没有我的成功日记本，我就不会去思考自己适合在哪些方面赚钱。</span>”</p>
          </div>

<p>越自信，挣得钱越多！</p>
<p>精力要集中在自己的能力范围之内！</p>
<p>只有知道哪些事情已经成功过了，才能知道哪些事情可以成功！</p>
<h4 id="第十二章-陶穆太太归来"><a href="#第十二章-陶穆太太归来" class="headerlink" title="第十二章　陶穆太太归来"></a>第十二章　陶穆太太归来</h4><div class="annotation-label-wapper">
    <div>2020年02月28日 06:26</div>
    <div title="epubcfi(/6/40[id140]!/4/56/1,:19,:172)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>要想过更幸福、更满意的生活，人就得改变自身。这和钱无关，金钱本身既不会使人幸福，也不会带来不幸。<span style="color: #FECF0B">金钱是中性的，既不好，也不坏</span>。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年02月28日 06:35</div>
    <div title="epubcfi(/6/40[id140]!/4/116/1,:118,:199)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>虽说<span style="color: #FECF0B">钱也许不是生活中最要紧的东西，可是在缺钱花的时候它又非常重要</span>。没钱，生活的各个方面都会受到影响，你会整天愁眉苦脸，跟周围的人吵架，还会觉得自己很悲惨，很没用。</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年02月28日 06:39</div>
    <div title="epubcfi(/6/40[id140]!/4/150/1,:16,:44)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>他用一种恳切的目光望着我，说：“<span style="color: #FECF0B">我生命中出现了最美好的东西，是因为我做了原本不敢做的事。</span>”</p>
          </div>

<h4 id="第十三章-巨大的危机"><a href="#第十三章-巨大的危机" class="headerlink" title="第十三章　巨大的危机"></a>第十三章　巨大的危机</h4><div class="annotation-label-wapper">
    <div>2020年02月28日 06:48</div>
    <div title="epubcfi(/6/42[id139]!/4/70/1,:36,:62)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>“可是还有一点，你不能在困难面前逃跑。<span style="color: #FECF0B">困难、犯错误和丢面子引起的恐惧已经破坏了无数人的生活</span>。”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年02月28日 06:49</div>
    <div title="epubcfi(/6/42[id139]!/4/82/1,:1,:24)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>“<span style="color: #FECF0B">每当你觉得有些事情不好办的时候，你可以做一件事</span>，”等我歇了口气后，钱钱说，“<span style="color: #FECF0B">只要翻一翻成功日记，你就会从过去的事情中找到证据，相信自己未来也有能力完成任何事情。</span>”</p>
          </div>

<p>有所学校邀请吉雅做场演讲，吉雅海怕她做不到，钱钱建议她翻一翻成功日记来鼓舞自己。</p>
<p>工作和生活中经常会遇到一些机遇和挑战，此时我们经常会心存顾忌，担心自己没有足够的能力应对。在这种时候我们应该尽量放平心态，仔细分析面对这个机遇和挑战究竟需要哪些能力，而这些能力是否在我以前的人生经历中处理其他问题时用到过，如果用到过，说明我们是可以成功应对的。</p>
<p>在分析现在和回顾过往的过程中找回信心和勇气。</p>
<h4 id="第十四章-投资俱乐部"><a href="#第十四章-投资俱乐部" class="headerlink" title="第十四章　投资俱乐部"></a>第十四章　投资俱乐部</h4><div class="annotation-label-wapper">
    <div>2020年02月29日 07:25</div>
    <div title="epubcfi(/6/44[id138]!/4/142/1,:1,:30)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>“<span style="color: #FECF0B">决定一件东西价值多少的唯一因素就是，你愿意为它支付多少钱。</span>”</p>
          </div>

<p>这里的价值应该是对我们来说的价值。在日常购物时，尽量客观的找一找资料、数据，分析价格和价值是否对等，不要盲目、冲动的消费。</p>
<h4 id="第十五章-演-讲"><a href="#第十五章-演-讲" class="headerlink" title="第十五章　演　讲"></a>第十五章　演　讲</h4><div class="annotation-label-wapper">
    <div>2020年02月29日 07:44</div>
    <div title="epubcfi(/6/46[id137]!/4/66/1,:54,:84)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。<span style="color: #FECF0B">一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。</span></p>
          </div>

<h4 id="第十七章-爷爷奶奶害怕风险"><a href="#第十七章-爷爷奶奶害怕风险" class="headerlink" title="第十七章　爷爷奶奶害怕风险"></a>第十七章　爷爷奶奶害怕风险</h4><div class="annotation-label-wapper">
    <div>2020年02月29日 08:20</div>
    <div title="epubcfi(/6/50[id135]!/4/160/1,:66,:95)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">我意识到，在一个我一看就喜欢上的人那里开户，是多么重要啊。</span></p>
          </div>

<h4 id="第十八章-大冒险的结局"><a href="#第十八章-大冒险的结局" class="headerlink" title="第十八章　大冒险的结局"></a>第十八章　大冒险的结局</h4><div class="annotation-label-wapper">
    <div>2020年03月01日 06:14</div>
    <div title="epubcfi(/6/52[id134]!/4/8/1,:126,:183)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>以前他曾经怀疑自己究竟适不适合独立创业，但现在他知道，只<span style="color: #FECF0B">要学会把某些自己不喜欢做而又不擅长做的事情交给别人</span>就行了。</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 06:23</div>
    <div title="epubcfi(/6/52[id134]!/4/62/1,:19,:45)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>这时，我想起了金先生对我说过的一句话：<span style="color: #FECF0B">不要为失去的东西而忧伤，而要对拥有它的时光心存感激。</span></p>
          </div>

<h4 id="自力更生——写给成年人的后记"><a href="#自力更生——写给成年人的后记" class="headerlink" title="自力更生——写给成年人的后记"></a>自力更生——写给成年人的后记</h4><div class="annotation-label-wapper">
    <div>2020年03月01日 06:26</div>
    <div title="epubcfi(/6/54[id133]!/4/6/2/2/1,:2,:4)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>打破<span style="color: #33D42D">桎梏</span>，开阔视野</p>
          </div>

<p>桎梏 [zhìgù]：脚镣和手铐；比喻束缚人或阻碍事物发展的东西。</p>
<div class="annotation-label-wapper">
    <div>2020年03月01日 06:27</div>
    <div title="epubcfi(/6/54[id133]!/4/10/1,:19,:43)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>《大与小》杂志的一篇评论文章认为，自从<span style="color: #3CA3FF">德国人弗里德里希·福禄贝尔创办世界上第一家幼儿园</span>以来，200年间，他的追随者们把儿童从做童工受剥削的恐惧中解放出来之后，又把他们束缚在培养乖孩子的游戏之中。</p>
          </div>

<blockquote>
<p>弗里德里希·威廉·奥古斯特·福禄贝尔（德语：Friedrich Wilhelm August Fröbel，1782年4月21日－1852年6月2日），德国教育家，被公认为是19世纪欧洲最重要的几个教育家之一，现代<strong>学前教育的鼻祖</strong>。他不仅创办了第一所称为“幼稚园”的学前教育机构，他的教育思想迄今仍在主导着学前教育理论的基本方向。当时来说，能让孩子上其教育课程者均为有钱有权之父母。——<a href="https://zh.wikipedia.org/zh-hans/弗里德里希·福禄贝尔" target="_blank" rel="noopener">弗里德里希·福禄贝尔- 维基百科，自由的百科全书 - 維基百科</a></p>
</blockquote>
<div class="annotation-label-wapper">
    <div>2020年03月01日 06:30</div>
    <div title="epubcfi(/6/54[id133]!/4/22/1,:27,:31)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>我们应该保护弱者，不能歧视少数群体，不要对不如自己的人<span style="color: #33D42D">颐指气使</span>，不要追逐凌驾于众人之上的权力。</p>
          </div>

<p>颐指气使 [yí zhǐ qì shǐ]：意思是指不说话，只用面部表情来示意。形容有权势者指挥别人的<a href="https://baike.baidu.com/item/傲慢/7238397" target="_blank" rel="noopener">傲慢</a>神气。出自唐·<a href="https://baike.baidu.com/item/元稹/207525" target="_blank" rel="noopener">元稹</a>《追封李逊母崔氏博陵郡太君》</p>
<p>【近义词】<a href="https://baike.baidu.com/item/盛气凌人/1662522" target="_blank" rel="noopener">盛气凌人</a>、趾高气扬、神气活现</p>
<p>【反义词】唯唯诺诺、低三下四、奴颜婢膝</p>
<div class="annotation-label-wapper">
    <div>2020年03月01日 06:32</div>
    <div title="epubcfi(/6/54[id133]!/4,/26/1:0,/27:0)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>我们推崇一种<span style="color: #FECF0B">聪明的、简朴的生活方式</span>。也就是说，<span style="color: #FECF0B">宁愿购买一件一流产品，也不要不停地买许多的二流产品</span>。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 06:36</div>
    <div title="epubcfi(/6/54[id133]!/4/28/1,:0,:72)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">生活质量不是由越来越多的高科技产品堆砌而成的</span>，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。</p>
          </div>

<h3 id="小狗钱钱2"><a href="#小狗钱钱2" class="headerlink" title="小狗钱钱2"></a>小狗钱钱2</h3><h4 id="童话与理财"><a href="#童话与理财" class="headerlink" title="童话与理财"></a>童话与理财</h4><blockquote class="blockquote-center"><p>坐在屋子里<br>看墙上的风景画<br>在画框里</p>
<p>坐在窗户旁<br>看外面的风景<br>在窗框里</p>
<p>走下楼去<br>想看一看原野<br>高楼和烟囱<br>横在风景上</p>
<p>想看一幅风景<br>没有画框的风景<br>我知道<br>我还要走很远很远</p>
</blockquote>

<div class="annotation-label-wapper">
    <div>2020年03月01日 06:48</div>
    <div title="epubcfi(/6/70[id125]!/4/22/2/1,:3,:5)" class="annotation-label-pos">POS</div>
</div>
<div class="note no-icon">
            <p>高楼和<span style="color: #33D42D">烟囱</span></p>
          </div>

<p>烟囱 [cōng]</p>
<div class="annotation-label-wapper">
    <div>2020年03月01日 06:51</div>
    <div title="epubcfi(/6/70[id125]!/4/34/1,:13,:66)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>当时的我有些伤感地表达了：<span style="color: #FECF0B">在这个绚丽、复杂、多变的都市，我们离简单和真实已经有很远很远的距离了，无论是在现实世界，还是在我们的心里。</span></p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 06:52</div>
    <div title="epubcfi(/6/70[id125]!/4,/44/1:9,/46/1:23)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>关键在于你的心态，<span style="color: #FECF0B">在你的心里究竟还有多少框框？——“名人”的框框、习惯的框框、观念的框框……</span></p><p>当然，对于框框我们不可能也不可以视而不见，但最重要的是<span style="color: #FECF0B">在看见框框的同时，你是否也看见了里面的风景。</span>这需要勇气和信心，而<span style="color: #FECF0B">真正的勇敢是在感到最恐惧的时候，你依然在往前走。</span></p>
          </div>

<h4 id="第二章-白色石头"><a href="#第二章-白色石头" class="headerlink" title="第二章　白色石头"></a>第二章　白色石头</h4><div class="annotation-label-wapper">
    <div>2020年03月01日 20:00</div>
    <div title="epubcfi(/6/74[id123]!/4/26/1,:41,:60)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>因为<span style="color: #FECF0B">不友善一直就是缺乏教养和内心脆弱的标志</span>，而且也显得很愚蠢。”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 20:01</div>
    <div title="epubcfi(/6/74[id123]!/4/34/1,:63,:82)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>但这并不意味着你就应该放弃，因为<span style="color: #FECF0B">成功并不取决于你是否受到了公平的对待。</span>”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 20:02</div>
    <div title="epubcfi(/6/74[id123]!/4/50/1,:29,:65)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">当你把目光都集中在别人的错误和缺点上时，就自然会忽略他们身上闪光的一面</span>。而<span style="color: #FECF0B">一个人只有具备了审视美好事物的能力，世界对他来说才会变得更加美好。</span></p>
          </div>

<h4 id="第三章-放大镜"><a href="#第三章-放大镜" class="headerlink" title="第三章　放大镜"></a>第三章　放大镜</h4><div class="annotation-label-wapper">
    <div>2020年03月01日 20:36</div>
    <div title="epubcfi(/6/76[id122]!/4/154/1,:13,:49)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>老妇人继续耐心地解释道：“<span style="color: #FECF0B">人们通常并不把自己已经理解的事情看作是奇迹。但是每一次的帮助却都是奇迹。</span>“唯有依靠这些帮助，我们才能完成本来一个人无法完成的事。“</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 20:40</div>
    <div title="epubcfi(/6/76[id122]!/4/186/1,:65,:88)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">无论在什么情况下都要试着去发现那些积极的东西。</span>”</p>
          </div>

<h4 id="第四章-论文"><a href="#第四章-论文" class="headerlink" title="第四章　论文"></a>第四章　论文</h4><div class="annotation-label-wapper">
    <div>2020年03月01日 20:42</div>
    <div title="epubcfi(/6/78[id121]!/4/8/1,:51,:94)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>金先生总是说：“<span style="color: #FECF0B">失败者总是无法成功，那是因为他们习惯于放弃；胜利者最终总是成功，则是因为他们永不放弃。</span>”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月01日 20:44</div>
    <div title="epubcfi(/6/78[id121]!/4/16/1,:115,:121)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>这下子吉娅终于看清楚了，是“<span style="color: #33D42D">马可·奥勒留</span>”。</p>
          </div>

<blockquote>
<p><img data-src="https://pic2.zhimg.com/80/v2-468c109bebe337f81174574fcae831cd_1440w.jpg" alt=""></p>
<div align="center">意大利50欧分: **卡比托利欧广场中央**的马可•奥勒留骑马像</div>

<p><a href="https://baike.baidu.com/item/马可·奥勒留/6720350" target="_blank" rel="noopener">马可·奥勒留</a>（公元121 年4月26日－180年3月17日），全名为马尔克·奥列里乌斯·安东尼·奥古斯都（Marcus Aurelius Antoninus Augustus）。拥有<strong>凯撒称号</strong>（Imperator Caesar）的他是<a href="https://baike.baidu.com/item/罗马帝国/3059" target="_blank" rel="noopener">罗马帝国</a>五贤帝时代最后一个皇帝。</p>
</blockquote>
<h4 id="第七章-好老师"><a href="#第七章-好老师" class="headerlink" title="第七章　好老师"></a>第七章　好老师</h4><div class="annotation-label-wapper">
    <div>2020年03月02日 20:25</div>
    <div title="epubcfi(/6/84[id118]!/4/78/1,:2,:6)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">勇于承担</span></p>
          </div>

<p>这里指的是勇于承担自己的职责。</p>
<p>这个世界本身就是不公平的，在遇到不公平的事情时，专注于自身的优势，勇于承担自己的职责(尽可能的想办法充分利用自己的优势)</p>
<div class="annotation-label-wapper">
    <div>2020年03月02日 20:20</div>
    <div title="epubcfi(/6/84[id118]!/4/102/1,:9,:106)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>好老师笑了，他说：<span style="color: #FECF0B">“你在把责任推脱给别人的同时，也把权利转让给了他</span>。<span style="color: #33D42D">‘答案’这个词就隐藏在‘职责’当中。（“职责”的德文为Verantwortung，“答案”的德文为Antwort，这是一个文字游戏。——译者注）</span>”</p>
          </div>

<p>责任对应‘职责’，权利对应‘答案’。即“把责任(职责-Ver<span style="color: #3CA3FF">antwort</span>ung)推脱给别人的同时，也把权利(答案-Antwort)转让给了他”。</p>
<p>牵强的解释：吉雅把她害怕参加演讲比赛的原因归咎于胡伯特认为她英语不好，即把她的责任(克服恐惧参加演讲比赛)推脱给了别人，所以她也把她的权利(决定自己是否参加比赛)转让给了别人。</p>
<div class="annotation-label-wapper">
    <div>2020年03月02日 20:22</div>
    <div title="epubcfi(/6/84[id118]!/4/116/1,:38,:123)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>可以这么说，<span style="color: #FECF0B">橘子本身并不在乎你怎么做，它总是提供给你橘子汁。它的答案就是橘子汁。它总是按照自己的意愿给出答案，无论人们怎么做都一样。它绝不会说：‘因为有人敲打我，所以这次榨出的是水。</span>’”</p>
          </div>

<p>橘子只会承担它自己的责任(给予人橘子汁)</p>
<h4 id="第九章-好老师的秘密"><a href="#第九章-好老师的秘密" class="headerlink" title="第九章　好老师的秘密"></a>第九章　好老师的秘密</h4><div class="annotation-label-wapper">
    <div>2020年03月02日 20:56</div>
    <div title="epubcfi(/6/88[id116]!/4/148/1,:19,:89)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>菲利普老师并不认同吉娅的辩解，他说：“<span style="color: #FECF0B">你必须学会勇于承担自己的职责。也就是说，你要将注意力更多地集中在自己的能力上。与因他人的成绩感到灰心丧气相比，你更应该想办法改进自己的成绩。</span>”</p>
          </div>

<p>不要抱怨，勇于承担自身应尽的责任——改变自己！</p>
<div class="annotation-label-wapper">
    <div>2020年03月03日 06:18</div>
    <div title="epubcfi(/6/88[id116]!/4/190/1,:112,:147)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>老学者向他们说道：‘<span style="color: #FECF0B">如果有人想给你们一些东西，而你们却不接受，那么这些东西又是属于谁的呢？</span>’</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月03日 06:18</div>
    <div title="epubcfi(/6/88[id116]!/4/194/1,:9,:44)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>“老学者接着说：‘<span style="color: #FECF0B">愤怒和仇恨也是同样的道理。如果我们不接受，它们就还是属于原来的人所有。</span>’”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月03日 06:21</div>
    <div title="epubcfi(/6/88[id116]!/4,/214/1:0,/220/1:29)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">勇于承担<br>●　遇事我能自我抉择。我能自行判断对某种情况应该作何反应。<br>●　我不受不公平之事的影响，而是将注意力集中在我能做的事情、我知道的知识和我拥有的东西之上。<br>●　我把责任推托给别人的同时，也把相应的权利转交给了对方。</span></p>
          </div>

<h4 id="第十章-7条准则"><a href="#第十章-7条准则" class="headerlink" title="第十章　7条准则"></a>第十章　7条准则</h4><div class="annotation-label-wapper">
    <div>2020年03月03日 06:48</div>
    <div title="epubcfi(/6/90[id115]!/4/206/1,:65,:99)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>有位音乐家曾说过：‘<span style="color: #FECF0B">如果有一天你不再相信自己可以进步，从此以后你演奏的就只是同一首乐曲。</span>’这句话的意思是：只要能坚持不懈地学习，生活就总是多姿多彩的。</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月03日 06:50</div>
    <div title="epubcfi(/6/90[id115]!/4,/212/1:0,/219:0)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p><span style="color: #FECF0B">值得信赖<br>●　我能否成功总是取决于自身培养出的习惯。<br>●　如果我是一个非常自律的人，我就能比那些虽有天赋但却懒惰散漫的人获得更多的成功。<br>●　我总是很守时。我信守为他人作出的承诺。<br></span></p>
          </div>

<h4 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章　事件"></a>第十二章　事件</h4><div class="annotation-label-wapper">
    <div>2020年03月03日 20:10</div>
    <div title="epubcfi(/6/94[id113]!/4/64/1,:39,:41)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>树枝尖把大家的皮肤都划破了，他们还时不时地被<span style="color: #33D42D">荨麻</span>刺到。</p>
          </div>

<p>荨麻 [qián má]</p>
<p><img data-src="https://www.kostbarenatur.net/wp-content/uploads/2015/09/grosse-brennnessel-urtica-urens-3-1200x800.jpg" alt=""></p>
<h4 id="第十三章-回家"><a href="#第十三章-回家" class="headerlink" title="第十三章　回家"></a>第十三章　回家</h4><div class="annotation-label-wapper">
    <div>2020年03月03日 20:29</div>
    <div title="epubcfi(/6/96[id112]!/4/22/1,:65,:69)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>与银行账户相似，世间还有一种叫作‘<span style="color: #FECF0B">关系账户</span>’的东西。金先生立即对她解释道：“<span style="color: #FECF0B">当我们伤害别人的时候，就等于是在‘取钱’。</span></p>
          </div>

<h4 id="第十四章-道别"><a href="#第十四章-道别" class="headerlink" title="第十四章　道别"></a>第十四章　道别</h4><div class="annotation-label-wapper">
    <div>2020年03月03日 20:52</div>
    <div title="epubcfi(/6/98[id111]!/4/118/1,:15,:50)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>但她又想到了好老师说过的话：“<span style="color: #FECF0B">与其为那些已经不在的事物悲伤，倒不如为那些令我们感到愉快的时光而高兴。</span>”</p>
          </div>

<div class="annotation-label-wapper">
    <div>2020年03月03日 20:54</div>
    <div title="epubcfi(/6/98[id111]!/4/146/1,:15,:55)" class="annotation-label-pos">POS</div>
</div>

<div class="note no-icon">
            <p>道别的时候金先生还对吉娅说：“<span style="color: #FECF0B">永远别忘了，当你努力去成为有能力成为的那种人的时候，你要明白自己并不是独自一人。</span>”</p>
          </div>

]]></content>
      <categories>
        <category>Reading</category>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title>Export Notes from iBook</title>
    <url>/2020/03/07/Export-Notes-from-iBook/</url>
    <content><![CDATA[<img data-src="https://pepaless.com/column/191009_01/3.png" width="100%"/>

<a id="more"></a>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="ZAEANNOTATION-笔记表"><a href="#ZAEANNOTATION-笔记表" class="headerlink" title="ZAEANNOTATION 笔记表"></a>ZAEANNOTATION 笔记表</h3><blockquote>
<p><code>/Users/username/Library/Containers/com.apple.iBooksX/Data/Documents/AEAnnotation/AEAnnotation_v10312011_1727_local.sqlite</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Not Null</th>
<th>Default Value</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>Z_PK</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>主键</td>
</tr>
<tr>
<td>Z_ENT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Z_OPT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZANNOTATIONDELETED</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>删除标志</td>
</tr>
<tr>
<td>ZANNOTATIONISUNDERLINE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>是不是下划线(iBook中下划线表示重点)</td>
</tr>
<tr>
<td>ZANNOTATIONSTYLE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>笔记类型<br />3: 黄色 <i class="fa fa-circle" style="color: #FECF0B"></i><br />1: 绿色 <i class="fa fa-circle" style="color: #33D42D"></i><br />2: 蓝色 <i class="fa fa-circle" style="color: #3CA3FF"></i></td>
</tr>
<tr>
<td>ZANNOTATIONTYPE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>类型</td>
</tr>
<tr>
<td>ZPLABSOLUTEPHYSICALLOCATION</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>绝对物理位置</td>
</tr>
<tr>
<td>ZPLLOCATIONRANGEEND</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>位置范围结束</td>
</tr>
<tr>
<td>ZPLLOCATIONRANGESTART</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>位置范围开始</td>
</tr>
<tr>
<td>ZANNOTATIONCREATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td>标注创建日期<br />类型：Timestamp<br />注意：这里的时间戳是相对于 2001-01-01 08:00:00</td>
</tr>
<tr>
<td>ZANNOTATIONMODIFICATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td>标注修改日期</td>
</tr>
<tr>
<td>ZANNOTATIONASSETID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>对应书库表中的 ZASSERTID 字段</td>
</tr>
<tr>
<td>ZANNOTATIONCREATORIDENTIFIER</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>标注创建者标识符</td>
</tr>
<tr>
<td>ZANNOTATIONLOCATION</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>标注位置</td>
</tr>
<tr>
<td>ZANNOTATIONNOTE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>笔记</td>
</tr>
<tr>
<td>ZANNOTATIONREPRESENTATIVETEXT</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>笔记所代表的文本</td>
</tr>
<tr>
<td>ZANNOTATIONSELECTEDTEXT</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>笔记所选中的文本</td>
</tr>
<tr>
<td>ZANNOTATIONUUID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>标记的UUID</td>
</tr>
<tr>
<td>ZFUTUREPROOFING1</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>未来验证</td>
</tr>
<tr>
<td>ZFUTUREPROOFING10</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING11</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING12</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING2</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING3</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING4</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING5</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING6</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING7</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING8</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFUTUREPROOFING9</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPLSTORAGEUUID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>存储器UUID</td>
</tr>
<tr>
<td>ZPLUSERDATA</td>
<td>BLOB</td>
<td></td>
<td></td>
<td>用户数据</td>
</tr>
</tbody></table>
<h3 id="ZBKLIBRARYASSET-书库表"><a href="#ZBKLIBRARYASSET-书库表" class="headerlink" title="ZBKLIBRARYASSET 书库表"></a>ZBKLIBRARYASSET 书库表</h3><blockquote>
<p><code>/Users/gzhennaxia/Library/Containers/com.apple.iBooksX/Data/Documents/BKSeriesDatabase/BKSeries-1-012820141020.sqlite</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Not Null</th>
<th>Default Value</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>Z_PK</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td>主键</td>
</tr>
<tr>
<td>Z_ENT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Z_OPT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCANREDOWNLOAD</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCOMPUTEDRATING</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCONTENTTYPE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDESKTOPSUPPORTLEVEL</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDIDRUNFORYOUENDOFBOOKEXPERIENCE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDIDWARNABOUTDESKTOPSUPPORT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFILESIZE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZGENERATION</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISDEVELOPMENT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISEPHEMERAL</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISEXPLICIT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISFINISHED</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISHIDDEN</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISLOCKED</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISNEW</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISPROOF</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISSAMPLE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISSTOREAUDIOBOOK</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZISTRACKEDASRECENT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZMETADATAMIGRATIONVERSION</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZNOTFINISHED</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPAGECOUNT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZRATING</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSERIESISCLOUDONLY</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSERIESISHIDDEN</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSERIESNEXTFLAG</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSERIESSORTKEY</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSORTKEY</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSTATE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZTASTE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZTASTESYNCEDTOSTORE</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZLOCALONLYSERIESITEMSPARENT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPURCHASEDANDLOCALPARENT</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSERIESCONTAINER</td>
<td>INTEGER</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZASSETDETAILSMODIFICATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZBOOKHIGHWATERMARKPROGRESS</td>
<td>FLOAT</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZBOOKMARKSSERVERMAXMODIFICATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCREATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDATEFINISHED</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDURATION</td>
<td>FLOAT</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZEXPECTEDDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFILEONDISKLASTTOUCHDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZLASTENGAGEDDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZLASTOPENDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZLOCATIONSERVERMAXMODIFICATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZMODIFICATIONDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPURCHASEDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZREADINGPROGRESS</td>
<td>FLOAT</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZRELEASEDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZUPDATEDATE</td>
<td>TIMESTAMP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZVERSIONNUMBER</td>
<td>FLOAT</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZACCOUNTID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZASSETID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>对应笔记本中的 ZANNOTATIONASSETID 字段</td>
</tr>
<tr>
<td>ZAUTHOR</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>作者</td>
</tr>
<tr>
<td>ZBOOKDESCRIPTION</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZBOOKMARKSSERVERVERSION</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCOMMENTS</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCOVERURL</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZCOVERWRITINGMODE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDATASOURCEIDENTIFIER</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZDOWNLOADEDDSID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZEPUBID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZFAMILYID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZGENRE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZGROUPING</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZKIND</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZLANGUAGE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZLOCATIONSERVERVERSION</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPAGEPROGRESSIONDIRECTION</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPATH</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>文件位置</td>
</tr>
<tr>
<td>ZPERMLINK</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZPURCHASEDDSID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSEQUENCEDISPLAYNAME</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSERIESID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSORTAUTHOR</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSORTTITLE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSTOREID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZTEMPORARYASSETID</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZTITLE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td>书名</td>
</tr>
<tr>
<td>ZVERSIONNUMBERHUMANREADABLE</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZYEAR</td>
<td>VARCHAR</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>将内联样式提取出来，结合 NexT 自定义样式，添加到 Post 页面 Body 中。</p>
]]></content>
  </entry>
  <entry>
    <title>Entertainment Video</title>
    <url>/2020/03/16/Entertainment-Video/</url>
    <content><![CDATA[<img data-src="https://bmcreations.com/wp-content/uploads/2014/10/bmcreations_homepage.jpg" width="100%"/>

<a id="more"></a>

<p>一直以来会过度观看一些综艺、电影、电视剧等娱乐视频，觉着适当的娱乐无可厚非，但是过度沉迷，或者花费太多时间就会造成很大的自责感、愧疚感。想试图分析分析原因，找一找如何克制自己过度娱乐的方法。</p>
<p>希望能将娱乐时间的比例控制在一定的范围内，能够做到“适当”。</p>
<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><h3 id="舒适圈"><a href="#舒适圈" class="headerlink" title="舒适圈"></a>舒适圈</h3><blockquote>
<p><a href="https://www.jianshu.com/p/d053ced4894c" target="_blank" rel="noopener">看电视剧、综艺节目上瘾——根据人性谈学习</a></p>
</blockquote>
<p>因为在看娱乐视频的时候我们处于<strong>舒适圈</strong>里！</p>
<p>在这种舒适圈里，我们的情绪随着情节而浮动，我们能够专心致志的观看，其他事物很难影响我们的主要思绪，我们会沉浸在这样的世界中。</p>
<p>为什么舒服？</p>
<p>处于舒适圈，意味着我们是<strong>被动</strong>的，大脑、情绪围绕剧情而动。舒服是因为不需要主动花费精力，只需被动接受。</p>
<h3 id="跌宕起伏"><a href="#跌宕起伏" class="headerlink" title="跌宕起伏"></a>跌宕起伏</h3><blockquote>
<p><a href="https://www.zhihu.com/question/20215906" target="_blank" rel="noopener">人们为什么喜欢看电影？ - 知乎</a></p>
<p>是为了报仇，向平庸的生活报仇 。——韩松落</p>
<p>因为生活本身实在是太乏善可陈了，大家伙忙着生忙着死，渴望不凡却生而平凡，庸庸碌碌一辈子，拢共能经历几次挑动泪腺肾上腺的大开大合大起大落？而电影，用两小时串联起一个人一辈子最起承转合的时刻，用镜头隔离出一个让你沉浸其中的虚拟世界，这个虚拟世界中的人物，可以不凡地活着，有属于自己的故事和传奇，闯着你想闯却不敢闯的祸，爱着你想爱却不敢爱的人，他们展现着最浓烈的爱恨，或善或恶，亦正亦邪。就像罗素说的那样，参差多态才是幸福的本源。</p>
<p>杨德昌《一一》里面的台词 “电影的发明使我们的人生延长了三倍。 因为我们在里面获得了至少两倍不同的人生经验。”</p>
</blockquote>
<p>因为生活太平淡了，在电影中能够体会到情绪的跌宕起伏。</p>
<h3 id="寂寞"><a href="#寂寞" class="headerlink" title="寂寞"></a>寂寞</h3><blockquote>
<p>以前我也跟其他人说的一样，可以知道不一样的人生。后来《看电影》有一封读者来信，才知道，<br>其实就是寂寞。</p>
<p>攻壳机动队里面的台词：<br>“我当然不会说那是个糟糕电影。不过，基本上无论什么娱乐都只是一时的，而且也应该如此，像这种没有开始也没有结束，只是一味迷住观众使其无法离开的电影，不管它是多了不起的东西，只是有害无益”<br>“哦，很严厉的批评呢……在这里的观众中，也有人一回到现实就会遭到不幸。如果你把那些观众的梦想夺走，你承担得起责任吗？”<br>“承担不起啊。正是在现实生活中拼搏，梦想才有意义…….<strong>只是把自己投射到别人的梦想里的话，跟死又有什么两样？</strong>！”<br>“真是一个现实主义者啊。”<br>“如果你把逃避现实叫做浪漫的话。”</p>
</blockquote>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><h3 id="如何让自己活的更舒服？"><a href="#如何让自己活的更舒服？" class="headerlink" title="如何让自己活的更舒服？"></a>如何让自己活的更舒服？</h3><ul>
<li>一张舒服的床</li>
<li>一张舒服的椅子</li>
<li>一张宽敞的书桌</li>
<li>一架完备的书架</li>
<li>一只可爱的宠物狗</li>
</ul>
<h3 id="如何让生活更精彩？"><a href="#如何让生活更精彩？" class="headerlink" title="如何让生活更精彩？"></a>如何让生活更精彩？</h3><h3 id="如何不寂寞？"><a href="#如何不寂寞？" class="headerlink" title="如何不寂寞？"></a>如何不寂寞？</h3><blockquote>
<p><a href="https://www.zhihu.com/question/22055804" target="_blank" rel="noopener">单身，不谈恋爱，怎么才能不寂寞？ - 知乎</a></p>
<p>一个人在单身时觉得孤独，多半是闲的！</p>
<p>一个人只有将自己的生活安排好了，才有可能将快乐和充实带给另一方。而不是需要对方来完整自己。</p>
</blockquote>
<ul>
<li><p>建立自己的社交圈。</p>
<p>可多参加一些群体活动：打球，聚餐，旅游，唱K，马拉松…</p>
</li>
<li><p>培养适合一个人参与的兴趣爱好。</p>
<p>例如：一项健身活动，可以是一周跑步三次。或者学习一项能带给你快乐的技能：游泳，舞蹈，摄影，烹饪…</p>
</li>
<li><p>不断学习，充实自己的大脑。</p>
<p>例如：对工作有用的专业知识和技能，能够充实灵魂帮助你领悟人生的书籍…</p>
</li>
<li><p>有三两个可以谈谈心事的知心朋友。</p>
<p>生活的不快，工作的压力，积压久了，人就会累。倾诉可以适当缓解这种压力。可能这项对女生比较管用。男生貌似比较倾向自己消化情绪和承担心事。</p>
</li>
<li><p>平时多和亲友及父母沟通。</p>
<p>多和亲人联系能够排遣内心的被孤立感。因为家人是永远关心和支持你的，也是很多在外打拼的游子动力和温暖的来源。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Encrypting Blog Article</title>
    <url>/2020/02/23/Encrypting-Blog-Article/</url>
    <content><![CDATA[<img data-src="https://dotlayer.com/wp-content/uploads/2018/11/dotlayer.com-how-to-encrypt-decrypt-files-with-openssl-on-ubuntu-and-mac-os-x-1500x750.jpg" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">hexo-blog-encrypt | GitHub</a></p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>安装 <code>hexo-blog-encrypt</code> 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
</li>
<li><p>博客文章中添加相应配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">password:</span> <span class="string">mikemessi</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">Here's</span> <span class="string">something</span> <span class="string">encrypted,</span> <span class="string">password</span> <span class="string">is</span> <span class="string">required</span> <span class="string">to</span> <span class="string">continue</span> <span class="string">reading.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">Hey,</span> <span class="string">password</span> <span class="string">is</span> <span class="string">required</span> <span class="string">here.</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">Oh,</span> <span class="string">this</span> <span class="string">is</span> <span class="string">an</span> <span class="string">invalid</span> <span class="string">password.</span> <span class="string">Check</span> <span class="string">and</span> <span class="string">try</span> <span class="string">again,</span> <span class="string">please.</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">Oh,</span> <span class="string">these</span> <span class="string">decrypted</span> <span class="string">content</span> <span class="string">cannot</span> <span class="string">be</span> <span class="string">verified,</span> <span class="string">but</span> <span class="string">you</span> <span class="string">can</span> <span class="string">still</span> <span class="string">have</span> <span class="string">a</span> <span class="string">look.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ol>
<li>加密博文中的代码块样式风格不能正确渲染</li>
<li>加密博文中的代码块超出边界</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Building</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>Exercise</title>
    <url>/2020/02/23/Exercise/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Third warning: This content is personal, please skip it." data-whm="Fourth warning: This content is personal, please skip it."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Warning again: This content is personal, please skip it." /><label>Warning again: This content is personal, please skip it.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="cd4ea531fd60164932c5e87127ff948026f1664dec687577a259b1db085aabbf">6b218a509ba08e6ec04160b9b6a8a44eaca8e30b287080893ae71251ada00022bcd7e4772d3c4bfeb2baa8e194742958adfd60541c3bb5cd0ea7334df66ef5145b50d09d51fb7655751bd6c0c85d450f3e85ee1466a0eeffe4dbc7004f3d483583b2bf16bf642c3d585eedc6bc9ab507b5ff5fa2e24c8277a7bca9c24786334b5c2b54edde270e81cdc5eb9df79607cbdd7b5f65b9deae962c223297e44bf6164b5ed78d1ec42f68cc9c6f5811dad7dc7b760b7e63d30410ec3c34ce9d1c44240260d5abbc4b381a559f73c0b8a894cb257f493fbded64a947968b254d034c6c965554f7fc329d642fa2352d193d5ddd4908d98727cc4f3c8a3e9cbfe82ed517d1a9edeb34343b27bcec25c5c6d4b4b205e27bf5a3caae3925182a518503101e89b9cf5dd17a44794b5f66decc8862621739aa3a1cda8864af1c7b6ba26c323b6598fc09f24706372258726aabee80298e0d0c2bc3b3fdcc047c34b3dd21f8fe14ee1af41e54e482100534e8888e12847cbca273cfae7ce0887d98ee1449d1ce4f7eaaeca36743f10cbe4a30c55511c36ea46d9f5d62dd18fd41459d742746c2a4f773c7fb0190c302f1aa05c0db1f9f5f68b9faae0465035ee52f137a94baabaacfbe01f2bdb5ea0e0774d84a4fa0cbfecb9e6a15b011158f03f7aad26fc72a0cbb175ef5c07b72aecd98747f672bcdbfa16d0bcaa80680e83c2ab42daf6bd9f361d5619b28eb97515fd9b5d38e65dc73f5fdc082542814ca99d76ae11a6204a6aef4193c466e052a4f4670e9ad7e94535be8881234531595be1a14056749ff3650893d97ae5eb3b70062f65103fd9cb8a7f345cec05e96740a4ce41db2854305f7acff3ff95ac9b37be6217e6fa4e25617fcb06447593334ee8bbb566409d16647cd816b50f206187f6b6bbebc23505268788ae20d60906635f599eeeb28e10f74ba03012d46b93bb816b0c06e05c94064bdda417debf0f7675deb4e4b32ea479dc2412454d1665609b102bd61fd9696d66a3fafdd11a9dffeed0a9dfba51fdd63a5f5a781b5646f7cf33944ee4ecebda8b25c0e26347670dbdfa1a85ebae1ccfabc6b43b78d00ed7b034bc3fa6b567f8961ff95150a2948b5bc268673df60f81a531556a7b5e717370726aa79ce8c7bcf8f2fc198c130c1258d63f92703e15b109c78241c534bb18b93a2afd05734d1207d01bf98aca783e1461ff2db2474968dce7b6cdea9b4fa15c4e382955b1b00b60647090250077446988b4ae97de19ba6e4ceaa734b0a55317cceb168c08bf2723783217c12a81ea9e0fe1737054451af3fc6ae8724d2efa15b11fc8dcc1c0fbd6d7bb8e8a943c85d8412ba2077c4c2d160166af3d34337d4862c3a4af6b117e472f274fd56b4b7a59e23c5387703ae4bb210cbc886f37ee28a28ac908aee3fae84e0b5c1d10ee4c6502ca59af5be49dd4504992ff6e939188608b27c8da78457b1b8727c7e0a4666d7c506552ffa2cfb86153cc74df5f1e79fa63d3d0bcfdd4efa80d3d5b1576132cf29ca1f95786d1c575e6780460d5d9db3a2c89edbca05b3703480d6cc22376c065f17f1e96c3940955d22b517020b63988a7fcd75efec971b0a02bd3077b5d1d3dac3c41b6cbec4333d3bc399811ffbdf85d77801eac43d2974f9972ad2c39daf2375b7a32353283b9c9539f7ac60445b895ffe0574695a540d0f20b8da5edb388afdcae4e681b7fddfca428ebe99bb23fb6f7b35e78ce1283d16534d7490fd251d467fa791bdd5230f653155d6388db364caa5b39ddf198e7b829b135cab6b61f1e89b69fc11b1995b2183a8eb8b37beeb3514d33f4f143f6d8e18e41add3724b53e3ec94cd8afafbd06721291a8f18c7c492184f46c7c6cbe3d2d389078708747857f961246c1f9beab1a265f1a4448ec337780f49ee0f2e4b0d28822c9cee1d8af7400940ac397a75dbfbc8ad2c79ce57af96c869cfba5ceb9396b4c1909a8b0d9eef39f84ff5d927b6e24fdb0a58e14ce90f7e87ced796285ff8bc8f96450fa8295a77e5a753ae4d692cf890f2999f6231e113a77bd30d0e4b19c7c8739c825852f41d62d21600e47c50b5abdf0416bebd9a0fb55967b766c5864b977ac78860aa38d0edf60305c3838398d6b91e31c152b6e3550418a059d96b17f5b35f0d08a525edd610bb45c0e887933d3f0ad58ae4001d24dcd463805093612f0323e718f509f85c70e558ebf28ca4541398d483d8eef5fee87e3bc91107265e3ded4adcdf97d029c68aa155185cc0b17479537a36bcf6902bd263aaba12b8f0b7093dfe8c73a94f180d433d1cc1d827c95eb9136f80601610ebc4062ccd6a7dead63d533e0ba5883aa8e37c60c75cccd81a2c6d5225b27aeb8e28b60fd15bdd81e2cfd9c236e8b26cd8e6c71dc524a4d63f5b5153b4d4700d8800aab76263044f975a16bc750de898305296c0c877a46eab3541318c728b4f08bbb2436aa4e210abe32913aa0eb72be26c9d3d5226a73bfb5cd864121d71874b882a707079db3b85fb828c59c49a7255e480fc0856de3b50b05b8564a446378514a9b3216ba569fa14094d3f075495f3f3a83e2bb0e81a63a8785b31933ed886337e00f2434cd27fab52b1d28ff505209ff90ae3c7099e4a02689777209d3d56bbade6c2bb344345e27ab4b5c23fce957bdcf9b93d31002f0e9994c62b21b7dd8d1069c03b3a0778f1eba713efa158447895e13a45fc424381627e46e5f1a276b67689bd5366cabc0a83dbab33710acd53f21e11f9563e947c671aff43d3fd9365aacab32fe15427ff5087b4ba2909bcd58f47d99d6ef5bf72836f5fe92b1d2488e53084090bc9fee209d4c3b415b2d0825deb99e66688eef64b80f21b3c4357d9a1e221252138c7d17d4aaad32e54c0238bbd7da305ec7ecce75c7c4a924b56ab4409c83767b3851fefe07656a87fa6dbc5cc7f87f796d183561bf7d2638d3f492cd9668fd121db60afd773d6c39423cce8bbb7eade2dd5d047cc25124505455f1c2584184f152e04275ef65c8738056ef6f81340178b441c5488ef77b92733d76888437236d868d1246226d8a76fc0532d7290700fe7eb0dc9bbbe6a12b9b6011823f70644ba8ef41a8584616681c2cb32f49ad21319846ff50b072d4001ff719cb19de9024852d81cf2345173b563757e0c1221ddf7a2cd7f77f70b602e6d45a82fd31368a8156581766d03605d11c15d8f9af94665f97f504fc979b10997b3058a8d072bff50ba110bcf1c6f1738ad88a7821edbdaf9bc1b6740624e7968520980f988b4079daa6b7f736c2e39bc18b3014ea55361036dfc278308a3984aef5c5392cf47de6d69318bb44fa76fb09608ed9e8faaa69ba8c03a57cfdfa7fd69c2ccec8b64b27e2eed9227e9f18b7cd85548fe01cc77b1ec6c5fbc29d34dab5ec9c40dc3271d2941bc1f19619f9cea63ae3334bb82c729513081c2e47405c0e2debbc6540d15443195a57791daace960c910d7da8e01833f5ce7fe3eae9922ae889869d6f6766e757c33e5101997bd476933d0f08b21bffce14a88106a909546ed6cd63b7090216e61552ed82e3cef24b96de15ddf1f4e9e7457a001541f0549803bd1eb3deba4013eb80c23e7c798c6933537447e8ac8f8a3357247277c4866d9130d8a96df66bde90481f68d633be24fb307b9dbba2096b23f3ff455a18b520b95ad483ec233f47e69c89f62490a71aa20e71e599e2b93340dbe73bd14c5068ef6ec0572b77b3bdbbb995614a4b766f988d85615af5e8342c68a703c813ba4f84c0b808d98069699db8c0eab3bb45ca3fdb5a751710c03f25939d7a5a76bab975d91bc829aaa6676bda567e8041d68c79b0d183e63467886a79cec03581853ebe63a1370c3ef0d7c8c82d1f60965cb588779878eef6fa4d1c35ec34500810d1735887874381bdba8f6eb99d6735b1e28096e275a9ea03cf95921cd863fbdf7856574dece51b4cfd45c1340237a7fd8ed0985597c4138a210eb023200740d03208f983cacee836305ed934765282fbfda1d55b4477bf7866d09e37700d757596067b036a1141d51ba20e12cc470fd46e48836b891f6597f56ea28795b88b684c2d4ab39f496e1cd873b06b78baaf4e0757341424dd1d12bc2dce7e9b193e018b394e9d0ba43f2e06442a124182ca91e8822eff043f2dd692fd56a289ce1dfd12c713374de434899c1aa282ff79fe10ee748920abb1244f1bde607326d7f157695f0401084a3e95e8163b0e9c0d50de75ab53a461f1ecb55cebfa36eb5e5336811a7d46c56cb1c961a4ea43f25862092527029083c5c8747c4b4943f9665b85f8ed8f1c4874b848349964265721799befcb3ee08914a61f22bc0224e130c1ae9fa53df104e9b080ee5ee388b4a6df0fd94b1c81931a28e38d5367568c53ed30c776e11dcf510debecb882cca48971821cbf1b28576bfa2eaa8bf8d32dfe8ec122dd11c9036f9160ed89148c730155020c5a62fdcda5c0d6906f9640e4b1f9a74c3c7927d5b5e6f371e2406ab8b1b4b0e4eb11aba620140734af9bbeb33fcee1c20803a3b578ce3f88b559a5d5117214e869973676a20ea941082f603c33f5305d58d259b17aefc38fdd1054640dd3646e38796df1dc146c828e9edae7e46fc57105e17e83b97f404ed00149c288c59c1b3e579508f8bcba4fa0155ada43384681063c8748d723baf66f3c3e709abd2c32403cf3201643846512ec633159af9f68b38db7adc5cb0cf2148dd1df2a5d263c52a4d316069ffbaa6d9141259992fdf4c5c6503cffa276a636f52be5a3dc32100c9bbd9fd5c9527ae60d53d8aabbc4dd07664dfeb180196c936d11415d568eb2e01583d1907045a4398e4af1a6ccba3a03b7dd5e3bc9223ea38ea87019f6aafb9db7e17c211348145c024e79f476d1a90580ec6b0fe7f785a250798adf149eb37842b373275279b573dc1605a49af6b4d807b3ae229af5ad0fc30d8d3f703830809604fc0db1cc6049bd0bc0913c8dfa72b1d79696bcbfec9456f852b7333761fb0128eff88de00bcc86e238a54f042f42724492fe42dd69712d66580879ff09be8fa00a13605332a6d93366d22fbdb10a562bd475484aeb4984ca5e4c9dba5322c3679a2118b2b79c5ca7ad6f78603be76f94a7b4efed2ccc40d845e84568ab8fbe89e9806d33e1eb854f9b9829eae10ba50d539b55471eb99a3f7317e95cd18321655a9784e5ef1e98d2bfbfd54dc7886038f7821919ebd542935405b4114887e2b80eaddf87a49935ec1db9893a087678e474a7c48cac5dd8355401efd092941e129e1050ebaa3f20dc9ada66eb5e0bf536e2244926b1bbadf7eece5f6146498aab07d7b7e62ad003d5cece4c496a3c68f4148784da6d4ba8a5ec4616f27bcebd131b7c5f27cbc1f1229a712fca455e282fd720a769e78dc241f0d8e386a713c567763cfb116df1ceb86d2ea3e41661da04cdb601953e06947f2ec83be0fd4c26daaabd602384e8df996498d52ba21f6fef130189a82257c06f3166502de75779e4ff29994f6f050e1ea5e6cc0c3a5663264faa09dfc456708296b73bb7528522f255c242423e6310d68c52693d04d7326894bfd1d28ca0ddb3581e9d244b9088843b61aaba430ae1cf99cf8c9bd85e9d2b3a7ff70e86c2d26206c258aa7f79b4aa4187f02a073648993edff4ae924142eb32f8238dcc3dc0b9fd9f08f4f01a6c738064e6322b12040a214bf33e427f6a27a88ce20993d6aafdee0331efde6e14f56510e616fb41e954fb54b24856a2249ad62c28838ae72f356be11be070bcbaec4b6d701093c768f390f839c371dc84670edefce1d89db42140fe88dbafed3bc0011b09da912ec9196d5a5d2578ba283c26f53151aec55423d53209412c30274f87174fc7a421bb618bd2c79c27eb7c9d19a36fc655170baa431e10a377acd253de733a4f9ca3f5d9232ad820b42c49e2710d3b5cde1cbcf88cd8f5a9566dc5f7f30f1101a6077abbebe4ee392483f5653f71fa616fea59281780beb3c410fad44327fabbcb5470cd54f842796f952d12a46744ee8b818ddcbcaf93780f54193428d9397311f663d6cbbb27e7e42b88d52fd8402329e4e028856b9d8f4ea8aa774d85cad0f30c1e806cb6124dd60b291dee63db2c22a3a9ba8b6f959eb313ffac71646b50ed9f8fc75c357e2f1f4de37199f921f092143c292a35515582fed10d0c9b92bc31f987acc30fe50a206ce001043e785ef081d007b4f86d6d2c7e31837c522fbb5595584b019e0f85071d18c361d6d4d05f3fdd568c7afb0997d5db4f4be4a176ef65d836ba8abe26eac01f07603939354115d2f2ea88c291dbd4e72515e1fd3ced2fc6ee8d8904e5c015a8372446d4a075d2dd744d96542a58a46f78ddb59fa2eef52b9a2ae793b727d9912cb4b73d074296220dd7695d44f9953a26a91448a7eaa27c508cb6618fbb9abf7f65c8c04a858076b0610a00ae1f099ad00a3c09e3936f8062b778881e61bda5456979cf45f2c3cddb5b3236b5a9b0e2bc3a13033899b5b5958a846dbfc4a15b824a0e4bd10d0bea73a654ac4bc7e429e7048648c588e79aac179a49ac983d4581dd62376863975df6ab61750ae3f67f657529315d16d855c1914f1865ab3e3886a1e2afe067352459807a89032c6f35d79c2eef4c7532e6ddd6a9cc1546b605d8374550670b7c0a24dec7b09d1f1d592704b64d2ad6204db2cc940766a49425847cd02454315e58df2a20fffaa14dd20333b4c667cd22d475617fc08c7bd53bc88e1831255a551e125960304cde7809b76a85477090ce76ef262a30a83c7563e4b9886b0144467fc9d164729e82e11f7640ed92ea384282704b36db5050f02e13be7752b1d81cb211f3a6daede6cf9612adb5582c2dc1279f11eb5dd85f431b2322db21e7da47b111cd8de23acdd6860b19f7eb86c4c54308bedd8bd94007d444c21bec0177174911124f18438d1f4e0f0153aa861de3c21cf295e7c7f14a6fc18625cb2ee40b814d176cc3c320a9026d3760053f98aceae11f7bdb3011d69215527ad15ef5eebbc89949b5af4031a1e9d0b8d29f93beae067a429a1293d9ad64b41aa3899255b717a3ab18a7ca7419e84233a8e0a35513280b166ad70ff8ea0b1aaf6a23864ec17562a14bc8e7980c0a288e23092e67a85f863b501d74ed7c529a102b38ed3467b2fcbaf6615b8b8a280b7483f2a78f5a73f7a2be35b60c5ecb1dfb59fc2314a678fc2b4bef478fab14df4808bdf4ad746567d5f91cae1fa3be1f32081f13059850854449b37308cf04afd8808f7b4aa1b34e6378bb46fc512ac3fcfa44f3653c13bf46b3bacff3f3ac5707c70571f8cded1480ea103533f2e02d33b727c4179168cf51e0a4012c92da4e89f67285957d8610d0baa651d90fab8aad9709ffcd3e611406945d1c8c6f531c3fb138b9270e802baa13a052a51943cebf6f7739160a4eb288d1b16246dafa4294b6c524a7743a1e9f63737330ee0551bc602b87e06951d9fbd687fdba5973c515c180ec016b01352facf478974ea0e54b3d27c50643fb49ccc7bc77e6761bc34fd99d463dca8e397dfbee2b01c276c3d7d53ba3ec5a52eaee2d7d6c30bb5992556a37110e7960cb6a56278f97b83e8746abbb05a1f617cf5ebf07560a360a8a0bf06f4ed323d7f13c71f26bddd7c6d74aefc0161386328b8e52ce5af5a6400d6c5d857e1f1738d806a9ac7e2fc9f4f74bb6ac71cbd79262f9da77be1ef1ab18efb0b6f51f382e94f3fe786edae78d74942238b676770f5a98c697257c26bb1ab169879972a7b9fe6a5fb1e56b4349e4179f2433b1954d40340c854ed5d87874f198babfc4a1fcfaab5f97ec68ca0846033f1f2a378ea2fdcf52913cec75e0e0253eba02f5f00c0a9b2763e30cff310544c738821e2a9f81ac2977a704b617050a1b9d2fd78da23cce33f8d50fa2c9d808618b08a976044905f2c0c1027e374ff3d1b3d8e3b4657935dc6a70dd5e85a89a15e3913ecbcf4877cac9db3fd3f99f44828a4217a49498f895f1b7ef6ff079959b810e2e2eefed3cd735294c70a2bdbc03548d0518cc67f5f6317cb8db73aedb0753f27122836b12ae062ede801c2b5539f31bbcfaedeaca1f946f12c517c947d8a347ae67435c3caf5b55c3db7a83b1323bcd0a405b27c6336f38c52f54ec29eb72eb6e5a22a4b1cf2cf96f931e26bc3c87825d847f7ee651edaa6c9eaf4a77d6fd728916b5e47d23b48ebdf596afbc4c99dfdc7365ddebe50569ad0ec0033a089b53612c87a5cabc118c10b256d98b401c2a2c02afeb4c8467d5b36e90ec83163c8eb8e08ebc3b51ca4326f8bcb3b8c6b17896eea14296219ac3323de7e84c79bdd7b2a5db436a75d74f8108ea42b83a652f9bbcc1ba</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
        <category>Good Habits</category>
        <category>Exercise</category>
      </categories>
  </entry>
  <entry>
    <title>GTD</title>
    <url>/2020/04/08/GTD/</url>
    <content><![CDATA[<img data-src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcSMYmCuxI7d9TWX_Up8HWwEbmRiVl9SasWWtb-w2tyyQ3Q2lSuA&usqp=CAU" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://gettingthingsdone.com/common-tools-software/" target="_blank" rel="noopener">Common Tools &amp; Software</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2025/07/22/Git/</url>
    <content><![CDATA[<img data-src="https://git-scm.com/images/logos/2color-lightbg@2x.png" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git</a></p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a></p>
<p>由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。推荐从 <a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">Git for Windows 国内下载站</a> 下载。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>根据安装程序一步步安装即可。</p>
<p>注意一下几个地方：</p>
<ol>
<li><p>Adjusting your PATH environment</p>
<p>勾选第一个选项：Use Git from Git Bash only</p>
<p>因为这种方式最安全。</p>
</li>
<li><p>Choosing HTTPS transport backend</p>
<p>勾选第一个选项：Use the OpenSSL library</p>
</li>
<li><p>Configuring the terminal emulator to use with Git Bash</p>
<p>勾选第一个选项：Use MinTTY</p>
</li>
</ol>
<p>其他的配置使用默认的即可。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">初次运行 Git 前的配置</a></p>
</blockquote>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><blockquote>
<p><a href="https://www.jianshu.com/p/9fc1b6b354f8" target="_blank" rel="noopener">git reset 命令详解</a></p>
<p><a href="https://blog.csdn.net/longintchar/article/details/81843048" target="_blank" rel="noopener">git reset 命令详解（一）—— Git 学习笔记 07</a></p>
<p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-代码回滚：Reset、Checkout、Revert-的选择" target="_blank" rel="noopener">5.2 代码回滚：Reset、Checkout、Revert 的选择· geeeeeeeeek …</a></p>
</blockquote>
<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a><code>git reflog</code></h3><h2 id="命令场景"><a href="#命令场景" class="headerlink" title="命令场景"></a>命令场景</h2><h3 id="克隆指定分支"><a href="#克隆指定分支" class="headerlink" title="克隆指定分支"></a>克隆指定分支</h3><p><code>git clone -b branch_name repo_url</code></p>
<h3 id="克隆到指定目录"><a href="#克隆到指定目录" class="headerlink" title="克隆到指定目录"></a>克隆到指定目录</h3><p><code>git clone repo_url dir_path</code></p>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="恢复-git-reset-hard-的误操作"><a href="#恢复-git-reset-hard-的误操作" class="headerlink" title="恢复 git reset -hard 的误操作"></a>恢复 <code>git reset -hard</code> 的误操作</h3><blockquote>
<p><a href="https://www.cnblogs.com/mliudong/archive/2013/04/08/3007303.html" target="_blank" rel="noopener">恢复 git reset -hard 的误操作</a></p>
</blockquote>
<h4 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h4><p>Git 本地 Add、Commit 后没有 Push 到远程，然后 reset 到了某个版本，想要恢复到刚才到 Commit 版本。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>执行 <code>git reflog</code> 查看所有提交记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">00a3483b HEAD@&#123;1&#125;: reset: moving to 00a3483bd0bf4a53de63bcdd1a17b394a542618e</span><br><span class="line">c9b9d236 HEAD@&#123;2&#125;: commit: update</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>git reset c9b9d236</code> 恢复到上一次的提交</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Version Control</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Green wool monster</title>
    <url>/2019/03/17/Green-wool-monster/</url>
    <content><![CDATA[<img data-src="http://s3.sinaimg.cn/bmiddle/001LgE1rzy7aEyL9Z1ob2&690" width="100%"/>

<a id="more"></a>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>第一感觉是零碎的小说集，看到最后书的背面里归类就是中篇小说集，有点不过瘾，里面有好几个我很喜欢的小说太短了，看不够，比如说【绿毛水怪】【我在荒岛上迎接黎明】【地久天长】，尤其是【绿毛水怪】这一集，如果每一集都能写一本小说的话该多好。感觉应该是出版社为了出书，把这些拼凑起来出成一本书，也不能怪出版社了，可能原本就写的短，或者没能收集到全稿。总之是没能尽兴。</p>
<p>有几个小说写的是很离奇的故事，有的甚至像是惊悚的推理故事，读起来甚是可怕。【战福】里可怜的战福，【猫】里惊悚的瞎猫。还是温暖的故事读起来舒服。不禁想编者是否是害怕读者会有审美疲劳，故意把这些小说岔开了排版，让人的情绪起伏不定，不至于长时间保持某一个氛围里导致审美疲劳。</p>
<p>总的下来还是最喜欢写友谊地久天长的【地久天长】，可能是因为它是排在最后，刚读完印象比较深刻？其实是真的很喜欢这种完全写友谊类的小说，很让人羡慕的。爱情这个事情对于每个人而言都是可遇而不可求的事情，再就是经历过爱情的划痕的人很难再对爱情抱有希望，而友情相对于爱情就更显得可靠很多，它有它亲密的一边，又有它该有的距离，不会令人厌倦，又会带给人以温暖。拥有长久友谊的人总是格外的令我羡慕。</p>
<p>当然，美好的爱情故事也是很羡慕，应该说是憧憬吧，总觉得那么美好的事物可能并不会降临到并不怎么美好的自己身上一样。读【绿毛水怪】的前半段，陈辉和妖妖两小无猜的时候在一起干的种种趣事，很温暖，为没能最终在一起而惋惜，为海里礁石上的久别重逢而感动。</p>
<p>王小波真是个有趣的灵魂，他能将美好写的那么美好，真是件美好的事。每个读王小波作品的人应该都能从中获取一些温度吧。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li><p>我们爬上了窗户，踏着孙主任桌子上的书拔开了插销，跳下去，一直流出校门口没碰上人，可是心跳的厉害，真有一种做贼的甜蜜。</p>
</li>
<li><p>我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流上，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我说：“我们好像在池塘的水底。从一个月亮走向另一个月亮。”</p>
</li>
<li><p>有一天，西北来的狂风在大道上掀起滚滚的黄沙。风和路边的杨树在空中争夺树叶，金黄色的叶片像大雪一样飘落下来。</p>
</li>
<li><p>一切欢喜都不可能长久，只有不堪回首的记忆，才被人屡屡提起，难于忘怀。</p>
</li>
<li><p>可是人都是越活离死越近。</p>
</li>
<li><p>老陈推着小车站在东山上，心里想着：我们活着是为了谁？为了儿孙吗？要是过的和我一样，要他干什么？为了自己吗，是为了吃还是为了穿？只是为了将来还有希望。可是希望在哪儿呢？都把我们忘了。从农村出去的人也把我们忘了。我们要吃饱，我们想不要干这么使人的活。我们希望我们的老婆不要弄得像鬼一样。我们也要住在又卫生间的房子里头，我们也要一天有几个小时能听听音乐、看看小说。</p>
<p>这就是老陈，一个上辈子不是农民的农民的希望。</p>
</li>
<li><p>我背着书包，书包里放着一条绳子和一把小刀。我要到动物收购站取买一只猫来。当我把它的眼睛挖掉送上平台时，我就一切都明白了。</p>
<p>到那个时候，我才真正跨入人世。</p>
</li>
<li><p>人们所做的一切不过是死前的游戏……</p>
</li>
<li><p>如果我会发光，就不必害怕黑暗。如果我自己是那么美好，那么一切恐惧就可以烟消云散。于是我开始存下了一点希望——如果我能做到，那么我就战胜了寂寞的命运。</p>
</li>
<li><p>我的脑子总是在想那个渺茫的目标。我常常看到那个寂寞的大海。如果我停下来，那么就是寂寞，不如试下去。</p>
</li>
<li><p>我不希望人们知道我的名字，因为我的胜利是属于我的。</p>
</li>
<li><p>我用眼光问他，他艰难地说：“小红留下遗言，她把骨灰分留给家里和我们。这就是她。”</p>
</li>
<li><p>后来我和大许在一起过了两年，就分开了。我们把小红最后几封信分了。他要走了小红的遗骨，把她的箱子和衣物留给我。我们把小红留下的书分开，一人拿了一半，然后收拾好行装，反锁上房门。我们离开那里，走向新的生活。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Get Up Early</title>
    <url>/2020/02/24/Get-Up-Early/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Third warning: This content is personal, please skip it." data-whm="Fourth warning: This content is personal, please skip it."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Warning again: This content is personal, please skip it." /><label>Warning again: This content is personal, please skip it.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="40c3043d9bc7feae6e470206331123a0f13b28649a79308f3aeda13bada03e90">27e85e64ed1f3b7733f279ff1798cfd5ca234ca308c1332d7e89c60eb597d5cf8694d9490e0f740cc56da4341244c4e4356eb62cb379667e1fd95b37afb1a28c93e2ff5f5a3bce75b5a07a46775e602fd8f4b8c96e628e46c851425887255d313258a050671e3325b4cf7a82772a4887303b3c7cbfe0dc29f4cf29d74fb8e4cd166a28141be12ea335611a22fb319af7723c967f54b59b394c36433f31d634fd87b7ff161108bd2c9ff797e75b8d149902cedaf38743e71aa96f9fe60f681ba21b1c7cea09678a50dc477674cfb3247b0093be71fa6de11861ba206f5ab7e15cfbed1abce2bd37a63d7edfd608519c506dd079f19a06ef3e817fa369d21e62935b4aa44aa44eb7e5b8a62bd12c3de3e938434292af701b98e32a9f04d50a58a83f7892d802c75a8e0b7a92d0233a5e544397892a4fb3a965398fb8165a6f74b2570d90200e13cf5f695b4cdf1d87ea7c8be863cfb6a1f55b29a188ad7843856d0783910aa62a47a8e179a0092922fb61462d01e6ed7e874972395d98d3375dcd1585f2644ecd03c8d8b50fc1a7cb7bec057d20d9640f264348f74d96cdf4d90b1e65a6d4d47a0046e600d0ef0c0e4e69f324539b223fad7dbbe60fa69065240a36ea8b51320f92a96464239bf2b630b4d79b6018a2629c23718264dca60ad0d6a5c14d479ddc2145d33dee190d41b63858d4818fed29e57b64a8e1baae7684868d68f393aa7dd4757d94c1c8ea963a9df8fad224a058dab36ae343b9079a7a47ebfc747a884a00a7c4f0bede36fdd0ecb48bd668fa8775bbc4da4926edfa545760000058df5cff2e5e1c55e06c526889275f7380a06d8303e0a234f0ceb00f3d512cd3c95cffd9be14c9683f1905fd27b1eb13070aac418ad72803b886d9967222ec0c9903b0c29a3aedd3c91e6332bd94f063e9dd6b8a6dec33226103b45e3b80cd0c290044cb6eb3218dcd1fffc3ad801c8a24f65ee7cfd88c1510fff52295e99372e7335e082bebd6ea3841a07183cde8b1f3d3ddab6b4d185784e479116407f13cedbd7653c8ea2d43f42ecd4265aff98b011cc42a1b8ca4e4328b6ceb430f369f8f9cfb3b9a047cd549188253d776879a03a94c199f8522de8697e6e0ac46f61c5f81dfd24a6d08aac6385dd494b30cdcaf79753c818bbe209ff0b7492129dcf3a087fd729dc28b019c0a329040e814aa10fdcf5284b16d141a8e50a43e54eacbe2c82d28d92276b00f71b02b49c81a6045960f1111b333a7b2f32eb467b0a8ce77d61474ef48f85418f02f73b09177832b2c5df6ec93ea836e79bb887f50f80004c83a13b4c5c23144f3352b8a5a1b0f102428bcd38fbdba33ffca30194e2f21e967f6f9e444d12b27f88b4cee71bb967faa7bfd2d4ffdc3cede9bf50e083379e6a3abcb9fc44b8a0097d27a765efcec6141d99037247b485a70ab8abefa199232798bebc13d015d66454a1da6680293f497bde89d249ca2c4a80af5fc79bca8edd33192b20a6927d5b7eccc7e92dee68e7bf9d13b1736756b611f4b426c62a2a0f21f08513e3a0e122035b4dd7bc2605391869dd280aa02b8e96280361519531526411beb9c6e6dee8a677810f65a163294a6b7831656a993ec8fc5a8589970004c8963f3d8e2dbc32fee800ea72812b02c6117e411edf9fb75c081f814010f38ed095d932100b126fd2091a5a5dee6dc219c2c6bcbd0dfaf705ee567f81dbb2fd6a7f14dd75f2468fc409402a77210d85815a5eb13f41c582cd0b9e393e306b100c3eac6b1c9e5099242e6d784cb62dc2145e4ff7b503022bb3c3e101403ccb9810de58d792cf730bc57de5f58755e39436c0e4483170fea9e50f3b1b15962102a900560a28e260daa1c682d9bfbf8d0815b5492429df301778124ae27b70e6270160236a9f98b3438e06b7fd9e80d397656ecb116c6a71b8f8c2479ada935da279b4cc70241599c8bfc7dc7bb14ceb8619b012b1b93adb6cd59439e600c28d91a14edabf165ae94b11e506ccb54cd6f3a326bae0cc2db87c67026bbc010701ddab49706353234f399810b2c7152bdb22061e7befaa084d91f1b7cbf43bdcda577f1c2e7a8b22c69f7524b45951015b7d3fc4e28ce3a81582e0b37f46a5044a1cf7823ddcc499951b279044e68bf1cd05ff9e5559a96f0a65b71988b16c8bdacfdf851d98e5dcd711af7c3ee69834e0b1ec7bba4c7d531cd03050d9ebd9732521516dabfd7f53e3467d780cbb123e45c3e71194a54a1fe99aa0285fada0cbb3dc94c069d6cc63cf91e7a10e18b3954bffef173295acea1620ef2f29731d136322d2bb6622270ffd9ab2bef00ef50d511faed761e4ad57abd44d3277ad7c0409cd4f3f9c8d225b5ef3efbe0ca7c3a537cfa5b9d29af6be07191fb597678780b707126681db3a7a55b1b1af8bdb3343f271be31c6b5d18c2b0f7e5629d0a0c277bbfc38a88a51e49ec09d24e9dc556a1560d26cd229d621538cc1d23ee4edafb12dde2a5f01ab599958ac1d26601467dcba72139ff25ac797a42f151ce603435f883459b326adcc1622f23005ed5206738b7a6c284027a890b322b2a35a9ec5c24c4dfc33a2695417853a0173b9339ef03cb20e8a8c1c34a8a50cad77c97abdcc881def3f172028ac0cbe4f5426ba8a95abb1435dce74795753f19cb9d7822e91730f0470b7ef2e14da60cb300e3a3abe34ad64f3b937f12eb4477777f7557efc0cc5b4b67e0a22c2c054ce6c6ef3300eaa4160572eab0551b4a8e530c8b2362c2bd6c8e78504ba6603d7a1608891f5975356637b1a97a52246de5c58f63ab4ce8a6568ee6228cf03849e0336043a11407188d9159ec32860dd77dedf74e6c7d76d864ae65f20772edd0051351fd14b2ad8b536e1d87c5dd8c4e6996c1d6dd60dcda9b17f1101c0a15959d3427f97c6a6f3f7bc7054f368a65a99efca413828babb7ab0785d331d0a117aeed7ca47c6b0390efe6d85dde7aa0c794b5379458b09bbe62ab801cd2531299fd6940f3da24f8804fbb213c0f71f8f6928b9871d7caa66aa7840826272342ce50f156750b9d7dbed0b5dd3fccd2d349644ff7ca080ced60bde2eb4be6ef676b05b87407d80a4f4c7703c0a251072898c7cd64bbc384dc14c90814e59006dbeddd7586d2e5dc807994312142568171c811c348fae5dd31e710c15befd75c02ae270bb4a2d85cb627f5c7b0cd11fe14599f0b7a2754c2abd2c450676a2d15a6a7ebd3036f37bf8a61bc1121be2113ff1c85e133d10e2593cc51507ddd160eff81bae38a25df0a0a42684872041a6bf3d6747d5008a2f8d8fcc51ca87a73b32be244fb8c12173f294a385c861692fc7f5d57b48ef1c19f68bbbe4122f789a7d055cd9c47e3b9fe9f62935eeb9b7ae948999ddf3585af1c6beb62b876f9d4a0b95a34e36f26647f2f92f3013137404093711675bf911dd211f9c1933814c10d1383fd736f11c8bc824393066afd8c02e248bf4f8b7c71281f25bd21810ec211b95b1cf82d449526fc803df4f79eec760a8be660763b76bc096c41b045ac24d7cacc75af4ef9307a9fedc555801b441900076cd69da30f9cea27ad4e5f1b057817ccbe9cfd2bae4d80794a5139780afef14348280733c1dafe69c9d112963e639a85a40afa7514e4b2f87da8a08ffe77c9bd2bc8735dd48e8e45b4c177bd35da1a453e630074090fe6e0b3fd9f6c4abd41be118538fafbb561e8d945a239f044a0d7729810f53222460f630ebd056fa8a53ac919740491b5a411777a09ce55436920e4e2703c185c089c34c1803074fad6ed35229334d910b7adc28cccabde39e88876ce5971ebd95d8b41866909012318912b8618e6d56ff2da179a09091cd1b250f765c943b960df3c277d8489f83e2b9857d338e530930ccbb7f2242bf6c735bf50e318b76aee24f735a1f446f47174bca2dd01a59c19ca9018f53127bc1d20c02078d35428bcf0332f04db75ac1902f79b636b7c749ab513d912b7444edebaa53c86632107b95fff9c35efab704470b9edb8a403e3f6c806dd8ba18e5961c87187834cbce8c4a095da497eee0118cf9c8e05f9a87128dbe4b7c86d1ba5f26b418f0ef1d06e6b5c0e09e413959732c28cb19899bcf3db81703bd5eb7ac93ea93ac9abfdf10868e64a628b719f6c5d90adb9cee435869c33151531b74df79c2af0ed50357c502dbe7579091e72e773389968550c7973efd61c307dfba7f9fef798bb8346963add447fe7d99dc3133041453a6dbb525a7e7df37d26d1ae5cdee82efd6caec66652daed1ab0081e0f0f4d088a07bb</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
        <category>Good Habits</category>
        <category>Get Up Early</category>
      </categories>
  </entry>
  <entry>
    <title>How to Down Up a Plan</title>
    <url>/2019/01/02/How-to-Down-Up-a-Plan/</url>
    <content><![CDATA[<img data-src="http://www.thebluediamondgallery.com/handwriting/images/plan.jpg" width="100%"/>

<a id="more"></a>

<h2 id="为什么要制定计划"><a href="#为什么要制定计划" class="headerlink" title="为什么要制定计划"></a>为什么要制定计划</h2><blockquote>
<p><a href="https://study.163.com/topics/coursefinder40_m/" target="_blank" rel="noopener">这样制定计划 让你的效率翻倍</a></p>
<p><a href="https://www.douban.com/note/697771300/" target="_blank" rel="noopener">【人生规划局 VOL.02】构建你的计划与时间管理系统</a></p>
<p><a href="https://know.baidu.com/question/a2a81ea12bef6a0a7e4af6bb214c1f577f664fb" target="_blank" rel="noopener">计划没有变化快，为什么还要定计划？</a></p>
</blockquote>
<ul>
<li>清楚自己要做什么</li>
<li>清楚事情的进展情况</li>
<li>让自己的时间得以有效利用</li>
</ul>
<h2 id="计划的分类"><a href="#计划的分类" class="headerlink" title="计划的分类"></a>计划的分类</h2><p>主要分为两大类</p>
<ol>
<li><p>固定时间计划</p>
<p>如日计划，周计划，月计划……</p>
</li>
<li><p>关键事务计划</p>
<p>如项目计划等……</p>
</li>
</ol>
<h2 id="制定计划的原则"><a href="#制定计划的原则" class="headerlink" title="制定计划的原则"></a>制定计划的原则</h2><blockquote>
<p><a href="https://www.jianshu.com/p/2e2de41fea93" target="_blank" rel="noopener">[方法论] 如何设定目标，如何制定计划？</a></p>
</blockquote>
<p>SMART原则：</p>
<p><strong>Specific</strong>（具体的）</p>
<p><strong>Measurable</strong>（可度量的）</p>
<p><strong>Achievable</strong>（可实现的）</p>
<p><strong>Relevant</strong>（相关的）</p>
<p><strong>Time-bound</strong>（时间可控的）</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1Sxb8lLL4QSXOeNRYOZy7cA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Sxb8lLL4QSXOeNRYOZy7cA</a><br>提取码：x3w1 </p>
</blockquote>
<p><img data-src="https://i.loli.net/2019/01/08/5c345a0f38a05.jpg" alt=""></p>
<h2 id="制定计划的流程"><a href="#制定计划的流程" class="headerlink" title="制定计划的流程"></a>制定计划的流程</h2><ol>
<li>罗列要做的事情</li>
<li>确定重点事宜</li>
<li>分配时间</li>
</ol>
<h2 id="计划的检查与调整"><a href="#计划的检查与调整" class="headerlink" title="计划的检查与调整"></a>计划的检查与调整</h2><p>日计划一般中午和晚上各检查一次，周计划则1-2天检查一次</p>
<h2 id="为什么完不成计划"><a href="#为什么完不成计划" class="headerlink" title="为什么完不成计划"></a>为什么完不成计划</h2><blockquote>
<p><a href="https://www.xinli001.com/info/100356090" target="_blank" rel="noopener">你！为什么总是完不成计划！</a></p>
<p><a href="https://www.zhihu.com/question/50168355" target="_blank" rel="noopener">为什么制定的计划总是实现不了？</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>How to Discover Your Life Purpose in About 20 Minutes</title>
    <url>/2020/03/05/How-to-Discover-Your-Life-Purpose-in-About-20-Minutes/</url>
    <content><![CDATA[<img data-src="https://vernenciso.com/wp-content/uploads/2018/10/maxresdefault.jpg" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://www.stevepavlina.com/blog/2005/01/how-to-discover-your-life-purpose-in-about-20-minutes/" target="_blank" rel="noopener">How to Discover Your Life Purpose in About 20 Minutes | Steve Pavlina</a></p>
</blockquote>
<p>如何寻找你真正的人生目标？我不是在谈你的工作、责任抑或是长期目标。我想谈的是你为什么存在的真正原因——你存在的意义。</p>
<p>或许你是一个不相信人生目的或人生意义的极现实主义者。不过这不重要，不相信你有存在的意义，并不妨碍你找到它，就像苹果不相信万有引力，但还是会自然下落一样。不相信只会让拉长寻找的进程，所以，如果你是这样的人，那把标题的20分钟拉长到40分钟(或者60分钟，如果你真的特别固执的话)。最坏情况是不管我说什么你都不相信你有存在的意义，及时这样，花费这一个小时对你能有多大损失，万一你真的找到了呢？</p>
<p>李小龙的一个故事能为这个练习做个小小的铺垫。一个武术大师请李小龙把自己知道的所有功夫都教给他。李小龙端起两杯盛满水的杯子说道，这个杯里的水是你所知道的功夫，另一杯里的是我所知道的，如果你想要我全部的功夫，那你得先把你那杯倒了。</p>
<p>如果你想寻找你真正的人生意义，你首先要做的事情是先放空你的大脑，清空所有外界灌输给你的认知(包括你不相信你有存在的意义这一点)。</p>
<p>那么如何找到你的人生目标呢？虽然有很多方法都可以做到，但有些方法非常繁杂，我所介绍的方法任何人都可以轻易的做到。你对这个过程越开放，越期望它起作用，它对你的起效就越快。再重申一遍，即使你不抱有开放的心态，或者不相信，甚至认为这完全就是愚蠢地在浪费时间，毫无意义可言，只要你坚持完成，那对你有所作用，只是所花费的时间更多些而已。</p>
<p>下面教具体你怎么做：</p>
<ol>
<li>拿一张白纸或者用 Word 新建一个空白文档(我更喜欢后者，因为它更快)。</li>
<li>在最上面写上“我人生的真正目标是什么？”</li>
<li>写下一个头脑突然蹦出的答案(任何答案)，不必是完整的句子，简短的词语也可以。</li>
<li>重复第三步，直到写出能让你哭出来的答案为止，这就是你的人生目标。</li>
</ol>
<p>就是这样。不管你是顾问、工程师还是健美运动员。对一些人来说，这个练习非常有意义，对其他人来说，这可能看起来非常愚蠢。通常情况下，需要大概15～20分钟的时间理清你头脑里那些杂七杂八的东西和你认为的人生目标是什么的社会条件。从头脑和记忆中来的答案都是错误的，当正确答案最终来的时候，你会感觉它是从一个完全不同的地方来的。</p>
<p>对于那些深陷低意识生活的人来说，会花费更多的时间把所有错误答案写完，可能得一个多小时。不过只要你坚持，写完100个或者200个甚至是500个之后，你会被那个让你激动不已的答案所打动，那个让你崩溃的答案。如果你从未这样做过，你可能会觉得很傻。傻就傻吧，无论如何都要去做。</p>
<p>在你写的过程中，可能某些答案会非常相似。你甚至可能列出以前写过的答案。也可能在切到一个新的话题后写出10-20个答案。没关系，你可以列出你脑海中出现的任何答案，接着写就好了。</p>
<p>在这个过程中的某个时刻(通常在50-100个答案之后)，你可能想要退出，因为思维太发散了。你可能会有起身找借口做其他事情的冲动。这很正常。克服这种阻力，继续写，抗拒的感觉最终会过去的。</p>
<p>你可能会找到一些让你情绪短暂激动但又没到让你哭出来的程度的答案，这些答案只是有一点点跑题了，遇到这些答案的时候立马圈出它们，这样之后可以快速回到这里，然后从这里继续延伸。它们每个都只是你人生目标的一部分，单个来说并不完整。当你写下这些答案的时候表明你已经开始变得热情了，Keep going！</p>
<p>连续地、不间断地进行这个过程是十分关键的。如果你是一个空想家，则可以从“我没有目标”或者“生活没有意义”的答案开始，然后写下心的答案，就这样坚持下去，最终一定可以找到那个答案的！</p>
<p>我用了大概 25 分钟完成的这个练习，终极答案是第 106 个。有小触动的答案出现在第 17、39 和 第53 个，然后在第 100-106 的时候开始渐渐清晰并重新定义了终极答案。大概在写到第 55-60 个答案的时候出现了一些抗拒感和抵触情绪(想要站起来做点别的事情、希望这个过程失败、心绪很不耐烦甚至有点烦躁)。写到第 80 个时，我休息了 2 分钟，闭上眼睛，放松放松，清理了下我的大脑，专注于我下面要写答案，这很有帮助，因为我的终极答案在这个休息之后开始有了更大的清晰度。</p>
<p>这是我的终极答案：</p>
<ul>
<li>有意识地勇敢的生活</li>
<li>与爱和同情产生共鸣</li>
<li>唤起他人内在的伟大精神</li>
<li>与这个世界和平相处</li>
</ul>
<p>当你找到独属于你自己的答案时，你会觉得它与你产生了深刻的共鸣。这些词语似乎能给你带来特殊的能量，无论什么时候读到它们，你都能感受到那份能量。</p>
<p>找到目标并不是最难的，难的是日常生活中牢记它，并朝着这个目标不断努力。</p>
<p>如果你想知道为什么这个小练习有用，那就先把这个问题放到一边，直到你成功完成了再说。一旦你完成了，你可能就知道了它为什么有效了。每个人有每个人自己的答案，因为每个人都有自己的信仰和自己对真理的思索。</p>
<p>显然，如果你中途停下了那肯定找不到人生目标。我猜大概80-90%的人应该用不了一个小时就能完成。如果你真的十分固执己见，抵触这种过程，可能要做5组，花上3个小时左右，但我怀疑这样的人会早早的就放弃了(比如坚持不到15分钟)，甚至根本不会去尝试。不过如果你被这篇博文所吸引(而且并没有想把它从你的生活中屏蔽掉)，那你是不是这种人就很值得怀疑了。</p>
<p>试一试！至少你能了解到以下两点之一：你真正的人生目标——或者——你应该退订此博客。 😉</p>
]]></content>
  </entry>
  <entry>
    <title>GitHub Pages+Hexo+NexT</title>
    <url>/2025/07/22/GitHub%20Pages+Hexo+NexT/</url>
    <content><![CDATA[<blockquote>
<p>环境：</p>
<p>node.js    10.14.2</p>
<p>npm     6.4.1</p>
<p>hexo    3.8.0</p>
<p>NexT    6.6.0</p>
</blockquote>
<a id="more"></a>

<h1 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h1><blockquote>
<p><a href="http://moxfive.xyz/2015/12/21/common-hexo-commands/" target="_blank" rel="noopener">Hexo 最常用的几个命令</a></p>
<p><a href="http://tietang.wang/2016/02/21/%E6%8A%80%E6%9C%AF/Hexo/Hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E8%AE%B0/" target="_blank" rel="noopener">Hexo命令速记</a></p>
</blockquote>
<p><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -s</code></p>
<h1 id="NexT-主题的使用"><a href="#NexT-主题的使用" class="headerlink" title="NexT 主题的使用"></a>NexT 主题的使用</h1><blockquote>
<p><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a></p>
<p><a href="https://theme-next.org/" target="_blank" rel="noopener">Theme NexT</a></p>
</blockquote>
<p>推荐新入坑的兄弟使用<a href="https://theme-next.org/docs/getting-started/installation/#download-next-3" target="_blank" rel="noopener">第一种方式</a>来获取NexT主题。</p>
<h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p><a href="https://theme-next.org/docs/getting-started/data-files/" target="_blank" rel="noopener">Data Files</a></p>
<p>为了以后平滑升级，使用Hexo3.0的Data Files方式</p>
<h3 id="NexT-Way"><a href="#NexT-Way" class="headerlink" title="NexT-Way"></a><a href="https://theme-next.org/docs/getting-started/data-files/#option-2" target="_blank" rel="noopener">NexT-Way</a></h3><ol>
<li>在<code>hexo/source/_data</code>目录（没有的话新建一个）下新建<code>next.yml</code>文件。</li>
<li>把<strong>主题配置文件</strong>中的选项全部 copy 到<code>next.yml</code>中。</li>
<li>在<code>next.yml</code>文件中设置<code>override</code>选项为<code>true</code>。</li>
<li>在<strong>站点配置文件</strong>中修改<code>theme</code>选项为<code>next</code></li>
</ol>
<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><blockquote>
<p><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用</a></p>
</blockquote>
<h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h2><h3 id="头像旋转"><a href="#头像旋转" class="headerlink" title="头像旋转"></a>头像旋转</h3><blockquote>
<p><a href="http://www.iooeo.com/2017/07/20/Hexo-Next-%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E5%B9%B6%E6%97%8B%E8%BD%AC/" target="_blank" rel="noopener">Hexo Next 头像圆形并旋转</a></p>
</blockquote>
<p>注意<a href="https://www.zhangxinxu.com/jq/stylus/comments.php" target="_blank" rel="noopener">stylus中文版参考文档之注释(Comments)</a></p>
<p>单行注释使用<code>//</code>,多行使用<code>/* */</code></p>
<p>修改<code>/themes/next/source/css/_common/components/sidebar/sidebar-author.styl</code>如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$site</span>-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="variable">$site</span>-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$site</span>-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$site</span>-author-image-border-width solid <span class="variable">$site</span>-author-image-border-color;</span><br><span class="line">  <span class="attribute">opacity</span>: hexo-config(<span class="string">'avatar.opacity'</span>) is a <span class="string">'unit'</span> ? hexo-config(<span class="string">'avatar.opacity'</span>) : <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 头像圆形样式</span></span><br><span class="line">  <span class="comment">/* start */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">  webkit-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  moz-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  ms-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">'avatar.rounded'</span>) &#123;</span><br><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">'avatar.rotated'</span>) &#123;</span><br><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  -moz-<span class="attribute">transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  -ms-<span class="attribute">transition</span>: -ms-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: rotateZ(<span class="number">360deg</span>);</span><br><span class="line">  -moz-<span class="attribute">transform</span>: rotateZ(<span class="number">360deg</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotateZ(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-name</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="variable">$site</span>-author-name-margin;</span><br><span class="line">  <span class="attribute">text-align</span>: <span class="variable">$site</span>-author-name-align;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$site</span>-author-name-color;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="variable">$site</span>-author-name-weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-description</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="variable">$site</span>-description-margin-top;</span><br><span class="line">  <span class="attribute">text-align</span>: <span class="variable">$site</span>-description-align;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$site</span>-description-font-size;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$site</span>-description-color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头像旋转事件</span></span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  webkit-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  moz-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  ms-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure>

<h3 id="文章底部带-号的标签"><a href="#文章底部带-号的标签" class="headerlink" title="文章底部带#号的标签"></a>文章底部带#号的标签</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_32454537/article/details/79482896#t11" target="_blank" rel="noopener">文章底部带#号的标签</a></p>
</blockquote>
<p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_32454537/article/details/79482896#t12" target="_blank" rel="noopener">在每篇文章末尾统一添加“本文结束</a></p>
</blockquote>
<ol>
<li>在路径<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件,并添加以下内容：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span>-------------本文结束<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>END POST BLOCK</code>之后， 添加以下代码：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	&#123;% if not is_index %&#125;</span><br><span class="line">		&#123;% include 'passage-end-tag.swig' %&#125;</span><br><span class="line">	&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开<strong>主题配置文件</strong><code>next.yml</code>,在末尾添加：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="主页文章加阴影"><a href="#主页文章加阴影" class="headerlink" title="主页文章加阴影"></a>主页文章加阴影</h3><blockquote>
<p> <a href="https://blog.csdn.net/qq_32454537/article/details/79482896#t14" target="_blank" rel="noopener">主页文章加阴影</a></p>
</blockquote>
<p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line"><span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示文章更新时间"><a href="#显示文章更新时间" class="headerlink" title="显示文章更新时间"></a>显示文章更新时间</h3><p>修改<strong>主题配置文件</strong>的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>要想具体显示到时分秒,则修改<strong>站点配置文件</strong>的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure>

<h3 id="代码添加复制按钮"><a href="#代码添加复制按钮" class="headerlink" title="代码添加复制按钮"></a>代码添加复制按钮</h3><blockquote>
<p><a href="http://www.missfli.com/2018/06/19/github-hexo-next-08.html" target="_blank" rel="noopener">Hexo NexT主题代码块添加复制功能</a></p>
</blockquote>
<ol>
<li><p><a href="https://clipboardjs.com/" target="_blank" rel="noopener">下载</a><code>clipboard.js</code></p>
</li>
<li><p>保存文件<code>clipboard.min.js</code> 到目录<code>\themes\next\source\js\src</code></p>
</li>
<li><p>在<code>.\themes\next\source\js\src</code>目录下，创建<code>clipboard-use.js</code>，文件内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123; </span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'  &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>.\themes\next\source\css\_custom\custom.styl</code>样式文件中添加下面代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码块复制按钮</span></span><br><span class="line">.highlight&#123;</span><br><span class="line">  <span class="comment">//方便copy代码按钮（btn-copy）的定位</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: linear-gradient(<span class="number">#fcfcfc</span>,<span class="number">#eee</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    -webkit-user-select: <span class="attribute">none</span>;</span><br><span class="line">    -moz-user-select: <span class="attribute">none</span>;</span><br><span class="line">    -ms-user-select: <span class="attribute">none</span>;</span><br><span class="line">    user-select: <span class="attribute">none</span>;</span><br><span class="line">    -webkit-appearance: <span class="attribute">none</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    -webkit-transition: opacity .3s ease-in-out;</span><br><span class="line">    -o-transition: opacity .3s ease-in-out;</span><br><span class="line">    transition: opacity .3s ease-in-out;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span>:hover .btn-copy&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>.\themes\next\layout\_layout.swig</code>文件中，添加引用（注：在 swig 末尾或 body 结束标签（<code>&lt;/body&gt;</code>）之前添加）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;  </span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" src="</span>/js/src/clipboard-use.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h3><blockquote>
<p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">hexo-blog-encrypt</a></p>
</blockquote>
<ol>
<li><p><code>npm install --save hexo-blog-encrypt</code></p>
</li>
<li><p>在<strong>站点配置文件</strong>下添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要加密的文章的头部添加上对应的字段，如 password, abstract, message</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">Mike</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">Welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">blog,</span> <span class="string">enter</span> <span class="string">password</span> <span class="string">to</span> <span class="string">read.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">Welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">blog,</span> <span class="string">enter</span> <span class="string">password</span> <span class="string">to</span> <span class="string">read.</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二次元看板娘"><a href="#二次元看板娘" class="headerlink" title="二次元看板娘"></a>二次元看板娘</h3><blockquote>
<p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">hexo-helper-live2d</a></p>
</blockquote>
<ol>
<li><p><code>npm install --save hexo-helper-live2d</code></p>
</li>
<li><p><code>npm install --save live2d-widget-model-wanko</code></p>
</li>
<li><p>向<strong>站点配置文件</strong>中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>注：在<code>next.yml</code>中配置时，<code>width, height</code>等参数不起作用。</p>
</li>
</ol>
<h3 id="加载条"><a href="#加载条" class="headerlink" title="加载条"></a>加载条</h3><blockquote>
<p><a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">Load bar at the top for NexT</a></p>
</blockquote>
<ol>
<li>将<code>theme-next-pace</code>克隆到本地一个空目录里。</li>
<li>删掉<code>pace</code>目录下的<code>.git</code>文件夹</li>
<li>将<code>pace</code>目录 copy 到<code>themes/next/source/lib</code>目录下</li>
<li>修改<strong>主题配置文件</strong><code>next.yml</code>的<code>pace</code>属性值为<code>true</code></li>
</ol>
<h3 id="显示文章浏览进度百分比"><a href="#显示文章浏览进度百分比" class="headerlink" title="显示文章浏览进度百分比"></a>显示文章浏览进度百分比</h3><p>在<strong>主题配置文件</strong>中修改属性<code>sidebar</code>下<code>scrollpercent</code>的值为<code>true</code></p>
<h3 id="文章预览"><a href="#文章预览" class="headerlink" title="文章预览"></a>文章预览</h3><p>在文章中使用截断标记<code>&lt;!-- more --&gt;</code>手动指定文章预览的内容。</p>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><h4 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h4><blockquote>
<p><a href="https://github.com/gitalk/gitalk/wiki/%E5%9C%A8hexo-next%E4%B8%BB%E9%A2%98%E4%B8%8A%E4%BD%BF%E7%94%A8gitalk" target="_blank" rel="noopener">在hexo next主题上使用gitalk</a></p>
<p><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">Hexo NexT主题中集成gitalk评论系统</a></p>
</blockquote>
<ol>
<li><p>Click here to sign up for a <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">new OAuth Application</a></p>
<p>Application name： # 应用名称，随意，如<code>gitalk</code><br>Homepage URL： # 网站URL，如<code>https://username.github.io</code>,<code>username</code>是 GitHub 账户名<br>Application description # 描述，随意，如<code>Comment System for Blog</code><br>Authorization callback URL：# 网站URL，<code>https://username.github.io</code>,<code>username</code>是 GitHub 账户名</p>
</li>
<li><p>修改<strong>主题配置文件</strong>中的如下属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk </span></span><br><span class="line"><span class="comment"># Demo: https://gitalk.github.io</span></span><br><span class="line"><span class="comment"># Reference: https://asdfv1929.github.io/2018/01/20/gitalk/, https://liujunzhou.cn/2018/8/10/gitalk-error/#more</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">username</span> <span class="comment"># Github repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">gitalk</span> <span class="comment"># Repository name to store issues.</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">******</span> <span class="comment"># Github Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">******</span> <span class="comment"># Github Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">gzhennaxia</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize github issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h4><blockquote>
<p><a href="https://theme-next.org/docs/third-party-services/comments-and-widgets/#Valine" target="_blank" rel="noopener">Comment Systems Valine</a></p>
</blockquote>
<ol>
<li><p>Create an account or log into <a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud</a>, and then click on the bottom left corner to <a href="https://leancloud.cn/dashboard/applist.html#/newapp" target="_blank" rel="noopener">create the application</a> in <a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">dashboard</a>.</p>
</li>
<li><p>Go to the application you just created, select <code>Settings -&gt; Apply Key</code> in the lower left corner, and you will see your <code>APP ID</code> and <code>APP Key</code>.</p>
</li>
<li><p>Set the value <code>enable</code> to <code>true</code>, add the obtained APP ID (<code>appid</code>) and APP Key (<code>appkey</code>), and edit other configurations in <code>valine</code> section in the theme config file as following:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">******</span> <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">******</span> <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Gitalk-Valine双评论系统"><a href="#Gitalk-Valine双评论系统" class="headerlink" title="Gitalk + Valine双评论系统"></a>Gitalk + Valine双评论系统</h4><p>在完成各自配置后对<code>themes\next\layout\_partials\comments.swig</code>做如下修改：</p>
<p><strong>Before</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comments"</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>After</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	&#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comments"</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><blockquote>
<p><a href="https://theme-next.org/docs/getting-started/deployment/#Continuous-Integration" target="_blank" rel="noopener">Continuous Integration</a></p>
</blockquote>
<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="npm-install-warnings"><a href="#npm-install-warnings" class="headerlink" title="npm install warnings"></a>npm install warnings</h2><blockquote>
<p><a href="https://github.com/Zulko/eagle.js/issues/35" target="_blank" rel="noopener">npm install warnings</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules/hexo-cli/node_modules/fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"linux","arch":"x64"&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>忽略就好</p>
<h2 id="Hexo-g-error"><a href="#Hexo-g-error" class="headerlink" title="Hexo g error"></a>Hexo g error</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR ENOENT: no such file or directory, open 'F:\Hexo\themes\next\layout\menu.swig'</span><br><span class="line">Error: ENOENT: no such file or directory, open 'F:\Hexo\themes\next\layout\menu.swig'</span><br><span class="line">    at Object.openSync (fs.js:439:3)</span><br><span class="line">    at Object.readFileSync (fs.js:344:35)</span><br><span class="line">    at Object.ret.load (F:\Hexo\node_modules\swig-templates\lib\loaders\filesystem.js:59:15)</span><br><span class="line">    at exports.Swig.compileFile (F:\Hexo\node_modules\swig-templates\lib\swig.js:740:31)</span><br><span class="line">    at Object.eval [as tpl] (eval at precompile (F:\Hexo\node_modules\swig-templates\lib\swig.js:537:13), &lt;anonymous&gt;:7:18)</span><br><span class="line">    at compiled (F:\Hexo\node_modules\swig-templates\lib\swig.js:664:18)</span><br><span class="line">    at Theme._View.View._compiled.locals [as _compiled] (F:\Hexo\node_modules\hexo\lib\theme\view.js:125:48)</span><br><span class="line">    at Theme._View.View.View.render (F:\Hexo\node_modules\hexo\lib\theme\view.js:30:15)</span><br><span class="line">    at route.set (F:\Hexo\node_modules\hexo\lib\hexo\index.js:394:29)</span><br><span class="line">    at tryCatcher (F:\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at F:\Hexo\node_modules\bluebird\js\release\method.js:15:34</span><br><span class="line">    at RouteStream._read (F:\Hexo\node_modules\hexo\lib\hexo\router.js:134:3)</span><br><span class="line">    at RouteStream.Readable.read (_stream_readable.js:452:10)</span><br><span class="line">    at resume_ (_stream_readable.js:899:12)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:63:19)</span><br></pre></td></tr></table></figure>

<h3 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h3><p>从<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v6.6.0" target="_blank" rel="noopener">releases</a>下载的 NexT 主题，然后再通过修改目录名为<code>next</code>的方式使用该主题的时候，生成文件的时候报的错。</p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><p>未知</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/28826000" target="_blank" rel="noopener">Wget for windows——优雅地实现批量下载</a></p>
</blockquote>
<p>换用<a href="https://theme-next.org/docs/getting-started/installation/#download-next-3" target="_blank" rel="noopener">命令行</a>下载的方式就不会报这个错了。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>GuiZhou-Weekend-Tour</title>
    <url>/2024/08/18/GuiZhou-Weekend-Tour/</url>
    <content><![CDATA[<img data-src="https://p1.itc.cn/q_70/images03/20210206/32d3497d12824b12a6c5845e2a891530.jpeg" width="100%"/>

<a id="more"></a>

<iframe  width='100%' height='700' frameBorder='0' src='https://libo9527.github.io/static/map/amap/20240822/all/index.html'>
</iframe>

<h2 id="景点分布"><a href="#景点分布" class="headerlink" title="景点分布"></a>景点分布</h2><p><img data-src="https://github.com/Gzhennaxia/picx-images-hosting/raw/master/image-20240818145134569.5xak68894l.webp" alt=""></p>
<h2 id="梵净山"><a href="#梵净山" class="headerlink" title="梵净山"></a>梵净山</h2><p><img data-src="https://github.com/Gzhennaxia/picx-images-hosting/raw/master/image.26les5wkku.webp" alt="image-20240823152825934"></p>
<p>13点后禁止徒步上山，<strong>15点后禁止徒步下山，必须坐缆车</strong>。</p>
<h2 id="肇兴侗寨"><a href="#肇兴侗寨" class="headerlink" title="肇兴侗寨"></a>肇兴侗寨</h2><blockquote>
<p><a href="https://www.720yun.com/t/5yz6nzw7n4u2mee9uw?pano_id=XUGCuzInuYSsuAmi" target="_blank" rel="noopener">全景</a></p>
</blockquote>
<p><img data-src="https://github.com/Gzhennaxia/picx-images-hosting/raw/master/image-20240825195022628.1023moyt95.webp" alt="image-20240825195022628"></p>
<h2 id="黄果树瀑布"><a href="#黄果树瀑布" class="headerlink" title="黄果树瀑布"></a>黄果树瀑布</h2><blockquote>
<p>黄果树景区AR导览小程序</p>
</blockquote>
<p>分为三大景区：大瀑布、天星桥、陡坡塘</p>
<ul>
<li><p>大瀑布最壮观；</p>
<ul>
<li>去大瀑布景区有个大扶梯：双程50r，单程30r，扶梯去程是下坡，返程是上坡，坐扶梯会错失观景台，建议购买返程单程票</li>
</ul>
</li>
<li><p>天星桥分为上半程和下半程，只有下半程的银坠链瀑布值得看；</p>
<ul>
<li>在天星桥景区有索道：10r，下半程出来可以坐索道</li>
</ul>
</li>
<li><p>陡坡塘是86版西游记的取景地；</p>
</li>
</ul>
<p>步行下—盆景园—第一观瀑台—第二观瀑台，仰观大瀑布—水帘洞，内观大瀑布—第三观景台，俯瞰大瀑布—扶梯上</p>
<p>我想去的景点</p>
<ol>
<li>黄果树瀑布</li>
<li>梵净山</li>
<li>赤水丹霞</li>
<li>荔波小七孔</li>
<li>西江千户苗寨</li>
<li>织金洞</li>
</ol>
<ol>
<li>黄果树</li>
</ol>
<h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="深圳-贵州"><a href="#深圳-贵州" class="headerlink" title="深圳-贵州"></a>深圳-贵州</h3><p>机票：往返预计 1200</p>
<p>高铁：444.5    4.5h</p>
<h3 id="西安-贵州"><a href="#西安-贵州" class="headerlink" title="西安-贵州"></a>西安-贵州</h3><p>机票：往返预计 1000</p>
<p>高铁：560    7~8h</p>
<h2 id="预算"><a href="#预算" class="headerlink" title="预算"></a>预算</h2><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>金额</th>
<th>李博</th>
<th>谭文晗</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>西安往返贵阳机票</td>
<td>机票</td>
<td></td>
<td></td>
<td>1000</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>高铁</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>黄果树门票（含观光车）</td>
<td>门票</td>
<td>210/人</td>
<td>210</td>
<td>210</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>酒店</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>租车</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="行李"><a href="#行李" class="headerlink" title="行李"></a>行李</h2><ol>
<li>纸巾</li>
<li>身份证</li>
<li>花露水</li>
<li>防晒霜</li>
<li>泳衣、拖鞋</li>
<li>小程序“在盐田”网上预约办理边防证，到中英街现场在自动打印机上就可以打处边防证，免得排队。</li>
<li>水+功能饮料+冰冻</li>
<li>硬币，存储柜用</li>
<li>毛巾、换洗衣物</li>
<li>一次性雨衣</li>
</ol>
<h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><table>
<thead>
<tr>
<th>日期</th>
<th>时间</th>
<th>相关人</th>
<th>地点/事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>2024-08-29</td>
<td>20:35</td>
<td>李博</td>
<td>深圳站</td>
<td>C8046 深圳站-广州白云站 20:35~22:26 历时 1h51m</td>
</tr>
<tr>
<td>2024-08-29</td>
<td>22:26</td>
<td>李博</td>
<td>广州白云站</td>
<td>C8046 深圳站-广州白云站 20:35~22:26 历时 1h51m</td>
</tr>
<tr>
<td>2024-08-29</td>
<td>22:54</td>
<td>李博</td>
<td>广州白云站</td>
<td>K192 广州白云站-铜仁站 22:54~09:57 历时 11h3m</td>
</tr>
<tr>
<td>2024-08-30</td>
<td>09:57</td>
<td>李博</td>
<td>铜仁站</td>
<td>K192 广州白云站-铜仁站 22:54~09:57 历时 11h3m</td>
</tr>
<tr>
<td></td>
<td>10:10</td>
<td></td>
<td>寄存行李</td>
<td></td>
</tr>
</tbody></table>
<p>2024-08-29 星期四 C8046 深圳站-广州白云站 20:35~22:26 历时 1h51m</p>
<p>K192 广州白云站-铜仁站 22:54~09:57 历时 11h3m</p>
<p>铜仁站出口黑色七座梵净山景区直通车，35，1小时到东门。没找到就去对面铜仁旅游客运站，35，1.5h到东门</p>
<p><img data-src="C:%5CBELLE%5Cimages%5Cimage-20240824155147937.png" alt="image-20240824155147937"></p>
<p>G2983 铜仁-贵阳东站 19:15~21:00</p>
<p>2024-09-03 G2925 贵阳北站-深圳北站 18:52~23:25</p>
]]></content>
  </entry>
  <entry>
    <title>Interview Experence</title>
    <url>/2020/11/10/Interview-Experence/</url>
    <content><![CDATA[<img data-src="https://quanminyingyu.com/ueditor/image/20190311/1552300547637720.png" width="100%"/>

<a id="more"></a>

<h2 id="深圳市智学云科技"><a href="#深圳市智学云科技" class="headerlink" title="深圳市智学云科技"></a>深圳市智学云科技</h2><blockquote>
<p>2020-11-12 10:30 ~ </p>
<p>Java 开发工程师，18～35k</p>
<p>深圳南山区深圳湾科技生态园9栋B5座719-720</p>
<p>Gzhennaxia.github.io/source/post_image/WechatIMG29.jpeg</p>
<p>Gzhennaxia.github.io/source/post_image/WechatIMG30.jpeg</p>
<p><a href="https://www.tianyancha.com/company/2981146416" target="_blank" rel="noopener">深圳市知学云科技有限公司 | 天眼查</a></p>
<p>网址：<a href="http://www.zhixuey.com" target="_blank" rel="noopener">www.zhixuey.com</a><br>简介：知学云科技是互联网教育和培训领域的先行者，也是组织云学习的领导者。知学云科技基于强大的互联网和移动互联网学习平台，通过贴心的运营和咨询服务，帮助组织和企业建立专属的网络学院。支持和推动组织和企业互联网时代的学习变革，实现组织和企业学习的规模化、敏捷化和个性化。</p>
</blockquote>
<h3 id="任职要求"><a href="#任职要求" class="headerlink" title="任职要求"></a>任职要求</h3><ul>
<li>本科以上学历，3 年以上不间断 Java/JavaEE 实际开发经验；</li>
<li>良好的 Java 编程基础，有实际多线程开发及并发控制经验者优先考虑；</li>
<li>熟悉 RabbitMQ 等消息中间件，有 Dubbo+Zookeeper 微服务开发经验者优先考虑；</li>
<li>熟练使用 javascript，熟练使用 jQuery、Nodejs、Requirejs、Angular.js，有 Vue.js 使用经验者优先考虑；</li>
<li>熟悉流行的开源框架，如 Spring，SpringMVC，IBatis/MyBatis，Hibernate/JOOQ等，阅读过源码者优先考虑。</li>
</ul>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote>
<p>录音笔11月12日_4.aac</p>
</blockquote>
<ol>
<li>00:02 正常是两轮技术面，你先自我介绍一下</li>
<li>00:55 离职原因？</li>
<li>02:04 之前的项目有没有用户量比较大的？</li>
<li>03:45 自动装箱/拆箱是在编译阶段还是运行阶段完成的？</li>
<li>04:00 方法的参数值传递还是引用传递？</li>
<li>04:55 父类可不可以转型为子类？</li>
<li>05:22 Java 的多太体现在哪些方面？</li>
<li>05:56 往 HashMap 里放 1000 条数据，怎么优化它的性能？</li>
<li>07:32 已知要放 1000 条数据，怎么计算要设置的初始化容量？</li>
<li>09:18 超市打折场景，有各种折扣，用哪种设计模式计算最终的价格比较合适？</li>
<li>11:53 过滤器和拦截器的区别是什么？</li>
<li>12:23 @Autowaire 和 @Resource 有什么区别？@Autowaire 放在成员变量上和放在set方法上的区别是什么？</li>
<li>13:43 AOP的实现是动态代理，动态代理的JDK和CGLIB在性能上的区别是什么？</li>
<li>14:38 spring 中实现动态数据源要怎么做？</li>
<li>15:38 mysql 的执行计划，你平时关注的是哪些字段？</li>
<li>16:03 怎么判别使用的索引是不是最优索引？</li>
<li>17:05 主键索引和非主键索引的区别是什么？回表是什么？</li>
<li>18:40 什么场景会引发缓存穿透，怎么预防？</li>
<li>20:04 之前的工作中碰到的最难的地方，最有成就感的地方是什么？</li>
</ol>
<h2 id="珍爱网"><a href="#珍爱网" class="headerlink" title="珍爱网"></a>珍爱网</h2><blockquote>
<p>2020-11-13 14:00 ~ 15:40（1h40m）</p>
<p>广东省深圳市南山区兴海大道3040号前海世茂大厦36楼</p>
<p>Gzhennaxia.github.io/source/post_image/WechatIMG33.jpeg</p>
</blockquote>
<h3 id="任职资格"><a href="#任职资格" class="headerlink" title="任职资格"></a>任职资格</h3><ol>
<li>本科及以上学历，计算机相关专业，2-3年及以上Java开发经验；</li>
<li>扎实的Java基础知识，理解IO、多线程、集合等基础框架，对JVM原理有一定的了解；</li>
<li>熟悉分布式系统的设计和应用，了解分布式、缓存、消息等机制，能合理应用分布式技术解决问题；</li>
<li>熟练掌握SpringBoot、dubbo、redis、kafka等技术；</li>
<li>掌握多线程及高性能的设计编码与性能调优，有高并发应用开发经验优先；</li>
<li>有较强的逻辑思维能力与沟通协作能力；</li>
<li>积极主动，喜欢研究及尝试新技术，追求编写优雅的代码。</li>
</ol>
<h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><blockquote>
<p>2020-11-13 14:00 ~ 14:55（55m）</p>
<p>手机标准录音1.mp3</p>
</blockquote>
<ol>
<li>01:04 简单的自我介绍</li>
<li>02:15 离职原因</li>
<li>03:16 公司规模多大</li>
<li>04:37 你对前端的了解有多少？你能自己搭建一套前端的项目框架吗？</li>
<li>05:40 你是怎么看待前后端分离这个概念的？</li>
<li>06:33 从技术上来说，前后端分离的一些好处？</li>
<li>07:19 电商平台这个项目做了多久？</li>
<li>07:56 通过 Jenkins 发布的时候是单独发布某一个模块还是发布整个项目？</li>
<li>08:29 Jenkins 原理？脚本是怎么写的？</li>
<li>09:06 用 Docker 的好处是什么？</li>
<li>09:33 启动/停止容器的命令是什么？</li>
<li>09:49 怎么把你的项目装载到 Docker 容器里面？装的过程中要注意一些什么事情？</li>
<li>10:54 大概介绍下 CD 项目是怎么用的微服务架构？</li>
<li>12:17 你个人对微服务框架是怎么理解的？采用微服务框架的依据是什么？</li>
<li>13:56 微服务的弊端是什么？</li>
<li>15:37 TCP 和 UDP 包的头部分别是多少个字节？</li>
<li>16:08 TCP 和 UDP 的区别？</li>
<li>17:11 TCP 建立连接的过程？画一下！</li>
<li>21:18 有没有了解过 TCP 拆包，黏包的问题</li>
<li>23:51 有了解过 Vueip 吗？</li>
<li>24:16 浏览器输入网址后到看到页面内容的过程中都发生了什么事情？</li>
<li>26:58 实际中经常会在Linux环境下操作吗？都会做些什么事情？</li>
<li>27:22 查看磁盘占用情况用什么命令？比如查看整个系统根目录的占用情况。</li>
<li>30:28 查看端口的运行情况用什么命令？有好几种</li>
<li>31:49 实时查看日志用什么命令？</li>
<li>32:11 怎么加关键字查看日志</li>
<li>32:44 Nginx 负载均衡算法有哪几种？</li>
<li>33:37 如果 Nginx 负载均衡了两台服务器，分别平分到50个请求，如果其中一个服务A宕机了，此时这100个请求就都堆到B那里去了，然后重启B服务，此时这些请求是继续被分到A上，还是会又恢复到 AB 平摊的状态？</li>
<li>34:56 如果一个服务器支持的最大并发量是1000，现在系统的并发量是1200，然后用 Nginx 负载两台，各600个请求，如果A此时需要重启，然后1200就都堆到B上了，然后B很快也就Down掉了，这种因为某个服务器的重启，导致整个系统崩溃的情况怎么预防呢？即使是短暂的重启，也是不可以被接受的。</li>
<li>36:12 线上怎么灰度升级？</li>
<li>36:59 你个人的职业规划是怎样的？</li>
<li>38:50 并发不高，也没有用到 Spring Cloud，你会愿意做这样的项目吗？</li>
<li>50:32 呼叫中心有了解过吗，呼叫中心很大，它包括很多部分。</li>
</ol>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote>
<p>2020-11-13 14:55 ～ 15:40（45m）</p>
<p>手机标准录音2.mp3</p>
</blockquote>
<ol>
<li>08:52 先简单自我介绍一下</li>
<li>09:33 要不你在这些项目里找一个你相对比较满意的一个项目，比如说技术栈啊、业务流程什么的</li>
<li>11:36 前端你是做到什么程度？</li>
<li>12:09 CD项目并发量是多少？使用量大概有多少？</li>
<li>12:49 CD项目的难点是什么？你在开发过程中遇到过的比较困难的地方？</li>
<li>14:46 对 Nginx 比较熟悉是吧，Nginx 大概对原理是什么？</li>
<li>15:54 SQL 熟悉哪些常规的操作？</li>
<li>16:27 RabbitMQ 只是知道怎么用是吧，平时有没有部署过？</li>
<li>16:56 MQ 一般有什么用途？</li>
<li>17:38 第一家公司是一家初创公司，这家公司主要是做什么产品的？</li>
<li>19:32 第一家公司的离职原因是什么？</li>
<li>20:58 第二家公司的规模怎么样？</li>
<li>22:26 第二家公司的离职原因是什么？</li>
<li>23:42 我们这边的情况你有没有了解？</li>
<li>27:02 你后面的方向大概是什么样的？你对个人技术的定位？</li>
<li>28:21 这边看你在学校的时候比较突出，你觉得你在学校的时候哪方面比较优秀？</li>
<li>30:12 第二家公司里的评级制度大概是什么样的？</li>
<li>33:57 你们组有多少人？</li>
<li>34:22 你觉得你个人的优点是什么？或者特长是什么？</li>
<li>35:32 你觉得你个人在哪方面有不足的地方？</li>
<li>37:49 你这边有什么需要问的？</li>
</ol>
<h2 id="搜电科技"><a href="#搜电科技" class="headerlink" title="搜电科技"></a>搜电科技</h2><blockquote>
<p>2020-11-17 15:00 ~</p>
</blockquote>
<h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><blockquote>
<p>手机-标准录音3.mps</p>
</blockquote>
<ol>
<li>Spring AOP，在同一个类里面，定义两个切面A和B，A方法中调用B方法，这两个切面都会生效吗？<br> <a href="https://blog.csdn.net/dushenzhi/article/details/52663310" target="_blank" rel="noopener">https://blog.csdn.net/dushenzhi/article/details/52663310</a><br> Spring AOP不支持代理类内部方法调用的拦截，比如类中a方法调用b方法，切面拦截b方法会失败的<br> <a href="https://blog.csdn.net/quzishen/article/details/5803721" target="_blank" rel="noopener">https://blog.csdn.net/quzishen/article/details/5803721</a></li>
<li>AOP 底层的代理是哪几种代理？JDK 动态代理和CGLB本质上的区别是什么？</li>
<li>MySQL 为什么用 InnoDB 引擎？</li>
<li>MySQL 索引用的 B+ 树，和 B 树有啥区别？</li>
<li>聚簇索引和非聚簇索引的区别是什么？</li>
<li>联合索引的顺序有什么影响？</li>
<li>联合索引（A，B，C），但是查询的时候是反过来查的（C=xxx and B=xxx and A=xxx），这种能走索引吗？</li>
<li>那（A&gt;xxx and B=xxx and C=xxx）这种呢，能走索引吗？</li>
<li>MySQL 主键索引和非主键索引的区别是什么？</li>
<li>MySQL InnoDB 引擎有行锁和表锁，什么时候用到行锁，什么时候用到表锁？</li>
<li>MySQL 左连接与右连接有什么区别？</li>
<li>消息中间件怎么保证消息不丢失？比如说服务宕机了。</li>
<li>RocketMQ有用过吗？</li>
<li>Redis 有几种数据结构？</li>
<li>Redis 除了做缓存，还有其他的使用场景吗？</li>
<li>Redis 做分布式锁有用过吗？</li>
<li>MySQL 你有没有做过分库分表？</li>
<li>Spring Boot 哪块了解的比较熟悉？</li>
<li>怎么自定义一个 Spring Boot Starter？</li>
<li>ES 你们一般是用来干嘛？</li>
<li>Java 的垃圾回收过程是什么样的？比如说垃圾从哪里产生，什么时候触发GC，最后怎么回收？</li>
<li>如果线上有条 SQL 比较慢，你会怎么去分析它？</li>
<li>如果用到了索引，扫描的行数也不多，但是SQL就是慢，会是什么原因呢？</li>
<li>如果线上进程没有问题，但某个线程突然不打日志了，我也不知道它在干嘛，你会怎么排查呢？</li>
<li>你是全日制本科吗？</li>
<li>Java 里面的锁你了解过哪些？</li>
<li>Synchronized 和 Lock 有什么区别？哪个是悲观锁哪个是乐观锁？你是怎么理解乐观锁和悲观锁的？</li>
<li>Synchronized 加在静态方法和加在非静态方法上有什么区别？</li>
<li>Java 这块你觉得你最熟悉的是哪一块？</li>
</ol>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><blockquote>
<p>手机-标准录音3.mps</p>
</blockquote>
<ol>
<li>API 项目组主要做些什么工作？</li>
<li>Java 的基础包括哪些？哪些 API，JDK 集合类里有哪些？</li>
<li>Map 除了 HashMap 还有哪些？</li>
<li>HashMap 用到哪些地方？</li>
<li>比如在 Service 层的类里写一个 Map，HashMap 合适吗？用 TreeMap 呢？</li>
<li>TreeMap 用在什么场景？</li>
<li>HTTP 有哪些状态码？</li>
<li>SpringBoot 中定义的接口，如果请求时缺少了一个参数，报的错误码是多少？</li>
<li>23 种设计模式，说个十种出来看一下。</li>
<li>工厂模式在 JDK 中的体现，不是在 Spring。</li>
<li>有用过加解密吗？加密算法有哪些？</li>
<li>非对称加密算法有哪些？</li>
<li>适配器模式在JDK中哪里用到了？</li>
<li>JDK 哪个地方用到了装饰器模式？</li>
<li>在集合类里面用到的最明显的模式是什么？</li>
<li>Linux 常用命令有哪些？</li>
<li>加入我要在日志文件里根据某个关键字怎么找？如果同时还想看下关键字上下文的信息呢？</li>
<li>RabbitMQ 在项目里主要做了什么工作，用在什么场景？</li>
<li>MySQL 查询，哪些时候索引会失效？</li>
<li>假如有个联合索引（A，B，C），查询时候用（A=xxx and C=xxx and B=xxx），会用到索引吗？</li>
<li>那用（C=xxx and B=xxx and A=xxx）能用到这个索引吗？</li>
<li>如果（A in 一系列常量），能用到A上的索引吗？</li>
<li>A between （），会用到A上的索引吗？</li>
<li>什么情况下会使用 Hash 索引？</li>
<li>A=length(某个变量)，这个时候能用到 A 上的索引吗？</li>
<li>表示状态的列，它的值比较少，什么时候可以在这个列上建立索引？</li>
<li>位图索引使用的什么存储结构？</li>
<li>了解过 BitMap 吗？是一个什么样的结构？</li>
<li>Redis 有哪些数据结构？</li>
<li>Redis 的过期策略有哪些？</li>
<li>Redis 持久化的策略有哪些？区别是什么？</li>
<li>Redis 的线程模型是什么？</li>
<li>Redis 为什么是单线程模型？</li>
<li>Spring Cloud 有哪些组件？</li>
<li>你觉得你还有哪些比较优秀的地方没有问到？</li>
<li>你项目中做的哪一块？</li>
<li>纸箱推荐采取的什么策略？</li>
<li>用户投票排名算法是什么样子的？</li>
<li>因为存在分页查询，但是用户在请求下一页的时候，排名是时时在变的，第一页的应用可能就排到了第二页，怎么保证数据不重复？</li>
<li>如果查询第二页的应用的时候，应用的得分已经超过了第一页的应用，这个时候怎么实时更新应用的顺序。这时候会出现后面的应用分数高但却排在后面。</li>
<li>你现在是在职还是离职，离职原因是什么？</li>
<li>想提升哪方面的技术能力？</li>
<li>你对自己合理的评价是什么？</li>
<li>你有哪些优点，缺点？</li>
<li>Vue 用的是工程化的吗？都用了哪些 Vue 相关的框架？</li>
<li>Vue 的设计思想是什么？</li>
<li>Vue 动态数据绑定底层是怎么实现的？</li>
<li>设置背景颜色、字体颜色怎么设置？</li>
<li>知道盒子模型吗？</li>
<li>工作上有碰到什么难题吗，技术上或者跟人相处方面的？</li>
<li>你觉得什么问题需要跟别人沟通，什么问题可以自己解决？</li>
<li>如果上级没有回应你，你怎么处理？</li>
<li>你期望的薪资范围是多少？最低多少？</li>
<li>你有什么想了解的？</li>
</ol>
<h3 id="三面-技术总监"><a href="#三面-技术总监" class="headerlink" title="三面(技术总监)"></a>三面(技术总监)</h3><h3 id="四面-HR"><a href="#四面-HR" class="headerlink" title="四面(HR)"></a>四面(HR)</h3><h2 id="平安智慧城市"><a href="#平安智慧城市" class="headerlink" title="平安智慧城市"></a>平安智慧城市</h2><blockquote>
<p>录音笔11月17日_3.aac</p>
</blockquote>
<ol>
<li>02:07 自我介绍</li>
<li>03:36 介绍一个你最熟悉的项目，从业务的角度概括一下项目做了什么事情，从技术上概括一下项目是怎么实现的？</li>
<li>06:07 mongodb 你们是用在什么场景下？</li>
<li>07:14 商品如果只是多的话，也不一定要存到 mongodb啊，一般的关系型数据库就可以啊。</li>
<li>08:10 数据库的分库分表是怎么用的？为什么要分出来？</li>
<li>09:18 你对 RRSTful 的理解？</li>
<li>10:06 介绍一下 jwt token 的机制。</li>
<li>11:28 RabbitMq是怎么用的？ebay接口调用失败了就发消息给eBay组，为什么要用消息队列？</li>
<li>16:01 es 在什么场景下用的？</li>
<li>17:52 为什么 es 的效率高呢？</li>
<li>18:16 mysql like <code>%</code> 放前面和放后面有什么区别？为什么用不到索引？</li>
<li>19:44 Java代码到机器码，这中间大概会有哪几步？</li>
</ol>
<h2 id="宝能物流"><a href="#宝能物流" class="headerlink" title="宝能物流"></a>宝能物流</h2><blockquote>
<p>2020-11-20 10:00 ~ </p>
<p>录音笔11月20日_2.aac</p>
</blockquote>
<h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><ol>
<li>自我介绍</li>
<li>02:11 说一下API组具体做的什么，怎么做的？</li>
<li>02:40 API项目主要的功能是什么，架构是什么，采用了什么技术？</li>
<li>03:56 你们数据量有多大？</li>
<li>04:22 订单是怎么同步的？</li>
<li>05:14 消息队列是用的什么，怎么做的？</li>
<li>05:23 有没有出现消息丢失的情况，怎么处理？</li>
<li>06:12 有没有用过缓存，什么场景下使用缓存，怎么用的？</li>
<li>06:50 首页商品信息放缓存里，是用的什么格式？</li>
<li>07:36 Redis 有哪些数据类型？他们之间有什么区别，使用场景是什么？</li>
<li>09:20 有没有用 Redis 做分布式锁？</li>
<li>10:14 Java 集合有哪些？你最常用的是哪些？底层有没有去了解过？</li>
<li>11:13 HashMap 什么时候采用红黑树？</li>
<li>11:45 HashMap 什么时候扩容？</li>
<li>12:07 HashMap 是不是线程安全的？为什么线程不安全？</li>
<li>13:25 ConcurrentHashMap 的分段是根据什么来分段的？</li>
<li>13:45 分段锁是加在方法上还是加在哪里？</li>
<li>14:45 怎么创建线程池？</li>
<li>14:58 阿里巴巴规范为什么不让使用 Excutor 直接创建线程池？</li>
<li>15:54 ThreadPoolExector 都有哪些参数，代表什么含义？</li>
<li>17:17 拒绝策略都有哪些？你平时工作中是用的哪一种？</li>
<li>20:06 JVM 有没有去了解过？说一下内存模型</li>
<li>22:37 年轻代空间比例是多少？</li>
<li>22:47 垃圾回收算法有哪些？有哪些垃圾收集器？</li>
</ol>
<h3 id="二面-技术总监"><a href="#二面-技术总监" class="headerlink" title="二面(技术总监)"></a>二面(技术总监)</h3><blockquote>
<p>录音笔 11月24日_1.aac</p>
</blockquote>
<ol>
<li>00:35 自我介绍</li>
<li>01:48 最近在专业的领域上有看哪些书籍吗？</li>
<li>02:26 介绍一下 JVM 的内存模型</li>
<li>04:35 程序计数器主要的作用是什么？</li>
<li>05:10 GC 算法有哪些？</li>
<li>07:17 有哪些对象可以作为可达性分析算法的GC ROOT？</li>
<li>07:46 如果频繁的出现 Full GC，一般是什么原因造成的？怎么去分析和定位问题？怎么 Dump？做过 dump 文件的分析吗？</li>
<li>10:11 用 == 比较两个 Integer 对象会是什么结果？</li>
<li>10:57 一个 byte 有多少位？它能存储的整数范围是多大？如果把128放进去会怎么样？</li>
<li>11:47 Java list 的实现类有哪些？</li>
<li>11:58 ArrayList 的默认长度是多少？ArrayList 在扩容的时候是怎么处理的？它是在原有的上扩容还是需要新的数组？为什么不在原有的基础上扩？</li>
<li>13:25 数组的查询复杂度是多少？</li>
<li>13:40 HashMap 与 HashTable 有什么区别？</li>
<li>13:57 HashMap 的数据结构是什么样的？什么时候用的链表，什么时候用红黑树？</li>
<li>15:52 HashMap 要做到线程安全要怎么做？ConcurrentHashMap 是怎么实现线程安全的？1.8 使用的 synchronize，和我直接在 HashMap 上加 synchronized 有什么不一样的？</li>
<li>18:32 介绍一下 synchronized 的实现原理，synchronized 有几种锁？synchronized 和 lock 的区别是什么？</li>
<li>23:11 Java 中的 ThreadLocal 的存储结构上怎样的？</li>
<li>24:04 如果我要把一个大的任务拆分成多个字任务，最后进行汇总，用多线程怎么设计？</li>
<li>24:47 jdk 里一个线程默认占用的内存是多少？</li>
<li>25:06 new 一个 abc 字符串，产生了多少个对象？再new一个abc会产生多少个对象？</li>
<li>26:30 我们在设置密码的时候是用 String 好还是char好？</li>
<li>26:51 Java 对象在序列化的时候有哪些属性是不会被序列化的？</li>
<li>27:36 字符流和字节流有什么区别？字节流的Java类有哪些？</li>
<li>28:37 数据库哪种用的比较多？对哪个比较熟悉？</li>
<li>19:12 mysql的存储引擎有哪些？innodb 索引结构是什么？</li>
<li>30:54 现在有个表，有个字段是存储大文本的，那实现的时候是需要把它放在子表里还是保留在原表里？</li>
<li>31:38 mysql 的主从复制能介绍一下吗？</li>
<li>31:55 Spring 的事务传播机制有哪些？</li>
<li>32:28 Spring 的AOP的技术实现是怎么实现的？CGLIB是通过什么技术实现的？那它是动态的织入还是静态的织入？</li>
<li>34:13 IoC 是通过什么技术实现的？</li>
<li>35:06 中间件了解哪些？RabbitMq 是基于什么协议实现的？RabbitMq 消息的发送模式有几种？RabbitMq 的集群模式有几种？</li>
<li>39:12 Spring Cloud 哪些组建比较熟？</li>
<li>39:54 Euraka 在CAP里是保障了哪两项？解释一下什么是分区可用性？</li>
<li>42:07 怎么把mybatis说有的sql语句抓去出来？</li>
<li>42:57 平常写代码的时候怎么保证代码质量？</li>
<li>43:44 单元测试有写过mock测试吗？</li>
<li>44:10 职业规划是怎么样的？</li>
<li>44:51 你这边有什么问题要问我的吗？</li>
</ol>
<h3 id="三面-HR"><a href="#三面-HR" class="headerlink" title="三面(HR)"></a>三面(HR)</h3><blockquote>
<p>录音笔 11月25日_2.aac</p>
</blockquote>
<ol>
<li>00:57 自我介绍</li>
<li>03:35 你们主要是做什么项目？我看你写的是跨境电商</li>
<li>04:21 你们核心的项目是哪一个？</li>
<li>04:36 你在 API 项目组里是充当一个什么角色？</li>
<li>04:52 你们这个项目有多少人？</li>
<li>06:07 你们和欧洲团队是怎么沟通的？</li>
<li>08:23 通过文档来沟通，你觉得这种沟通效率高还是低？会不会存在语言上的障碍？</li>
<li>09:47 电商行业有做的好的有不好的，你们公司做的怎么样？</li>
<li>11:58 你现在是已经提离职了还是在看机会？</li>
<li>12:10 是已经有拿到了 offer 了吗？</li>
<li>12:46 你是住在哪个地方？我们工作地点猎头有跟你说吗？</li>
<li>14:20 你今年换工作的主要原因是你们公司业务受影响了是吗？</li>
<li>14:48 那你上一家公司的离职原因是什么？</li>
<li>18:25 你之前做过的项目里，你觉得哪个项目做起来是最优成就感的？你在这个项目中的亮点体现在哪里？</li>
<li>21:23 之前对宝能集团有做过了解吗？谈一下你对宝能的一些认识。</li>
<li>23:20 那你有没有什么问题想要问我的？</li>
<li>23:41 项目你这边感兴趣吗？</li>
<li>27:39 你在木星软件有得到过晋升加薪的机会吗？</li>
<li>30:19 你有因为薪资的原因离职吗？</li>
<li>31:19 你们有其他的一些福利吗？</li>
<li>33:12 那你的期望薪资是多少？还可以再谈吗？那你综合年薪期望是多少？</li>
<li>34:43 毕业证这些都有吗？</li>
<li>38:04 你这边到岗时间是多久？</li>
</ol>
<h3 id="定薪"><a href="#定薪" class="headerlink" title="定薪"></a>定薪</h3><blockquote>
<p>手机通话录音</p>
</blockquote>
<h4 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h4><p>月度综合工资 = 固定薪资(80%) + 绩效工资(20%)</p>
<p>19K = 15.2K + 3.8K</p>
<p>绩效工资按出勤情况发放！</p>
<p>绩效考核和绩效工资是不挂钩的！</p>
<h4 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h4><ol>
<li><p>年终奖：两个月综合工资</p>
</li>
<li><p>公积金：基数为固定薪资，比例为 8%，公司和个人合计 16%</p>
</li>
<li><p>节假日奖金：3K</p>
</li>
<li><p>工作餐：早餐+中餐</p>
</li>
<li><p>班车</p>
</li>
</ol>
<h5 id="加班福利"><a href="#加班福利" class="headerlink" title="加班福利"></a>加班福利</h5><ol>
<li>加班到晚 8 点，报销</li>
<li>加班到晚 9 点，</li>
</ol>
<p>报销按月报销。</p>
<p>那种第一个就是跟您确认一下这个岗位的薪酬结构，还有我们给您的op的情况，第二个就是给您介绍一下公司福利相关的一些事项，嗯，首先的话。结构呢，我们这边阅读的综合工资会拆封维护星河记下两个部分，沪新增事项几个月的综合工资百分之87项事项百分之二十是一个八比二的一个开关，嗯，你那个绩效工资可发一句我也给您说一下，阿宝这边的话呢，就是说您的。世博和你的绩效工资是不挂钩的，也就是说嗯，记下了一个结果，不会用大型计算公司的一个金额和绩效工资的发放这方面，整个的一个月度综合工资，我们这边都是根据您的一个初级的一个情况啊，每个月按你的出现就A77发的是这样子的情况。嗯，您的试用期的话呢是呃看一下三个月的双七升七的薪资和转正的薪资是要涨，我们这边是不做这单，包括给你这个职位的话呢。这个职位薪酬的话呢，阅读综合工资是九k金十五点二A7向三点八配合A79。这个是呃您这样的一个情况，然后扶着的情况的话，首先也能讲我们是一名两个月的月的综合工资做基数去核算你当年的年终奖，您当年最终拿到了年终奖的思想，打工，第一个公司绩效，第二个第三个是当前的时间，这三个因素，然后。今天的话首先改基数是根据您的户型部分，他提到了你的工资是十五点二k，其实就是Find 5签了。是在深圳公积金的减数是八个点合计的话，公司和个人合计的话是十六个点给我。我爸最快饿家具这一块的话呢是金额的话就是总金额三千的发放形式，那么要根据不同城市的时候，我们会出相应的通知。好的，嗯，加班的福利是两个，一个是加班到八点以后是吧？二十号九点钟以后是半小时的，有这两个加班的福利事宜，报销的钱是按月核发的，还有一个。工作餐公司是包早餐和中餐场是在市场就餐，他的通勤班车的话呢，厄如果你有需要也可以乘坐啊，这一块的费用的话呢，是不需要有非常大的他。就是常规的企业相应的福利，看看这边有什么需要跟我确认的。嗯，刚才这个说是懂的，叫什么顾鑫家那个皮绩效还是使用啊，总的是十点。谢谢谢谢。绩效是按什么绩效的？Find 7教官跟你说了呀，就是出勤，我我也想听到的是一个猪蹄，还有还有别的方面了。没有，他会要考核是不挂钩的，我就再确认一下。是哦OK了解。呐呐嗯。这边一层还有一个，还有一个就是叫什么？嗯，那工资就是公司有那么固定涨薪的节目。恶年度是有的，嗯，调薪和晋升是在一起，大概在五六月份左右，可是我们这边保安这边的话，呃，不是说每个月工作要调，他是根据绩效一些相关的情况去评定的。你可了解，也是有部分员工如果绩效表绩效高的话就可以是吧？嗯，要看要看您的记下符不符合当时R3年度的条件的一个要求，可以了解。嗯。然后我我之前有了解，但不确定啊，就是那个上班的时间是。十点到下午六点，嗯，早上八点当然是照是吧？嗯，上班时间八点二十到下午六点哦。型号了解。还有别的吗？喂，你说还有别的吗？看你的。啊，对，我我这些大概都了解了，那。并未回复。我今天晚上，今天晚上回去考虑一下，然后晚上啊，现在是应该也下班了，那就明天早上回复。嗯，可以啊，嗯，那就我这边明天给你回复，你这边这个电话是取现的话，你可以直接联系到我的，你有什么问题到时候你再打电话跟我确认可以吗？你就直接打这个电话。行好的，嗯，好那先这样，好好好，谢谢，拜拜好再见。</p>
]]></content>
  </entry>
  <entry>
    <title>Huizhou Tour in the weekend of November 2019</title>
    <url>/2019/11/06/Huizhou-Tour-in-the-weekend-of-November-2019/</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2019/11/06/klqyjxgNZ9UIhG2.png" width="100%"/>

<a id="more"></a>

<h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><iframe width="100%" height="1000" frameborder="no"  src="https://libo9527.github.io/static/map/amap/20191109/all/index.html"></iframe>
## 交通

<table>
<thead>
<tr>
<th>线路名称</th>
<th>发车站</th>
<th>终点站</th>
<th>发车时间</th>
<th>票价</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>惠东港口专线</td>
<td>惠东汽车总站</td>
<td>港口</td>
<td>06:00 - 18:00 每 6 分钟一班车</td>
<td></td>
<td></td>
</tr>
<tr>
<td>惠东港口专线</td>
<td>港口</td>
<td>惠东汽车总站</td>
<td>06:00 - 18:00 每 6 分钟一班车</td>
<td></td>
<td></td>
</tr>
<tr>
<td>惠州稔山巽寮专线</td>
<td>厦深铁路惠东站</td>
<td>巽寮市场站</td>
<td>08:43 - 22:26 每 30 分钟一班车</td>
<td>全程票价(元):15.00</td>
<td><a href="https://bus.mapbar.com/huizhou/xianlu/renshanxunliaozhuanxian/1" target="_blank" rel="noopener">稔山巽寮专线 - 公交查询 - 图吧</a></td>
</tr>
<tr>
<td></td>
<td>惠东站</td>
<td>双月湾</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="惠东站-双月湾"><a href="#惠东站-双月湾" class="headerlink" title="惠东站 - 双月湾"></a>惠东站 - 双月湾</h3><ul>
<li>惠东站出站后左转找去双月湾的车 - 双月湾</li>
<li>惠东站 - 走和谐路到国道路口 - 搭乘惠东到港口专线 - 港口 - 走路去双月湾</li>
<li>惠东站 - 坐 H1/H2/H3 到稔山镇政府 - 搭乘惠东到港口专线 - 港口 - 走路去双月湾</li>
<li>惠东站 - 坐摩的到</li>
</ul>
<h3 id="惠东站-巽寮湾"><a href="#惠东站-巽寮湾" class="headerlink" title="惠东站 - 巽寮湾"></a>惠东站 - 巽寮湾</h3><ul>
<li>从<strong>厦深铁路惠东站</strong>坐<strong>惠州稔山巽寮专线</strong>到<strong>巽寮市场站</strong>下车</li>
</ul>
<h3 id="双月湾-巽寮湾"><a href="#双月湾-巽寮湾" class="headerlink" title="双月湾 - 巽寮湾"></a>双月湾 - 巽寮湾</h3><ul>
<li>走路/骑行/摩的/打车到平海古城 - 平海古城骑行/摩的/打车到油麻园小学公交站 - 坐 708路 公交到华家班站下 - 走路到酒店</li>
<li>港口坐惠东到港口专线到大埔屯 - 大埔屯坐惠州稔山巽寮专线到巽寮市场站</li>
</ul>
]]></content>
      <categories>
        <category>Tour</category>
      </categories>
      <tags>
        <tag>Tour</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains Crack</title>
    <url>/2020/02/16/JetBrains-Crack/</url>
    <content><![CDATA[<img data-src="https://pic1.zhimg.com/v2-4c7979e8f94967607bd46f880c480ec7_1200x500.jpg" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://zhile.io/2018/08/25/jetbrains-license-server-crack.html" target="_blank" rel="noopener">Jetbrains系列产品激活方法[持续更新]</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Crack</category>
        <category>JetBrains</category>
      </categories>
      <tags>
        <tag>Crack</tag>
        <tag>JetBrains</tag>
      </tags>
  </entry>
  <entry>
    <title>MBTI Report</title>
    <url>/2020/03/16/MBTI-Report/</url>
    <content><![CDATA[<img data-src="https://service.crm945.com/wp-content/uploads/2015/06/b269666ae9e4fbe4939017cad53a9d9d1.gif" width="100%"/>

<a id="more"></a>

<h2 id="MBTI"><a href="#MBTI" class="headerlink" title="MBTI"></a>MBTI</h2><blockquote>
<p><strong>迈尔斯-布里格斯性格分类指标</strong>（英语：Myers-Briggs Type Indicator，简称<strong>MBTI</strong>）是<a href="https://zh.wikipedia.org/w/index.php?title=性格分類&action=edit&redlink=1" target="_blank" rel="noopener">性格分类</a>理论模型的一种，其基本理论是根据<a href="https://zh.wikipedia.org/wiki/瑞士" target="_blank" rel="noopener">瑞士</a>心理分析家<a href="https://zh.wikipedia.org/wiki/卡尔·荣格" target="_blank" rel="noopener">卡尔·荣格</a>于1921年所出版的书籍《<a href="https://zh.wikipedia.org/w/index.php?title=心理類型&action=edit&redlink=1" target="_blank" rel="noopener">心理类型</a>》。最先的研究者是美国心理学家<a href="https://zh.wikipedia.org/w/index.php?title=凯瑟琳·布里格斯&action=edit&redlink=1" target="_blank" rel="noopener">凯瑟琳·布里格斯</a>及其女儿<a href="https://zh.wikipedia.org/w/index.php?title=伊莎贝尔·迈尔斯&action=edit&redlink=1" target="_blank" rel="noopener">伊莎贝尔·迈尔斯</a>。</p>
</blockquote>
<p>MBTI人格理论的基础是著名心理学家<strong>卡尔·荣格</strong>先生(弗洛伊德的正宗门徒)关于心理类型的划分，后经一对母女Katharine Briggs(凯瑟琳·布里格斯)与Isabel Myers(伊莎贝尔·迈尔斯)研究并加以发展。MBTI中的M和B就是Myers和Briggs。</p>
<p>MBTI人格模型分为四个维度，每个维度有两个方向，共计八个方面，即共有八种人格特点：</p>
<ul>
<li><p>我们的能量来源</p>
<ul>
<li><p>外向Extraversion (E)</p>
<p>关注自己如何影响外部环境：将心理能量和注意力聚集于外部世界和与他人的交往上。</p>
<p>例如：聚会、讨论、聊天</p>
</li>
<li><p>内向Introversion (I)</p>
<p>关注外部环境的变化对自己的影响：将心理能量和注意力聚集于内部世界，注重自己的内心体验。</p>
<p>例如：独立思考，看书，避免成为注意的中心，听的比说的多</p>
</li>
</ul>
</li>
<li><p>我们获取信息的主要方式</p>
<ul>
<li><p>感觉Sensing (S)</p>
<p>关注由感觉器官获取的具体信息：看到的、听到的、闻到的、尝到的、触摸到的事物</p>
<p>例如：关注细节、喜欢描述、喜欢使用和琢磨已知的技能</p>
</li>
<li><p>直觉iNtuition (N)</p>
<p>关注事物的整体和发展变化趋势：灵感、预测、暗示，重视推理</p>
<p>例如：重视想象力和独创力，喜欢学习新技能，但容易厌倦、喜欢使用比喻，跳跃性地展现事实</p>
</li>
</ul>
</li>
<li><p>我们的决策方式</p>
<ul>
<li><p>思考Thinking (T)</p>
<p>重视事物之间的逻辑关系，喜欢通过客观分析作决定评价。</p>
<p>例如：理智、客观、公正、认为圆通比坦率更重要</p>
</li>
<li><p>情感Feeling (F)</p>
<p>以自己和他人的感受为重，将价值观作为判定标准</p>
<p>例如：有同情心、善良、和睦、善解人意，考虑行为对他人情感的影响，认为圆通和坦率同样重要</p>
</li>
</ul>
</li>
<li><p>我们的做事方式</p>
<ul>
<li><p>判断Judging (J)</p>
<p>喜欢做计划和决定，愿意进行管理和控制，希望生活井然有序</p>
<p>例如：重视结果(重点在于完成任务)、按部就班、有条理、尊重时间期限、喜欢做决定</p>
</li>
<li><p>知觉Perceiving (P)</p>
<p>灵活、试图去理解、适应环境、倾向于留有余地，喜欢宽松自由的生活方式</p>
<p>例如：重视过程、随信息的变化不断调整目标，喜欢有多种选择。</p>
</li>
</ul>
</li>
</ul>
<h2 id="MBTI职业性格测试–-在线版"><a href="#MBTI职业性格测试–-在线版" class="headerlink" title="MBTI职业性格测试– 在线版"></a><a href="http://www.welefen.com/lab/mbti/" target="_blank" rel="noopener">MBTI职业性格测试– 在线版</a></h2><div class="tabs" id="mbti-reports"><ul class="nav-tabs"><li class="tab active"><a href="#mbti-reports-1">23题版报告</a></li><li class="tab"><a href="#mbti-reports-2">93题版报告</a></li></ul><div class="tab-content"><div class="tab-pane active" id="mbti-reports-1"><blockquote>
<p><a href="https://www.apesk.com/mbti/submit_email_date.asp?code=223.73.241.5&user=25875471" target="_blank" rel="noopener">23题版报告</a></p>
</blockquote>
<h3 id="INFP-哲学家型——生活在自己的理想世界"><a href="#INFP-哲学家型——生活在自己的理想世界" class="headerlink" title="INFP 哲学家型——生活在自己的理想世界"></a>INFP 哲学家型——生活在自己的理想世界</h3><p><strong>日期:</strong>  2020/3/16</p>
<h4 id="一、你的MBTI图形"><a href="#一、你的MBTI图形" class="headerlink" title="一、你的MBTI图形"></a>一、你的MBTI图形</h4><p><img data-src="/pdf/images/image-20200316193106608.png" alt="image-20200316193106608"></p>
<h4 id="二、基本描述"><a href="#二、基本描述" class="headerlink" title="二、基本描述"></a>二、基本描述</h4><p><img data-src="https://www.apesk.com/mensa/img/famous/INFP.jpg" alt="img"></p>
<div style="text-align: center">INFP (Introverted Feeling with Intuition)代表人物：卢梭 哲学家</div>

<blockquote class="blockquote-center"><p>虽然我的心既傲慢又温柔，我的性格柔弱，然而，我是不可战胜的。</p>
</blockquote>

<p>才储分析：</p>
<ul>
<li>您的性格类型倾向为“ INFP ”(内向 直觉 情感 知觉)</li>
<li><strong>倾向度：</strong> I-57 N-100 F-86 P-57</li>
<li>不假思索指数：8</li>
</ul></div><div class="tab-pane" id="mbti-reports-2"><blockquote>
<p><a href="https://www.apesk.com/mbti/submit_email_date.asp?code=223.73.241.5&user=25887502" target="_blank" rel="noopener">93题版报告</a></p>
</blockquote>
<h3 id="INFP-哲学家型——生活在自己的理想世界"><a href="#INFP-哲学家型——生活在自己的理想世界" class="headerlink" title="INFP 哲学家型——生活在自己的理想世界"></a>INFP 哲学家型——生活在自己的理想世界</h3><p><strong>日期:</strong> 2020/3/17</p>
<h4 id="一、你的MBTI图形"><a href="#一、你的MBTI图形" class="headerlink" title="一、你的MBTI图形"></a>一、你的MBTI图形</h4><p><img data-src="/pdf/images/image-20200317141841624.png" alt="image-20200317141841624"></p>
<h4 id="二、基本描述"><a href="#二、基本描述" class="headerlink" title="二、基本描述"></a>二、基本描述</h4><p>才储分析：</p>
<ul>
<li>您的性格类型倾向为“ INFP ”(内向 直觉 情感 知觉)</li>
<li><strong>倾向度：</strong> I50 N60 F78 P52 </li>
<li>不假思索指数：8</li>
</ul></div></div></div>

<p>理想主义者，忠于自己的价值观及自己所重视的人。外在的生活与内在的价值观配合，有好奇心，很快看到事情的可能与否，能够加速对理念的实践。试图了解别人、协助别人发展潜能。适应力强，有弹性；<mark>如果和他们的价值观没有抵触，往往能包容他人。</mark></p>
<p>INFP把内在的和谐视为高于其他一切。他们敏感、理想化、忠诚，对于个人价值具有一种强烈的荣誉感。他们个人信仰坚定，有为自认为有价值的事业献身的精神。 INFP型的人对于已知事物之外的可能性很感兴趣，精力集中于他们的梦想和想象。他们思维开阔、有好奇心和洞察力，常常具有出色的长远眼光。在日常事务中，他们通常灵活多变、具有<mark>忍耐力和适应性</mark>，但是他们非常坚定地对待内心的忠诚，<mark>为自己设定了事实上几乎是不可能的标准。</mark> INFP型的人具有许多使他们忙碌的理想和忠诚。他们十分坚定地完成自己所选择的事情，他们往往承担得太多，但不管怎样总要完成每件事。虽然对外部世界他们显得冷淡缄默，但INFP型的人很关心内在。他们富有同情心、理解力，<mark>对于别人的情感很敏感</mark>。除了他们的价值观受到威胁外，他们<mark>总是避免冲突</mark>，没有兴趣强迫或支配别人。INFP型的人<mark>常常喜欢通过书写而不是口头来表达自己的感情</mark>。当INFP型的人劝说别人相信他们的想法的重要性时，可能是最有说服力的。INFP<mark>很少显露强烈的感情，常常显得沉默而冷静</mark>。然而，一旦他们与你认识了，就会变得热情友好，但<mark>往往会避免浮浅的交往</mark>。他们珍视那些花费时间去思考目标与价值的人。</p>
<p>您适合的领域有：创作性、艺术类 教育、研究、咨询类等</p>
<p>您适合的职业有：· 心理学家 · 心理辅导和咨询人员 · 人力资源管理 · 翻译 · 大学教师（人文学科） · 社会工作者 · 图书管理员 · 服装设计师 · 编辑 · <mark>网站设计师</mark> · <mark>计算机程序UI设计员</mark> · 团队建设顾问 · 艺术指导 · 记者 · 口笔译人员 · 娱乐业人士 · 建筑师 · 社科类研究人员 · 教育顾问 · 各类艺术家 · 插图画家 · 诗人 · 小说家  </p>
<h4 id="三、气质类型"><a href="#三、气质类型" class="headerlink" title="三、气质类型"></a>三、气质类型</h4><p>根据大卫.凯尔西（David Keirsey）气质与性情理论，你属于“<strong>理想主义者</strong>”，下面是对“<strong>理想主义者</strong>”的描述：</p>
<p>“理想主义者”型的人感兴趣的是事物的意义、关系和可能性，并基于其个人的价值观念做出决定。这是一类关心个人成长和如何理解他人与自我的人。<mark>“理想主义者”做人的原则是：“真实地面对自已”</mark>，是精神上最具哲理性的人。“理想主义者”乐于接受新的思想，善于容纳他人。<mark>“理想主义者”好象永远在寻找生存的意义。</mark>他们非常崇尚人与人之间和各种关系中的真实和正直，容易将别人理想化。许多“理想主义者”<mark>本能地喜欢帮助别人成长和进步。</mark>“理想主义者”是很好的传播者，被人们认为是促进积极变化的催化剂。他们天生能够理解别人的情感，关心他们在生活、工作中碰到的人们（如同事、病人或客户、雇员）的需要。  <mark>对于“理想主义者”型的人而言，一份好的工作应该是对他们个人很有意义的工作，而不是简单的常规工作或只是一种谋生手段。</mark>“ 理想主义者”崇尚和谐，不愿意在一种竞争激烈或四分五裂的环境中发展。他们喜欢民主、能够激励各种层次的人们高度参与的组织 。他们会被那些促进人性价值的组织或那些允许他们帮助别人完成工作的职业所吸引。</p>
<p><strong>总体描述</strong>  </p>
<ol>
<li>对别人的情绪敏感，能理解、体会别人的心情，善于安慰、鼓励别人</li>
<li>对文字、语言敏感</li>
<li>善于分析、总结</li>
<li>善于从整体上把握事物</li>
<li>能理解复杂的理论概念，善于将事情概念化，善于从中推断出原则</li>
<li>擅长策略性思维</li>
</ol>
<p><strong>潜在的弱点</strong></p>
<ol>
<li>有仅仅凭个人的好恶或价值观来决定事情，并希望别人也以同样的角度或标准来处理问题的倾向。</li>
<li>有时他们心里老想着别人的问题，可能会过于陷于其中，以至于被其困扰。</li>
<li>有时容易将别人或事情理想化，不够实际。</li>
<li>不是特别善于管束和批评他人，尽管常常自我批评。有时会为了和睦而牺牲自己的意见或利益。</li>
<li>有些此类型成员比较容易动感情，情绪波动较大。</li>
</ol>
<h4 id="四、优势与劣势"><a href="#四、优势与劣势" class="headerlink" title="四、优势与劣势"></a>四、优势与劣势</h4><p><strong>INFP的特质：哲学家型——生活在自己的理想世界</strong><br><strong>优势：</strong>你比较敏感，非常崇尚内心的平和，看重个人的价值，忠诚，并且理想化，一旦做出选择，就会约束自己完成。你外表看起来沉默而冷静，但内心对他人的情感十分在意。你非常善良，有同情心，善解人意。你重视与他人有深度、真实、共同进步的关系，希望参与有助于自己及他人的进步和内在发展的工作，欣赏那些能够理解你价值的人。你有独创性、有个性，好奇心强，思路开阔，有容忍力。乐于探索事物的可能性，致力于自己的梦想和远见。你很喜欢探索自己和他人的个性。一旦全身心地投入一项工作时，你往往发挥出冲刺式的干劲，全神贯注，全力以赴。你对人、事和思想信仰负责，一般能够忠实履行自己的义务。但是，对于意义不大的日常工作，你做起来可能有些困难。</p>
<p><strong>劣势：</strong>你追求完美，会花很长时间酝酿自己的想法，难以用适当的方式来表达自己。你需要更加注重行动。你经常忽略逻辑思考和具体现实，沉浸于梦想。当意识到自己的理想与现实之间的差距，你就容易灰心丧气。你需要听取他人更实际的建议，考虑方法的现实性和可行性。你非常固执，经常局限在自己的想法里，对外界的客观具体事物没有兴趣，甚至忙的不知道周围发生了什么事情。你总是用高标准来要求自己，投入太多的感情，导致你对批评相当敏感。压力很大的时候，你可能会非常怀疑自己或他人的能力，而变得吹毛求疵，又爱瞎判断，对一切都有抵触情绪。</p>
<blockquote class="blockquote-center"><p>为什么受到启迪的人总是轻松愉快，宛如孩童？</p>
<p>因为他们是……</p>
<p>生命的主人，熟悉自己的路，</p>
<p>因为他们听从良知的呼唤，</p>
<p>那是智慧和天真的声音……</p>
<p>———— 佐罗.大卫</p>
</blockquote>

<h3 id="MBTI第二步报告"><a href="#MBTI第二步报告" class="headerlink" title="MBTI第二步报告"></a>MBTI第二步报告</h3><h4 id="基本报告"><a href="#基本报告" class="headerlink" title="基本报告"></a>基本报告</h4><blockquote>
<p>source/pdf/XX - MBTI基本分析报告.pdf</p>
<p><a href="https://www.apesk.com/mbti_step2/common2report/mbti1_report_admin_get_id.asp?id=188790&amp;grhr=gr&amp;pdf=yes#report_zhuti" target="_blank" rel="noopener">https://www.apesk.com/mbti_step2/common2report/mbti1_report_admin_get_id.asp?id=188790&amp;grhr=gr&amp;pdf=yes#report_zhuti</a></p>
</blockquote>
<h5 id="被隐藏的实质"><a href="#被隐藏的实质" class="headerlink" title="被隐藏的实质"></a>被隐藏的实质</h5><p>也许你也有过相似的经历，经过几年的分离，再见老朋友的感觉总是 令人忍不住的兴奋。起初，你可能不停的想他变成什么样子了。不过，很快你就会高兴的发现站在你面前的这个半陌生半熟悉的人还是你认识的那个老朋友。没变的那部分最本质的核心也就是心理学家口中的<strong>人格</strong>。</p>
<h5 id="人格心理学——你有人格吗？"><a href="#人格心理学——你有人格吗？" class="headerlink" title="人格心理学——你有人格吗？"></a>人格心理学——你有人格吗？</h5><p>心理学认为，人格是一个人独特的思维、情感和行为模式。换句话说，一个人过去是什么样的人，现在和将来还是什么样的人，这种一贯性就是由其人格所决定的。</p>
<h5 id="人格特质"><a href="#人格特质" class="headerlink" title="人格特质"></a>人格特质</h5><p>心理学家把人的特殊的、稳定的个性品质称为“人格特质”。</p>
<h5 id="人格模板是什么时候形成的？"><a href="#人格模板是什么时候形成的？" class="headerlink" title="人格模板是什么时候形成的？"></a>人格模板是什么时候形成的？</h5><p>人格特质通常非常稳定。</p>
<p>一般人到了二十岁之后，人格就很难再改变了。到了30岁，人格彻底稳定下来，你30岁怎样，到了60岁还差不多是这样。</p>
<h5 id="你的MBTI图形"><a href="#你的MBTI图形" class="headerlink" title="你的MBTI图形"></a>你的MBTI图形</h5><p><img data-src="/pdf/images/image-20200318150159516.png" alt="image-20200318150159516"></p>
<h5 id="个性特征描述"><a href="#个性特征描述" class="headerlink" title="个性特征描述"></a>个性特征描述</h5><p><img data-src="https://www.apesk.com/mensa/img/famous/ISFJ-F.jpg" alt="img"></p>
<div style="text-align: center">ISFJ (Introverted Sensation with Feeling)代表人物：戴安娜王妃 慈善家</div>

<blockquote class="blockquote-center"><p>爱始于家。重点不在于我们做了多少，而在于我们倾注了多少爱。</p>
</blockquote>

<p>测试显示你的类型为：<strong>ISFJ</strong>（内倾、感觉、情感和判断）——值得信赖和依靠。亦被称为<strong>照顾者型</strong></p>
<p>你具有友善、负责、认真、忠于职守的特点，只要你认为应该做的事，不管有多少麻烦都要去做，但却<mark>厌烦去做你认为毫无意义的事情</mark>。</p>
<p>你务实、实事求是，追求具体和明确的事情，喜欢做实际的考虑。善于单独思考、收集和考察丰富的外在信息。不喜欢逻辑的思考和理论的应用，拥有对细节很强的记忆力，诸如声音的音色或面部表情。</p>
<p>你与人交往时较为敏感，谦逊而少言、善良、有同情心，喜欢关心他人并提供实际的帮助，你们对朋友忠实友好，有奉献精神。虽然在很多情况下你有很强烈的反应，但通常不愿意将个人情感表现出来。</p>
<p>你做事有很强的原则性，尊重约定，维护传统。工作时严谨而有条理，愿意承担责任，你依据明晰的评估和收集的信息来做决定，充分发挥自己客观的判断和敏锐的洞察力。</p>
<p>ISFJ型的人忠减、有奉献精神和同情心他们意志清醒而有责任心，乐于为人,理解别人的感受。ISFJ型的人十分务实，他们喜欢平和谦逊的人，他们喜欢利用大量的事实情况，对于细节则有很强的记忆力。他们耐心地对待任务的整个阶段，喜欢事情能够清晰明确。</p>
<p>因为他们具有强烈的职业道德，所以他们如果知道自己的行为真正有用时，会对需要完成之事承担责任。他们准确系统地完成任务。他们具有传统的价值观，十分保守。他们利用符合实际的判断标准做决定，通过出色的注重实际的态度增加了稳定性。</p>
<p>ISFJ型的人平和谦虚、勤奋严肃。他们温和、圆通，支持朋友和同伴。他们乐于协助别人，喜欢实际可行地帮助他人。他们利用个人热情与人交往，在困难中与他人和睦相处。ISFJ型的人不喜欢表达个人情感，但实际上对于大多数的情况和事件都具有强烈的个人反应。他们关心保护朋友，愿意为朋友献身，他们有为他人服务的意识，愿意完成他们的责任和义务。</p>
<h5 id="可能存在的盲点"><a href="#可能存在的盲点" class="headerlink" title="可能存在的盲点"></a>可能存在的盲点</h5><p>你有高度的责任心，会陷入日常事务的细节中去，以至于没完没了的工作。每件事情你都会从头做到尾，这总是让你过度劳累，压力很大时，你会过度紧张，甚至产生消极情绪。</p>
<p>由于你的现实、细致，有时<mark>容易忽略事情的全局和发展变化趋势，难以预见存在的可能性</mark>。建议你周到考虑解决问题的不同方法和可能性，<mark>需要增强对远景的关注</mark>。</p>
<p>你总是替别人着想，以至于<mark>让人感觉“关心过度”，你需要学会给别人空间</mark>。在工作中，你过多的承受和忍耐，不太习惯表达，<mark>却</mark>将情绪在家庭和生活中发泄出来。</p>
<p>你不停地制订计划并保证完成，以致于经常花费更多的时间和投入更多的精力来完成工作，建议你给自己安排必要的娱乐和放松的活动，不要总是“低头拉车”，需要考虑“抬头看路”。</p>
<p>ISFJ型的人生活在完全现实的生活中，他们很难全面地观察问题，也很难预见情形的可能性结果，尤其是当他们不熟悉情形之时。他们需要看得更远些，想象如果以不同方式做事可能会产生怎样的后果。</p>
<p>ISFJ型的人为了自己和那些对其应负责的人，每天陷入了劳累和无终止的劳作中。他们常常过多地工作，亲自去做某件事以确保能够一丝不苟地完成。因为他们<mark>天生并不是过分自信或意志坚强</mark>，所以他们有被别人利用的危险。他们必须表达不断被各种事物缠绕的怨恨之情，所以他们没有发现自己已成为一种帮助的角色。而且他们还必须让其他人知道他们的需求和成就。</p>
<p>ISFJ型的人经常需要额外的时间以掌握技术性的内容。他们<mark>往往过多地计划</mark>，所以必须制定有助于重新调整他们那耗费过多、令人担心的精力的计划。ISFJ型的人必须寻找能够得到他们应得的、更多的快乐和放松的方法。</p>
<h5 id="功能运用"><a href="#功能运用" class="headerlink" title="功能运用"></a>功能运用</h5><p>外向与内向是指我们心理能量的作用方向，判断与知觉是我们做事的两种方式。心理学称之为“<strong>态度</strong>”。</p>
<p>感觉与直觉是我们获取信息的方式，思考和情感是做决定的方式，心理学称之为“<strong>功能</strong>”，功能是人格理论的精髓、核心。</p>
<p>每一个人在都会用到四种功能，但对功能应用的喜好程度不一样。等级中第一位的称为“主导功能”，第二位的称为“辅助功能”。每个人都需要运用到这两个过程。</p>
<h5 id="有效地使用你的类型：-ISFJ"><a href="#有效地使用你的类型：-ISFJ" class="headerlink" title="有效地使用你的类型：(ISFJ)"></a>有效地使用你的类型：(ISFJ)</h5><p>ISFJ型的人主导功能是感觉（关注细节），辅助功能是情感。他们倾向于：</p>
<p>注意细节、重视实际、能记住琐碎细节、耐得住烦闷的工作、有耐性、细心有系统。</p>
<p>体谅他人感受、了解他人的需要、喜欢和谐的人际关系、易表露情感、喜去说服他人。</p>
<p>ISFJ型的人比较少地使用他们的第三、第四功能——思考和直觉。即使在需要这些功能的场合，他们仍然无法有效使用。</p>
<p>作为一个ISFJ型的人：</p>
<p>如果你过多的使用感觉和情感功能，你可能会失去整体的概念、想不出各种可能解决的途径、不相信直觉、不求创新、无法应付太复杂的工作、不喜欢预测未来。</p>
<h5 id="问题解决方式"><a href="#问题解决方式" class="headerlink" title="问题解决方式"></a>问题解决方式</h5><p>每个人都会用自己的方式进行决策，决策通常来自于你的主导功能，并且完全忽视你的第四功能。</p>
<p>你的功能运用如下：主导功能感觉——辅助功能情感——第三功能思考——第四功能直觉</p>
<p>人格中的每一种功能对解决问题都具有关键和重要作用，忽视任何一个都将导致做出有缺陷的决定，<mark>理想化的问题解决功能流程如下</mark>：</p>
<p><img data-src="https://www.apesk.com/mbti2/images/favchengshi_isfj.jpg" alt="img"></p>
<p><mark>一个好的决策通常来自于四个功能的合理运用。</mark>当你尝试去解决问题时，你可以利用上表指导这个过程，但在整个的执行过程是非常困难的，因为每个人都不愿意用他不喜欢的功能去解决问题。就算你有意识地努力运用所有这些功能，你也不可能会在“真实生活”中以这种顺序运用它们。关键是要利用它们提醒自己，完善决策，就算你不按这种方式行事。</p>
<p>工作中选择符合你的主导功能和辅助功能的岗位是非常重要的。第三功能要经过发展锻炼才能合适运用，第四功能可能永远不会在你的职业生涯中起到关键作用，因此你应当避免那种要求长期使用它的工作。</p>
<h5 id="工作中的优势"><a href="#工作中的优势" class="headerlink" title="工作中的优势"></a>工作中的优势</h5><p>●能够很好地集中、关注焦点</p>
<p>●很强的工作伦理，工作努力而且很负责任</p>
<p>●良好的协作技巧，能和别人建立起和谐友好的关系</p>
<p>●讲求实效的工作态度，办事方法现实可行</p>
<p>●十分关注细节，能够准确地把握事实</p>
<p>●乐于助人，给同事和下属职员的工作提供支持和帮助</p>
<p>●了解公司（或组织）的经历，能够很好地维护公司（或组织）的传统</p>
<p>●杰出的组织才能</p>
<p>●愿意在传统的机构中工作，而且兢兢业业、不遗余力</p>
<p>●能够连续地工作，对相同的工作任务不会感到厌倦</p>
<p>●非常强的责任意识；别人可以信任你去实现自己的诺言</p>
<p>●喜欢运用固定的办事程序；尊重别人的地位和能力</p>
<p>●通情达理，视角现实</p>
<h5 id="工作中的劣势"><a href="#工作中的劣势" class="headerlink" title="工作中的劣势"></a>工作中的劣势</h5><p>●可能<mark>低估自己的能力</mark>，难以坚决地维护自己的需要和利益</p>
<p>●不愿意尝试、接受新的和未经考验的观点和想法</p>
<p>●<mark>对反对意见过于敏感</mark>；在紧张的工作环境里感到很受压抑</p>
<p>●可能只关注细节和眼前之事，而对整体和将来重视不够</p>
<p>●倾向于同时投入到过多的任务之中</p>
<p>●难以适应新环境，或者在不同工作任务之间来回切换时会有困难</p>
<p>●易于被需要同时解决的太多的工作项目或任务弄得晕头转向、无所适从</p>
<p>●如果自己<mark>得不到充分的重视和赞赏，可能会感到灰心丧气</mark></p>
<p>●一经做出决定，就<mark>不愿意从头考虑同一个问题</mark></p>
<h5 id="适合的岗位特质"><a href="#适合的岗位特质" class="headerlink" title="适合的岗位特质"></a>适合的岗位特质</h5><p>下面的条目从各个侧面上认证了您怎样才能感受到真正的职业满足，看完这些条目之后，我们建议您根据它们对您的重要程度进行排序，排序的时候，回想一下您过去的学习、工作经历以及当前学习环境和工作感受，并思考：“哪一些是令你感到特别满意，有哪些令你极其不高兴”。试着寻找贯穿这些经历的主题。</p>
<p><strong>你的岗位特质：</strong></p>
<p>在规范、传统、稳定的环境下工作，可以给他人提供服务或帮助</p>
<p>适合在责任清晰，有一定私人空间、人际关系和谐的氛围中工作</p>
<p>要求细致、精确，能够发挥你出色的观察力和对细节的关注能力</p>
<p>工作能够让你集中精力，关注一件事情或一个人，而不是平行开展多项工作</p>
<p>通过工作，你能够得到同事和上级的认可、欣赏和鼓励</p>
<p>按照标准化的工作流程和规范开展工作，不要在事先没有准备的情况下把你的工作展示给别人</p>
<p><strong>用第一人称描述如下：</strong></p>
<p>1、要求仔细观察、一丝不苟和准确无误，因此我能充分发挥记忆事实和分析细节的能力。</p>
<p>2、能让我致力于有形的、现实的项目任务，并以此为别人提供帮助和服务；通常需要对细节问题非常关注，对精确性的要求也非常高。</p>
<p>3、使我通过默默无闻的努力工作，表达自己对别人的同情与对工作的热忱；同时我做出的贡献也受到重视和赞赏。</p>
<p>4、工作在一个传统、稳定、有序和制度化的环境中，并且能为别人提供使用价值非常高的服务。</p>
<p>5、要求遵循标准化的工作程序，运用现实的判断力，并且仔细、有条不紊地坚持到底。</p>
<p>6、每次都全身心地投入到一个项目任务或一个人身上，并且做出的产品或提供的服务能够带来可观的结果。</p>
<p>7、能让我有一个独立的工作空间，这样我就能连续地集中注意力，受到最小限度的干扰和打断。</p>
<p>8、不论是帮助别人也好，还是与志同道合的人打交道也好，大多数时候都只需要我关注一个对象，而不是同时为好几个人工作或提供服务。</p>
<p>9、在完成工作任务的过程中，要求我条理清晰并且效率很高。</p>
<p>10、把工作成果向别人展示之前，能让我事先有充分的时间来准备。</p>
<h5 id="职业类型——您适合的职业"><a href="#职业类型——您适合的职业" class="headerlink" title="职业类型——您适合的职业"></a>职业类型——您适合的职业</h5><p><strong>你适合的职业</strong></p>
<p>你喜欢通过具体的方法亲自、单独的与他人打交道，运用技术给他们带来直接的影响。<br>例如：营养学者、外科医生、<strong>宠物医生</strong>、牙医、生物/植物学者、护士、矫形师等。</p>
<p>教育和研究类的工作特别受到和你特点相同的人的青睐，他们可以自主的工作，可以帮助别人，并能看到成果，可以为社会做出贡献。<br>例如：幼儿/小学教师、社会工作者、健康保健人员、指导顾问、历史学者、运动培训师、园艺人员等。</p>
<p>还有一些直接的和他人单独打交道的工作，这些工作要求你具有较广的知识面、技能和交际才能来给别人支持。<br>例如：秘书、行政/人事管理人员、电脑维护者、信贷顾问、顾客服务等。</p>
<p>那些对工作细节非常关注，满足客户要求，与他们友好相处的实实在在的工作也是你需要考虑的。<br>例如：艺术人员、室内设计师、商品规划师、营销、房地产代理或经纪人、酒店管理人员等。</p>
<p><strong>视野拓展：</strong></p>
<p>我们要警告您：每种职业中都有各种性格类型的成功人士；即使是相同的工作，不同公司的要求也不尽相同。这份报告上列举的工作种类不是限制了你的选择，而是告诉你，面对新工作的选择或机会时，应该从哪些因素来分析这些工作对你的适合程度。</p>
<p><strong>健康护理部分：</strong>牙医/家庭运动医生/护士/医务技术专家/理疗法专家/医疗设备推销/提供健康护理人员/饮食专家/营养学家/眼科大夫/医务记录管理人员/药剂师/药剂技术人员/放射专家/呼吸系统专家/<strong>兽医</strong>/有执照行医护士/初级保健大夫/家庭保健助理/医务/牙科助理</p>
<p>这些职业允许ISFJ型的人在这样一种环境下工作，在这里他们的贡献通过对别人施加的个人的、直接的影响表现出来。那些职业中的很大一部分要求同客户和患者进行亲身的、一对一的交往。ISFJ型的人<mark>喜欢用一种真实的方法帮助别人</mark>。那些职位也允许ISFJ型的人在一种传统的，组织化的文化中相对独立地工作。医务领域充分利用了ISFJ型的入学习和实践技术的能力，为他们提供了同别人建立个人联系的机会。</p>
<p><strong>社会服务部门：</strong>教育部门/学前教育/初级学校教师/图书馆员/建筑师/教育管理人员/社会福利工作人员/咨询服务人员/个人咨询人员/宗教教育者/言语病理学家/家庭健康社会服务人员/儿童福利咨询人员/戒酒和戒毒咨询人员/小学教师/图书管理员/档案保管员/特殊教育老师/(博物馆、美术馆、图书馆等的)馆长/家谱学家/教育行政人员/咨询服务人员/社会工作者(老年服务)/神学教育者/(博物馆、图书馆、美术馆等的)馆长/社会工作人员(老年和儿童每日看护问题)</p>
<p>由于教育部门能为ISFJ型的人提供<mark>帮助他人，服务社会</mark>的机会，所以很吸引这种类型的人。ISFJ型的人经常喜欢教初中生，由于这可以同学生进行个人交往和发挥他们善长教基本技巧的能力。许多ISFJ型的人喜欢教育管理类的职业。尤其当他们对特定范围(例如特殊教育)或相对小的服务范围(一个小镇而非大城市)负责时更是这样。ISFJ型的人喜欢在组织内独立工作，这种组织必须是认可他们的成绩，使他们明白职业目标的那种。</p>
<p>研究领域为ISFJ型人提供满足感是因为它们提供了独立工作和调查具体任务的机会。馆员们要求创造性并保持完整而准确的记录，这使他们能利用自己的组织能力和回忆事实的特长。尽管经常面临挑战，社会福利工作仍给予ISFJ型的人获得职业满足的机会。因为通过同客户的交往，ISFJ型的人能对别人的生活给予切实的提高，因此，他们发现贡献是有价值的，这些工作提供了同样的一对一交往和独立工作的环境，这对于ISFJ型的人都具有吸引力。</p>
<p>商业/秘书/员工监督人/顾客服务代表/人事管理人员/计算机操作者/记帐员/信用顾问/律师的专职助手/家用保健品推销</p>
<p>这些职业要求大量的<mark>在一对一基础上同别人交往的机会</mark>，因此常为ISFJ型的人所喜欢。这些职业中许多都不是独立完成的工作，这能使ISFJ型的人使用组织方面和深入细节的能力。尤其当他们同受他们尊敬和钦佩的人一块工作时。这些职业同样要求知识及技术和交流技巧以帮助别人获取信息或帮助他们满足需求。</p>
<p>创造性/技术性/内部装饰人员/电工/零售商/旅店老板/艺术家/音乐家/优先顾客销售代理人/商业计划者/不动产经纪人</p>
<p>这些职业彼此未必有关联但它们有一些共同的特征和要求。每种都要求<mark>与同日常生活有关的实际东西打交道</mark>。作为一个内部装饰人员，ISFJ型的人运用他或她的审美感给予客户以合适的装潢。这种工作要求注重细节以及同别人合作向满足客户对他或她室内装饰的需要和愿望迈进的能力。ISFJ型的人<mark>很注重自己房间的装饰</mark>，因此，他们容易理解客户装饰出使他们舒服的居室的愿望。</p>
<p>一个电工要求技术准确性和坚持标准程序和代码。ISFJ型的人<mark>喜欢注意那些要求亲自动手的工作</mark>，也喜欢使用他们掌握的技术。如果ISFJ型的人感到他或她的贡献是有价值的并为人欣赏，如果他或她赢得了同顾客、同伙、同事的有质量的交往，那么电工的工作也是令人满意的。</p>
<p>零售推销和商业是经常为ISFJ型所喜欢的职业，尤其当他们在小专卖店或大商场的一个部门工作时。ISFJ型的人常可以成为小商店的好老板。他们对诸如商店形象之类细节的关注以对顾客的“感觉”经常为他们赢得长期稳定的买卖。他们喜欢一定时间内同一名顾客交流，寻找合适的装饰品与顾客们已有的相配套。他们喜欢长期维持与顾客的关系，对待顾客十分友好和诚实可信。</p>
<h5 id="对组织的贡献"><a href="#对组织的贡献" class="headerlink" title="对组织的贡献"></a>对组织的贡献</h5><p>●重视人的实际需要；</p>
<p>●在贯彻执行组织目标中，采用强的执行技巧；</p>
<p>●关心细节，遵从规范，埋头苦干，有责任心；</p>
<p>●乐意为他人服务；</p>
<p>●安排事情井井有条。</p>
<h5 id="领导风格"><a href="#领导风格" class="headerlink" title="领导风格"></a>领导风格</h5><p>●不刻意追求领导角色，但在必要时能毅然承担重任；</p>
<p>●期望他人和自己都遵从组织的需求、规范和等级；</p>
<p>●运用表面现象背后的个人影响；</p>
<p>●认真、谨慎地遵守传统作法和规章；</p>
<p>●在细节上动脑筋以取得实际结果。</p>
<h5 id="潜在缺陷"><a href="#潜在缺陷" class="headerlink" title="潜在缺陷"></a>潜在缺陷</h5><p>●<mark>对未来过分悲观</mark>；</p>
<p>●在对人表达其观点时被视为<mark>不够强硬</mark>；</p>
<p>●僵化、不太灵活；</p>
<p>●由于总是<mark>避免出风头，其作用被低估</mark>。</p>
<h5 id="适合的工作环境"><a href="#适合的工作环境" class="headerlink" title="适合的工作环境"></a>适合的工作环境</h5><p><strong>你对组织的社会性要求分析：</strong></p>
<p>组织的社会性：这是什么含义？</p>
<p>一些人天生果断、活跃、他们喜欢大集体生活，经常是社交圈中的中心人物。在工作安排方面喜欢尽快完成。另一些人则完全不同，他们较为保守，不愿与人过多交往，通常只有几个亲密的朋友。很少超前，也不愿意和有野心的交往。同样的，有些企业的企业文化更倾向于积极进取，快速高效的完成工作，对事情结果的关注大于对人的关注。开会和交流不被认为是和工作相抵触的事情，在很大程度上他们本身就是工作。</p>
<p>另一些企业较为保守和独立。工作往往是关起门来完成的，活泼和有野心的行为不被这种企业的文化接受。社会和商业的关系网被认为是需要避免的杂事，而不是必要和增加工作趣味的一部分。</p>
<p>组织的社会性：如何判断？</p>
<p>这个组织是否喜欢用各种方式吸引有野心的人</p>
<p>办公室的设计是否允许职工有一定的私人空间</p>
<p>在这种文化中，成功在多大程度上取决于人际关系网</p>
<p>单独工作和与人合作的比率</p>
<p>在这种文化中事事去”压”在成功中占多大比重</p>
<p>在这种文化中有多少愉悦的氛围</p>
<p>对比花在分析和思考的时间与花在讨论与说服的时间</p>
<p>成功在多大程度上取决于职业的培训和专业</p>
<p><strong>你对组织的社会性要求不高</strong></p>
<p><strong>这表明你较为保守，喜欢在工作中拥有个人的空间。你喜欢这样的企业，他们尊重和强调个人的素质，并且奖励个人取得的成就，而不是只去建立社会关系网。<mark>你不愿把自己看作一个有野心的人，所以也不会喜欢那些鼓励员工有野心的企业</mark>。</strong></p>
<p><strong>你对组织的结构和细节关注度分析：</strong></p>
<p>组织的结构和细节关注度：这是什么含义?</p>
<p>一些人工作风格为非常有秩序的谨慎作风、系统地进行计划、关注细节。另一些人则工作风格随意，不喜欢计划、系统，也不太关注工作的最终质量。</p>
<p>类似的，一些组织/公司注重员工有严谨系统的工作作风，并关注工作细节。这种文化体现在成熟的工作程序、系统和工作计划。公司注重为最大化完善工作所做出的努力，而非”80-20”规则。多种行业里都拥有这种企业文化，更为突出的是在科学领域和工程工作中，或一些领域的管理阶层（例如：工厂的库存管理中”just in time”原则，机场运输等）。</p>
<p>另一些公司则不太关注细枝末节，也不太强调部门分工和按程序办事。他们更愿意追随感觉和人们之间的相互说服或影响，而不去力求追求完美。这种企业文化要求快速的反应，尽管所获信息可能还很有限（例如，贸易）。强调创新，（例如，广告公司）。</p>
<p>组织及对细节的关注度：如何判断？</p>
<p>在这种文化中你是否经常不得不去”粉饰”你的工作</p>
<p>“恰如其分”在这种文化中是否重要</p>
<p>有多少工作是在紧张的难以预料的工作期限下完成的</p>
<p>在多大程度上你能自主的制定适合自己的工作时间表和工作速度</p>
<p>是否经常需要在很短的时间里作决定和行动</p>
<p>企业是否提前计划和准备好应付各种不同的商业状况</p>
<p>工作环境是否整洁有序</p>
<p><strong>你对组织及对细节的关注度要求非常高</strong></p>
<p><strong>这表明你<mark>非常喜欢有序、组织性、纪律性强的企业文化</mark>。这种企业是以取得成绩为驱动力的“getting it right”。在这种高标准、严要求的文化中你会更快乐或者说更容易成功。这种企业往往不断的采用最好的做法，以便它的产品服务的质量与众不同。你会为成为一个行业领先企业中的一员而骄傲。</strong></p>
<p><strong>对组织的开放性和想象力</strong></p>
<p>含义：有些人天生富于想象力和好奇心，他们总是乐于接受新的观念和新的方法。另一些人则更为实际和朴实。同样的，有些企业的文化崇尚尝试各种新方法新方式。这种文化认为创新来源于错误的不断积累。</p>
<p>这类人敢于冒险，但往往没有一个清晰的计划去完成他们的目标。另一些企业宁愿花费更多的时间事先去理解和花费时间考验，不犯错误是他们的第一目标。把事情做好并且在基础领域能够展现你的能力是通往成功的关键。这些企业的文化特征是稳定和一成不变。</p>
<p>对组织的开放性和想象力：如何判断？</p>
<p>新想法和创造力是否在企业中受到重视和奖励</p>
<p>对于那些已经成功的事情在这个企业里是否还是不断的持续正常的发展</p>
<p>工作中是否有很多的变化</p>
<p>企业通常如何看待和平衡尝试新鲜事务中的得失和成败</p>
<p>企业是否愿意接受不循规蹈矩和具有创造力的职员</p>
<p>不论职工在企业中的位置如何，他们是否都愿意说出他们的想法</p>
<p><strong>你对组织的开放性和想象力要求不高。</strong></p>
<p><strong>表明你更倾向于那些忙碌的、注重实际操作的企业文化，用现有经过检验的方法处理事务。你崇尚经过时间检验的能力的有效性和可预测性。你<mark>不会从事风险极大的事情</mark>。你更欣赏按照传统方法按规定做事，不计时间代价的企业。你喜欢企业有明确目标、清晰的商业战略，并且能够尽可能有效和始终如一执行这些策略的企业文化。</strong></p>
<p><strong>你对组织的合作性和和谐性要求分析：</strong></p>
<p>对组织的合作性和和谐性： 这是什么意思？</p>
<p>一些人喜欢没有个人冲突和竞争的企业环境。在这种环境里友好、诚信、互相帮助是最基本的。这些个体通常有非常强烈的利他主义，他们认为他们的产品和服务社会价值更为重要。另一些人，喜欢竞争并把它看作一种美德，认为竞争是人的天性。</p>
<p>同样的，一些企业文化强调合作、关心他人、并且认为人性本善。这些企业往往通过要求大家一致的手段避免内部的冲突和竞争。另一些企业崇尚竞争精神，并且鼓励有利于企业发展的意见。他们鼓励你用怀疑和审视的眼光评论企业所做出的决定。在这种企业生存的人一般能够允许和接受人与人之间的不同意见。</p>
<p>对组织的合作性和和谐性：如何判断？</p>
<p>员工在这种企业文化里彼此了解的程度如何</p>
<p>优胜劣汰在这种企业文化里是否被崇尚</p>
<p>当你在路上遇到同事时大家是否都非常友好的打招呼，你是否感到温暖</p>
<p>大家看起来是真正的关心对方吗</p>
<p>内部竞争机制在多大程度上影响员工的成功与失败</p>
<p><strong>你对组织的合作性和和谐性要求非常高</strong></p>
<p><strong>这表明你很喜欢那种能培养友好、合作和“温暖”工作氛围的企业文化。办公室对你来说既是一个商业场合也是一个交朋友的地方。你有<mark>很强的利他主义情感</mark>，并且期望大多数同事有着此种情感或价值观。你倾向于没有冲突和争论，并鼓励相互尊重、支持的企业文化。那种崇尚内部竞争和敢闯敢干的企业肯定不是你成功的地方。</strong></p>
<p><strong>简而言之，如下情形的工作环境，会让你感觉更加如鱼得水：</strong></p>
<p>●在良好建构的任务上工作认真勤勉的人；</p>
<p>●提供安全感；</p>
<p>●工作结构清晰；</p>
<p>●安静平和；</p>
<p>●讲效率；</p>
<p>●考虑<mark>隐私权</mark>；</p>
<p>●服务导向。</p>
<h5 id="个人发展建议"><a href="#个人发展建议" class="headerlink" title="个人发展建议"></a>个人发展建议</h5><p>现在你对自己的人格类型和动力已经有了一个比较清楚的了解，但这还不够。“如何通过这些信息使你在这份工作上取得更大的成功”，这是关键所在。运用你的能力非常容易，你成功的秘诀在于：</p>
<p>●清楚地表达自己；●考虑尚不存在的可能之事；●设法更加灵活随和，表现自然一些。</p>
<p>个人发展建议是我们咨询师多年测评职业咨询和职业生涯规划的心得体会和经验总结，我们意识到以下的建议中有很多是难以完全照办的，但只要你花时间认真思考，一定会对你有极大的帮助和改变：</p>
<p>发展建议：</p>
<p>●在寻求未来工作上需要以积极、全局的态度处之；</p>
<p>●需要发展其决断性和直截了当；</p>
<p>●需要学会<mark>积极面对外界</mark>；</p>
<p>●需要<mark>以更加开放的态度对待其它的做事方式</mark>。</p>
<h4 id="解释性报告"><a href="#解释性报告" class="headerlink" title="解释性报告"></a>解释性报告</h4><blockquote>
<p><a href="https://www.apesk.com/mbti_step2/common2report/mbti2_report_admin_get.asp?id=188790&amp;grhr=gr&amp;pdf=yes" target="_blank" rel="noopener">https://www.apesk.com/mbti_step2/common2report/mbti2_report_admin_get.asp?id=188790&amp;grhr=gr&amp;pdf=yes</a></p>
<p>source/pdf/李博 - MBTI第二步解释性报告(后台) - 比较纯粹的ISFJ.pdf</p>
</blockquote>
<h5 id="扩展1：外向（E）的5个子维度与内向（I）的5个子维度倾向分布："><a href="#扩展1：外向（E）的5个子维度与内向（I）的5个子维度倾向分布：" class="headerlink" title="扩展1：外向（E）的5个子维度与内向（I）的5个子维度倾向分布："></a>扩展1：外向（E）的5个子维度与内向（I）的5个子维度倾向分布：</h5><p><img data-src="/pdf/images/image-20200321102745071.png" alt="image-20200321102745071"></p>
<p><strong>主动提出-被动接受（中间区域）</strong></p>
<ul>
<li>在社交场合中主动和你已经认识的人交谈，或你的角色是召集这次聚会。</li>
<li>在熟悉的场合中社交上表现自如，而张罗一个大型社交聚会则显得力不能胜。</li>
<li>能介绍人们相互认识，但不情愿这样做。</li>
</ul>
<p><strong>内敛（合倾向）</strong></p>
<ul>
<li><p>讷于言。</p>
</li>
<li><p>倾听自己的内心。</p>
</li>
<li><p>被他人视为宁静的甚至是默默无闻的。</p>
</li>
<li><p>不易于结识。</p>
</li>
<li><p>有时候会感觉自己是不是有点过于沉浸于自己的世界里了，偶尔也会有想找人聊的时候（但这时发现能倾述的人<mark>少的可怜</mark>）。</p>
</li>
</ul>
<p><strong>合群 - 寻求亲密（中间区域）</strong></p>
<ul>
<li><p>享受朋友聚会时的乐趣，也享受独处的空间。</p>
</li>
<li><p>聚会中能与陌生人交谈，但不是很喜欢这样。</p>
</li>
<li><p>对待朋友和对待熟人还是有一定程度的差别。</p>
</li>
<li><p>乐于参加各类组群，但更热衷参加不用见面的网络互动小组。</p>
</li>
<li><p>如果不是某Party的主角，觉得无所谓。</p>
</li>
<li><p>某活动没有被邀请，不会觉得失落。除非是自己特别想参与的。</p>
</li>
<li><p>有一定数量的熟人。</p>
</li>
</ul>
<p><strong>内省（合倾向）</strong></p>
<ul>
<li><p>不愿与人交流。</p>
</li>
<li><p>对于一些新的概念，更愿意上网查阅资料。</p>
</li>
<li><p>与其活跃地参与，不如冷静地观察。</p>
</li>
<li><p>相信书是最好的朋友。</p>
</li>
</ul>
<p><strong>热情-沉静（中间区域）</strong></p>
<ul>
<li><p>在熟悉的地方更有安全感。</p>
</li>
<li><p>不会害怕成为注意的焦点。</p>
</li>
<li><p>交谈时，不会表现木讷，但<mark>话不多</mark>。</p>
</li>
<li><p>生活还是平淡点好。</p>
</li>
<li><p>既不过分热情，也不会让人感到冷漠。</p>
</li>
</ul>
<h5 id="扩展2：感觉（S）的5个子维度与直觉（N）的5个子维度倾向分布："><a href="#扩展2：感觉（S）的5个子维度与直觉（N）的5个子维度倾向分布：" class="headerlink" title="扩展2：感觉（S）的5个子维度与直觉（N）的5个子维度倾向分布："></a>扩展2：感觉（S）的5个子维度与直觉（N）的5个子维度倾向分布：</h5><p><img data-src="/pdf/images/image-20200321103548814.png" alt="image-20200321103548814"></p>
<h6 id="具体-抽象（中间区域）"><a href="#具体-抽象（中间区域）" class="headerlink" title="具体-抽象（中间区域）"></a>具体-抽象（中间区域）</h6><ul>
<li><p>了解事实，但不拘泥于事实本身。</p>
</li>
<li><p>一般性对待事实解读和趋势分析。</p>
</li>
<li><p>既擅长阐述，也能进行推断。</p>
</li>
<li><p>在洞悉事实细节和把握大局上平衡得很好。</p>
</li>
<li><p>对于革新，既不过分热衷，也不会成为其阻力。</p>
</li>
</ul>
<h6 id="现实-想象（中间区域）"><a href="#现实-想象（中间区域）" class="headerlink" title="现实-想象（中间区域）"></a>现实-想象（中间区域）</h6><ul>
<li><p>不会过分沉浸于对情境的描述，也不会沉浸于无休止的推测中。</p>
</li>
<li><p>重视效率、实用性以及成本效益。</p>
</li>
<li><p>欣赏直接经验和具体结果。</p>
</li>
<li><p>认为良好的技术导致良好的结果。</p>
</li>
<li><p>被视为实事求是和明智。</p>
</li>
</ul>
<h6 id="实际-概念-（中间区域）"><a href="#实际-概念-（中间区域）" class="headerlink" title="实际 - 概念 （中间区域）"></a>实际 - 概念 （中间区域）</h6><ul>
<li><p>认为战略和执行同等重要。</p>
</li>
<li><p>对于行为结果和行为的内在性质同样关注。</p>
</li>
<li><p>既能耐心倾听哪怕是天马行空的猜测，也能耐心观察事实本身。</p>
</li>
<li><p>实际但不会抑制自己的好奇心。</p>
</li>
</ul>
<h6 id="体验-理论-（中间区域）"><a href="#体验-理论-（中间区域）" class="headerlink" title="体验 - 理论 （中间区域）"></a>体验 - 理论 （中间区域）</h6><ul>
<li><p>好奇与事物之间的因果关系，也乐于观察事物本身。</p>
</li>
<li><p>现象与解释都能吸引你的注意。</p>
</li>
<li><p>会<mark>矛盾于</mark>到底选择理论性课程还是实操性课程。</p>
<ul>
<li>不知道改通过看书/帖子还是实战课程来学习、提高编程技能</li>
</ul>
</li>
<li><p>不会对纯理论的东西感兴趣，必须紧密联系实际的才能提起你真正的兴趣。</p>
</li>
</ul>
<h6 id="传统（合倾向）"><a href="#传统（合倾向）" class="headerlink" title="传统（合倾向）"></a>传统（合倾向）</h6><ul>
<li><p>认同约定俗成的事物。</p>
</li>
<li><p>了解确凿不移的事实后感到安心。</p>
</li>
<li><p>因循守旧，<mark>安于现状</mark>。</p>
</li>
<li><p>不愿意改变/创新运作良好的事物。</p>
</li>
<li><p>骨子里依然崇尚“忠孝节义”</p>
</li>
</ul>
<h5 id="扩展3：思考（T）的5个子维度与情感（F）的5个子维度倾向分布："><a href="#扩展3：思考（T）的5个子维度与情感（F）的5个子维度倾向分布：" class="headerlink" title="扩展3：思考（T）的5个子维度与情感（F）的5个子维度倾向分布："></a>扩展3：思考（T）的5个子维度与情感（F）的5个子维度倾向分布：</h5><p><img data-src="/pdf/images/image-20200321104305185.png" alt="image-20200321104305185"></p>
<h6 id="同感（合倾向）"><a href="#同感（合倾向）" class="headerlink" title="同感（合倾向）"></a>同感（合倾向）</h6><ul>
<li><p>考虑问题的时候以他人的感受为重。</p>
</li>
<li><p>无法认可完全不考量人们情感上是否接受的方案。</p>
</li>
<li><p>容易过分陷入一份情感无法自拔。</p>
</li>
<li><p>容易在情感上拖泥带水。</p>
</li>
</ul>
<h6 id="合情（合倾向）"><a href="#合情（合倾向）" class="headerlink" title="合情（合倾向）"></a>合情（合倾向）</h6><ul>
<li><p>根据是否合情做决定。</p>
</li>
<li><p>富有同情心</p>
</li>
<li><p>很少因为讲原则而作出伤害他人感情的事。</p>
</li>
</ul>
<h6 id="随和（合倾向）"><a href="#随和（合倾向）" class="headerlink" title="随和（合倾向）"></a>随和（合倾向）</h6><ul>
<li><p>被认为很容易相处。</p>
</li>
<li><p>很少参与争论。</p>
</li>
<li><p>很少质问他人，与其这样不如用委婉些的方式可能效果更好。</p>
</li>
<li><p>愿意营造一种和谐的氛围。</p>
</li>
</ul>
<h6 id="批评-包容-（中间区域）"><a href="#批评-包容-（中间区域）" class="headerlink" title="批评 - 包容 （中间区域）"></a>批评 - 包容 （中间区域）</h6><ul>
<li><p>对部分事情持包容态度，但遇到一些在意的事情一定会刨根问底。</p>
</li>
<li><p>偶尔会感情用事。</p>
</li>
<li><p>偶尔会批评他人，必要的时候也并不吝惜赞美。</p>
</li>
<li><p>会以圆滑的策略提醒他人的错误。</p>
</li>
<li><p>深谙中庸之道。</p>
</li>
<li><p>有时候会很矛盾，心里想的和说出来的不同。</p>
</li>
</ul>
<h6 id="温和（合倾向）"><a href="#温和（合倾向）" class="headerlink" title="温和（合倾向）"></a>温和（合倾向）</h6><ul>
<li><p>人际关系是一切活动的出发点。</p>
</li>
<li><p>大部分时间不考虑逻辑上是否行得通。</p>
</li>
<li><p>心肠软。</p>
</li>
<li><p>和蔼可亲。</p>
</li>
<li><p><mark>更在意自己在他人心目中的位置</mark>而不是在意自己得到了什么。</p>
</li>
</ul>
<h5 id="扩展4：判断（J）的5个子维度与知觉（P）的5个子维度倾向分布："><a href="#扩展4：判断（J）的5个子维度与知觉（P）的5个子维度倾向分布：" class="headerlink" title="扩展4：判断（J）的5个子维度与知觉（P）的5个子维度倾向分布："></a>扩展4：判断（J）的5个子维度与知觉（P）的5个子维度倾向分布：</h5><p><img data-src="/pdf/images/image-20200321104702502.png" alt="image-20200321104702502"></p>
<h6 id="系统的（合倾向）"><a href="#系统的（合倾向）" class="headerlink" title="系统的（合倾向）"></a>系统的（合倾向）</h6><ul>
<li><p>若没有规划，就觉得很迷茫。</p>
</li>
<li><p>习惯把物品整理得有序而干净。</p>
</li>
<li><p>在计划行进中不习惯被打断。</p>
</li>
<li><p>不容易分心。</p>
</li>
<li><p>系统型的个人风格。</p>
</li>
</ul>
<h6 id="有计划-开放的-（中间区域）"><a href="#有计划-开放的-（中间区域）" class="headerlink" title="有计划 - 开放的 （中间区域）"></a>有计划 - 开放的 （中间区域）</h6><ul>
<li><p>喜欢工作时有计划，居家时灵活，反之亦然。</p>
</li>
<li><p>可以计划几个重要的个人目标但不是一切。</p>
</li>
<li><p>可能在享受当下和规划未来之间进退两难。</p>
</li>
</ul>
<h6 id="提早启动-压力推动-（中间区域）"><a href="#提早启动-压力推动-（中间区域）" class="headerlink" title="提早启动 - 压力推动 （中间区域）"></a>提早启动 - 压力推动 （中间区域）</h6><ul>
<li><p>徘徊于计划好还是不要计划好的决策困境。</p>
</li>
<li><p><mark>无所事事的时候会感叹人生没有目标</mark>。</p>
</li>
<li><p>能胜任应付多项任务，但并不享受这种状态。</p>
</li>
<li><p>在紧迫的时间压力下不会过分紧张，但不习惯长期承受这样的压力。</p>
</li>
<li><p>大部分事情会循序渐进，时间久了也会感到急躁。</p>
</li>
<li><p>比较中性看待随心所欲派和凡事计划派。</p>
</li>
<li><p>希望工作时有计划，生活中还是顺其自然好。</p>
</li>
</ul>
<h6 id="即兴-秩序-（中间区域）"><a href="#即兴-秩序-（中间区域）" class="headerlink" title="即兴 - 秩序 （中间区域）"></a>即兴 - 秩序 （中间区域）</h6><ul>
<li><p>生活中比较保守，但偶尔会向往一些新的体验。</p>
</li>
<li><p>有秩序的生活会让你感到安心，但缺乏新意又会让你感到些许遗憾。</p>
</li>
<li><p>以一种兼容并包的姿态面对传统保守派合标新立异派。</p>
</li>
<li><p>接受常规的传统生活，也接受多元化。</p>
</li>
<li><p>认同制度的作用，也相信即兴的构思会带来创造力。</p>
</li>
</ul>
<h6 id="突发的-有方法的-（中间区域）"><a href="#突发的-有方法的-（中间区域）" class="headerlink" title="突发的 - 有方法的 （中间区域）"></a>突发的 - 有方法的 （中间区域）</h6><ul>
<li><p>有时候会作出很具体的计划，有时候会遵循“随他去吧”听任事态自由发展。</p>
</li>
<li><p>对待突发事件既不回避，也不擅长解决。</p>
</li>
<li><p>很少贸然行动，但内心有这样的冲动。</p>
</li>
<li><p>在下定决心的时候显得<mark>犹豫不决</mark>。</p>
</li>
<li><p>有时候会矛盾与到底该选择传统而安定的生活，还是选择挑战刺激也有风险的生活。</p>
</li>
</ul>
<h5 id="应用第二步结果进行沟通"><a href="#应用第二步结果进行沟通" class="headerlink" title="应用第二步结果进行沟通"></a>应用第二步结果进行沟通</h5><p>除了下表，每种类型的沟通还应当包括：</p>
<ul>
<li><p>告知所必需的信息内容和细节。</p>
</li>
<li><p>适当控制和把控沟通时的表情和情绪。</p>
</li>
<li><p>注意自己的沟通方式与其他沟通方式的差异及融合。</p>
</li>
<li><p>小心“说者无心，听者有意”的误判导致的沟通隐患。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>我的子维度结果</th>
<th>沟通风格</th>
<th>有益提示</th>
</tr>
</thead>
<tbody><tr>
<td>主动提出-被动接受（中间区域）</td>
<td>乐意引见人们相互认识，如果没有其他人这样做的话。</td>
<td>在决定是否担当主动提出或者被动接受角色方面，对情境要很敏感。</td>
</tr>
<tr>
<td>内敛</td>
<td>只顾埋头干活。</td>
<td><mark>要</mark>知道有时候<mark>沟通</mark>可以减少很多不必要的工作量。</td>
</tr>
<tr>
<td>内省</td>
<td>对沉静地观察感到舒坦。</td>
<td><mark>学会参与</mark>，把自己所想的表达出来。如果觉得困难，可以从最容易的开始。</td>
</tr>
<tr>
<td>热情-沉静（中间区域）</td>
<td>情绪视对方的热情程度而定。</td>
<td><mark>学会宠辱不惊</mark>，情绪不受他人影响。</td>
</tr>
<tr>
<td>具体-抽象（中间区域）</td>
<td>思绪游离于细节和分析中。</td>
<td>尝试<mark>分离执行</mark>：深入细节勘探一段时间，然后再花时间好好总结。</td>
</tr>
<tr>
<td>随和</td>
<td><mark>过分</mark>追求气氛的友好。遇到争议习惯搁置，不愿得罪人。</td>
<td>明白有争议有时候不见得是坏事，相反有时候只有争论后才能看清事实的真相。</td>
</tr>
<tr>
<td>批评-包容（中间区域）</td>
<td>对于该批评的时候显得犹豫不决。</td>
<td>辨别孰是孰非，坚定自己的立场。</td>
</tr>
<tr>
<td>温和</td>
<td>温婉、柔和。</td>
<td>学会理解公司的某些强硬措施，特定情况下也许只有这些方式才有效。</td>
</tr>
<tr>
<td>有方法-突发的（中间区域）</td>
<td>在多种选择面前显得<mark>犹豫不决</mark>。</td>
<td>做好计划后，就按计划执行，不需三心二意。</td>
</tr>
</tbody></table>
<h4 id="爱情报告"><a href="#爱情报告" class="headerlink" title="爱情报告"></a>爱情报告</h4><blockquote>
<p><a href="https://www.apesk.com/mbti_step2/common2report/mbti1_report_love.asp?id=188790&amp;grhr=gr" target="_blank" rel="noopener">https://www.apesk.com/mbti_step2/common2report/mbti1_report_love.asp?id=188790&amp;grhr=gr</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Meilin Reservoir</title>
    <url>/2020/06/12/Meilin-Reservoir/</url>
    <content><![CDATA[<img data-src="https://n.sinaimg.cn/translate/20171106/U9H_-fynnnsc7304414.jpg" width="100%"/>

<a id="more"></a>

<iframe  width='100%' height='700' frameBorder='0' src='https://libo9527.github.io/static/map/amap/202006/all/index.html'>
</iframe>

]]></content>
      <categories>
        <category>Tour</category>
      </categories>
      <tags>
        <tag>Tour</tag>
      </tags>
  </entry>
  <entry>
    <title>Miracles in Namiya General Store</title>
    <url>/2019/01/17/Miracles-in-Namiya-General-Store/</url>
    <content><![CDATA[<img data-src="https://wx3.sinaimg.cn/crop.7.0.1067.600/dd256fbaly1fy5cenajvzj20u00gotbi.jpg" width="100%"/>

<a id="more"></a>

<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>因为先看了电影，而且是中国版的，然后才看的书。有了先入为主的感觉，读的时候满脑子都是回顾电影的情节。读关于翔太，郭也，幸平他们三个在店里投信取信的时候有种侦探小说的紧张感，可能是因为读的时间刚好是在夜深人静或是黎明拂晓的缘故，气氛给的足。</p>
<p>有些小节会直接转换故事主角，以为排版出错了。读完后才知道一个个故事联系很紧密，通过解忧杂货店的时光穿梭情节让所有故事情节连接起来形成一个闭环。貌似所有这类小说或者电影都在努力将故事线连成环，目前不知道该怎么描述这种手法。</p>
<p>发现书与电影的好像有这样一个区别。电影的主角儿就是翔太，郭也，幸平；而看书的时候每切换一个故事就有每个故事的主角。可能是因为书上每个故事都会描写自己主角的心理活动，而电影转换场景后没有太多表现主角心里活动的情节。</p>
<p>每个故事都很温暖，对于任何问题，浪矢都认真的给出自己的回答。这种暖心的态度，让人觉得自己给浪矢写信也能得到这种温柔以对的态度。从大学时代就很想能交一个笔友之类的，就想在这个世界有一个只有通过文字交往的朋友，肆无忌惮的吐露心声。可是到现在也没能实现这个愿望，听朋友说有类网站好像就是能写信给全世界的人，但还没尝试过，挺想试一试的。</p>
<p>关于烦恼，每个人都有无情物尽的事值得烦恼，我也一样，但如果能有个智者给出解答是件多么幸福的事，或许能有个倾听的也是极其幸福的事。也如浪矢所言，每个咨询者其实都有自己的答案。关于烦恼的答案终究还是要通过自身的仔细思考来给出答案，倾听者可能是促使和帮助我们自己认真思考的人，不要随便的将烦恼抛到一边不理会，或许有些徒劳的烦恼应该被直接抛弃吧。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>其实所有纠结做选择的人心里早就有了答案，咨询只是想得到内心所倾向的选择。最终的所谓命运 还是自己一步步走出来的。</li>
<li>人与人之间情断义绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。</li>
<li>人的心声是绝对不能无视的。</li>
<li>人与人之间的羁绊是何等脆弱。</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>No Longer Human</title>
    <url>/2019/01/10/No-Longer-Human/</url>
    <content><![CDATA[<img data-src="http://img3m5.ddimg.cn/56/4/23761145-1_w_2.jpg" width="100%"/>

<a id="more"></a>

<h2 id="总体感想"><a href="#总体感想" class="headerlink" title="总体感想"></a>总体感想</h2><p>读完整本书，整体上有两个感觉。1. 太丧。2. 印刷质量真差。</p>
<p>无赖派大师，听起来很厉害的样子，我以为并不像字面那样负面，查了才知道，真的是很负能量的派别。</p>
<blockquote>
<p>无赖派指的是太平洋战争结束后的一九四六年到一九四八年间活跃于日本文坛的一个重要作家流派。但是严格来讲，这一派的作家并没有像其它派别的作家那样组成文艺团体或出同人杂志，只是因为在<strong>社会秩序混乱</strong>和<strong>价值体系崩溃</strong>的战后那个特殊年代，他们的作品风格正好呈现出相同的特征和倾向，才被日本评论界和文学界统一冠上了无赖派的头衔。</p>
<p>所谓无赖派就是指作家有着反抗权威的意识，对生活采取<strong>自嘲</strong>和<strong>自虐</strong>的态度，专写<strong>病态</strong>和<strong>阴郁</strong>的东西，具有<strong>颓废</strong>倾向。</p>
</blockquote>
<p>读完后简直了，真的是太<strong>自虐</strong>、<strong>病态</strong>、<strong>抑郁</strong>了。刚好开始看这本书的时候正碰上我最低谷的时候，感情的伤还未愈合，又新增考研二战失败的疤。看到一半就看不洗去了，也是这个月开始做新一年各种计划的时候，想硬着头皮把它快快读完算了。</p>
<p>查了历史背景后再反观本书，有增加了一份替活在战后混乱年代的人们感到悲哀的情绪。</p>
<p>文采上并不觉得有什么特别突出的地方，可能是因为在没有了解具体历史背景的情况下读的，所以没有仔细体会文字背后的深意。读完之后我甚至没有一句印象深刻的话，只留有一种极度颓废的感觉，再就别无其他了。</p>
<p>回过头再看的时候，发现书背面那些名家推荐的理由写的很中肯。</p>
<blockquote>
<p>他的痛苦在于它用心看着漆黑的世界。 ——鲁迅</p>
</blockquote>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>太宰治一生充满了传奇色彩，出身豪门，师从名师。五度自杀，四度殉情未遂，三十九岁时与最后一位情人投水自尽。极度的自尊心和容易受伤的感受性构成了太宰治一生的性格基调，这样的性格的确太过于纯粹和脆弱。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>我不相信神的爱，只相信神的惩罚。</li>
<li>只是一切都将逝去。</li>
<li>回首往昔，我的人生充斥着耻辱。</li>
<li>生而为人，对不起 ——《二十世纪棋手》</li>
<li>就算可以相信地狱，也怎么也无法相信天国的存在。</li>
<li>所谓的世间，不就是个人吗？</li>
<li>人是绝对不会服从于他人的。</li>
<li>我的不幸乃是一个人缺乏拒绝能力的不幸。</li>
<li>就像玩扑克牌一样，一旦把负的全都收齐了，也就变成了正的。</li>
<li>在行善时，必须随时心存歉意。因为没有什么比行善更刺伤人的了。——瓦莱里</li>
<li>人活在这世上，真是件不容易的事，到处都有枷锁来束缚住你，哪怕是稍微动一下，也会冒出血来。</li>
</ul>
<p>希望我能清晰又糊涂的过一生。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Norms and Skills of G Suite</title>
    <url>/2020/02/21/Norms-and-Skills-of-G-Suite/</url>
    <content><![CDATA[<img data-src="https://meticul.com/blog/assets/g_suite-small-1.png" width="100%"/>

<a id="more"></a>

<blockquote>
<p>G Suite是 Google 在订阅基础上提供的一套云计算生产力和协作软件工具和软件。 它包含Google 广受欢迎的网上应用，包括 Gmail、Google 云端硬盘、Google 环聊、Google 日历和 Google 文档。——<a href="https://zh.wikipedia.org/wiki/G_Suite" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<h2 id="Google-Calendar"><a href="#Google-Calendar" class="headerlink" title="Google Calendar"></a>Google Calendar</h2><h3 id="主日历"><a href="#主日历" class="headerlink" title="主日历"></a>主日历</h3><p>Google Calendar 预设了默认的主日历，在网页版上名字是【谷歌账户名】，在 Android 设备上名字叫【活动】，而且网页版是可以修改这个日历的名字的，但是不会同步到 Android 设备中（即不管网页版改成什么，Andorid 设备上始终是【活动】），此外主日历是无法删除的！</p>
]]></content>
      <categories>
        <category>Norms and Skills</category>
        <category>G Suite</category>
      </categories>
      <tags>
        <tag>Norms and Skills</tag>
        <tag>G Suite</tag>
      </tags>
  </entry>
  <entry>
    <title>Norms and Skills of Writing Blog</title>
    <url>/2020/02/16/Norms-and-Skills-of-Writing-Blog/</url>
    <content><![CDATA[<img data-src="https://blog.hubspot.com/hubfs/blog-writing-for-SEO.jpg" width="100%"/>

<a id="more"></a>

<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="纯色背景填充"><a href="#纯色背景填充" class="headerlink" title="纯色背景填充"></a>纯色背景填充</h3><blockquote>
<p><a href="https://theme-next.org/docs/tag-plugins/label" target="_blank" rel="noopener">Label | NexT</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>{ % label @示例 1 % }</td>
<td><span class="label default">示例 1</span></td>
</tr>
<tr>
<td>{ % label default@示例 2 % }</td>
<td><span class="label default">示例 2</span></td>
</tr>
<tr>
<td>{ % label primary@示例 3 % }</td>
<td><span class="label primary">示例 3</span></td>
</tr>
<tr>
<td>{ % label success@示例 4 % }</td>
<td><span class="label success">示例 4</span></td>
</tr>
<tr>
<td>{ % label info@示例 5 % }</td>
<td><span class="label info">示例 5</span></td>
</tr>
<tr>
<td>{ % label warning@示例 6 % }</td>
<td><span class="label warning">示例 6</span></td>
</tr>
<tr>
<td>{ % label danger@示例 7 % }</td>
<td><span class="label danger">示例 7</span></td>
</tr>
<tr>
<td>~~{ % label default @示例8 % }~~</td>
<td><del><span class="label default">示例8</span></del></td>
</tr>
<tr>
<td>&lt;mark&gt;esse&lt;/mark&gt;</td>
<td><mark>esse</mark></td>
</tr>
</tbody></table>
<h3 id="中心引用"><a href="#中心引用" class="headerlink" title="中心引用"></a>中心引用</h3><blockquote>
<p><a href="https://theme-next.org/docs/tag-plugins/#Centered-Quote" target="_blank" rel="noopener">Centered Quote ｜ NexT</a></p>
</blockquote>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% centerquote %&#125;文字&#123;% endcenterquote %&#125;</span><br><span class="line">&lt;!-- Tag Alias --&gt;</span><br><span class="line">&#123;% cq %&#125;文字&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><blockquote class="blockquote-center"><p>文字</p>
</blockquote>

<h3 id="页面内跳转链接"><a href="#页面内跳转链接" class="headerlink" title="页面内跳转链接"></a>页面内跳转链接</h3><ol>
<li><p>页面内定义一个锚，及要跳转到的位置</p>
<p><code>&lt;span id=&quot;1&quot;&gt;XXX&lt;/span&gt;</code></p>
</li>
<li><p>使用如下格式定义链接即可</p>
<p><code>[跳转到XXX](#1)</code></p>
</li>
</ol>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h4><blockquote>
<p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">Hexo博客搭建之在文章中插入图片</a></p>
</blockquote>
<p>将图片统一放在 <code>source/post_image</code> 文件夹中，通过以下地址引用。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](/post_image/xxx.jpg)</span><br></pre></td></tr></table></figure>

<h3 id="缩放、截取"><a href="#缩放、截取" class="headerlink" title="缩放、截取"></a>缩放、截取</h3><div class="note ">
            <p>博客中经常要用到网络上的一些图片，但又需要在此基础上进行一些改动，而且并不想通过图片编辑软件进行编辑再上传图片服务器这种复杂耗时的方式。</p>
          </div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%;</span></span></span><br><span class="line"><span class="tag"><span class="string">            height: 300px;</span></span></span><br><span class="line"><span class="tag"><span class="string">            background-image: url(http://xxxx/xxx.xxx.jpg);</span></span></span><br><span class="line"><span class="tag"><span class="string">            background-size: 727px 248px;</span></span></span><br><span class="line"><span class="tag"><span class="string">            background-position: 0px 0px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过调整相应属性即可</p>
<ul>
<li><p>background-size</p>
<p>作用：控制缩放，尽量等比数列缩放</p>
<p>取值：[x 坐标，y 坐标]</p>
<p><img data-src="/post_image/background-size-x-y.jpg" alt=""></p>
</li>
<li><p>background-position</p>
<p>作用：背景图片的初始位置</p>
<p>取值：[x 坐标，y 坐标]</p>
</li>
</ul>
<h3 id="默认图片"><a href="#默认图片" class="headerlink" title="默认图片"></a>默认图片</h3><div class="note ">
            <p>博客中的图片如果加载失败则使用默认图片代替。</p>
          </div>

<blockquote>
<p><a href="https://blog.csdn.net/HaHa_Sir/article/details/78667659" target="_blank" rel="noopener">https://blog.csdn.net/HaHa_Sir/article/details/78667659</a></p>
</blockquote>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><blockquote>
<p><a href="https://theme-next.org/docs/tag-plugins/group-pictures" target="_blank" rel="noopener">Group Pictures | NexT</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% grouppicture [group]-[layout] %&#125;&#123;% endgrouppicture %&#125;</span><br><span class="line">&#123;% gp [group]-[layout] %&#125;&#123;% endgp %&#125;</span><br><span class="line"></span><br><span class="line">[group]  : Total number of pictures to add in the group.</span><br><span class="line">[layout] : Default picture under the group to show.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>例如</strong></p>
<div class="tabs" id="group-pictures"><ul class="nav-tabs"><li class="tab active"><a href="#group-pictures-1">Code</a></li><li class="tab"><a href="#group-pictures-2">Result</a></li></ul><div class="tab-content"><div class="tab-pane active" id="group-pictures-1"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% grouppicture <span class="number">5</span>-<span class="number">3</span> %&#125;</span><br><span class="line">  ![](/post_image/background-size-x-y.jpg)</span><br><span class="line">  ![](/post_image/background-size-x-y.jpg)</span><br><span class="line">  ![](/post_image/background-size-x-y.jpg)</span><br><span class="line">  ![](/post_image/background-size-x-y.jpg)</span><br><span class="line">  ![](/post_image/background-size-x-y.jpg)        </span><br><span class="line">&#123;% endgrouppicture %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="group-pictures-2"><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img data-src="/post_image/background-size-x-y.jpg" alt=""></div><div class="group-picture-column" style="width: 50%;"><img data-src="/post_image/background-size-x-y.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img data-src="/post_image/background-size-x-y.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img data-src="/post_image/background-size-x-y.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img data-src="/post_image/background-size-x-y.jpg" alt=""></div></div></div></div></div></div></div>

<h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><blockquote>
<p><a href="https://theme-next.org/docs/tag-plugins/pdf" target="_blank" rel="noopener">PDF | NexT</a></p>
</blockquote>
<ol>
<li><p>将 pdf 文件统一放在 <code>source/pdf</code> 目录中</p>
</li>
<li><p>文章里使用如下方式引用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><div class="note success no-icon">
            <p>在写博客搭建的文章时，不知道如何能够更好的表现需要配置内容和配置后的效果。一次偶然看到 <a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">mermaid|GitHub</a> 的README 得到启发，使用 table 布局就可以了。</p>
          </div>

<table>
<tr>
    <td><pre>
graph TD
A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]</pre></td>
    <td align="center">
        <img data-src="https://raw.githubusercontent.com/mermaid-js/mermaid/master/img/gray-flow.png" />
    </td>
</tr>
</table>

<h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><blockquote>
<p><a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">mermaid|GitHub</a></p>
<p><a href="https://theme-next.js.org/docs/tag-plugins/mermaid.html" target="_blank" rel="noopener">Mermaid | NexT</a></p>
</blockquote>
<blockquote class="blockquote-center"><p>Generation of diagram and flowchart from text in a similar manner as markdown.</p>
</blockquote>

<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><pre class="mermaid" style="text-align: center;">
            graph TD
            
A[Hard] -->|Text| B(Round)

B --> C{Decision}

C -->|One| D[Result 1]

C -->|Two| E[Result 2]

          </pre>

<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><table>
<thead>
<tr>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>{ % video url % }</td>
<td><video src="https://example.com/sample.mp4" preload="metadata" controls playsinline poster="">Sorry, your browser does not support the video tag.</video></td>
</tr>
</tbody></table>
<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><blockquote>
<p><a href="https://theme-next.org/docs/tag-plugins/button" target="_blank" rel="noopener">Button | NexT</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% button url, text, icon [class], [title] %&#125;</span><br><span class="line">&lt;!-- Tag Alias --&gt;</span><br><span class="line">&#123;% btn url, text, icon [class], [title] %&#125;</span><br><span class="line"></span><br><span class="line">url     : Absolute or relative path to URL.</span><br><span class="line">text    : Button text. Required if no icon specified.</span><br><span class="line">icon    : FontAwesome icon name (without &#39;fa-&#39; at the begining). Required if no text specified.</span><br><span class="line">[class] : FontAwesome class(es): fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5x</span><br><span class="line">          Optional parameter.</span><br><span class="line">[title] : Tooltip at mouseover.</span><br><span class="line">          Optional parameter.</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>{ % button #, 按钮文字 % }</td>
<td><a class="btn" href="#">按钮文字</a></td>
</tr>
<tr>
<td>{ % button #, 带图标的按钮, home % }</td>
<td><a class="btn" href="#"><i class="fa fa-home"></i>带图标的按钮</a></td>
</tr>
<tr>
<td>{ % button #, 带间隙的图标按钮, home fa-fw % }</td>
<td><a class="btn" href="#"><i class="fa fa-home fa-fw"></i>带间隙的图标按钮</a></td>
</tr>
<tr>
<td>{ % button #, 带标题的按钮, , 标题 % }</td>
<td><a class="btn" href="#" title="标题">带标题的按钮</a></td>
</tr>
<tr>
<td>文字文字{ % button #, 文字围绕的按钮 % }文字文字</td>
<td>文字文字<a class="btn" href="#">文字围绕的按钮</a>文字文字</td>
</tr>
<tr>
<td>{ % note info no-icon % }<br/>{ % btn #, 嵌入note中的按钮 % }<br/>{ % endnote % }</td>
<td><div class="note info no-icon">
            <p><a class="btn" href="#">嵌入note中的按钮</a>    </p>
          </div></td>
</tr>
</tbody></table>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ul>
<li>需要在博文的 <a href="https://hexo.io/zh-cn/docs/front-matter#JSON-Front-matter" target="_blank" rel="noopener">Front-matter</a> 中开启 <code>mathjax</code></li>
<li>公式里的运算符号两侧尽量加上空格，否则可能会导致渲染失败的情况</li>
</ul>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="Error-expected-end-of-comment-got-end-of-file"><a href="#Error-expected-end-of-comment-got-end-of-file" class="headerlink" title="Error: expected end of comment, got end of file"></a>Error: expected end of comment, got end of file</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unhandled rejection Template render error: (unknown path)</span><br><span class="line">  Error: expected end of comment, got end of file</span><br><span class="line">    at Object._prettifyError (&#x2F;Users&#x2F;gzhennaxia&#x2F;Documents&#x2F;GitHub&#x2F;libo9527.github.io&#x2F;node_modules&#x2F;nunjucks&#x2F;src&#x2F;lib.js:36:11)</span><br><span class="line">    at Template.render (&#x2F;Users&#x2F;gzhennaxia&#x2F;Documents&#x2F;GitHub&#x2F;libo9527.github.io&#x2F;node_modules&#x2F;nunjucks&#x2F;src&#x2F;environment.js:542:21)</span><br></pre></td></tr></table></figure>

<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>博文中出现 <code>{</code> 和 <code>#</code> 连在一起时报这个错。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>用 <code>&lt;span&gt;</code> 标签将其分开即可，即 <code>&lt;span&gt;{&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;</code>。</p>
]]></content>
      <categories>
        <category>Norms and Skills</category>
        <category>Blog Writing</category>
      </categories>
      <tags>
        <tag>Norms and Skills</tag>
        <tag>Blog Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>Prepare-for-spring-travel</title>
    <url>/2025/07/22/Prepare-for-spring-travel/</url>
    <content><![CDATA[<img data-src="https://ws1.sinaimg.cn/large/005M2pcYgy1fzg88oizf2j30b607e0ug.jpg" width="100%"/>

<a id="more"></a>

<h2 id="衣"><a href="#衣" class="headerlink" title="衣"></a>衣</h2><h2 id="食"><a href="#食" class="headerlink" title="食"></a>食</h2><h2 id="住"><a href="#住" class="headerlink" title="住"></a>住</h2><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2>]]></content>
  </entry>
  <entry>
    <title>PAT B1027</title>
    <url>/2019/01/19/PAT-B1027/</url>
    <content><![CDATA[<img data-src="cover" width="100%"/>

<a id="more"></a>

<p>设 h 为三角形的高度</p>
<p>一个三角形需要 * 的个数 s = 1 + 3 + 5 + … + (2h -1) = 2h^2</p>
<p>一个沙漏需要 2h^2 - 1 个 *</p>
<p>将沙漏的输出看作一个二位数组 <code>arr[2h-1][2h-1]</code></p>
<p>用两层for循环来打印，i为行下标，j为列下标。</p>
<p>则空格所再的点满足<code>i &lt; j &amp;&amp; i + j &lt; 2h - 2 || i &gt; j &amp;&amp; i + j &gt; 2h -2</code></p>
<p>i = j 和 i + j = 2h - 2 以二位坐标轴显示就是以2h - 2为边长的正方形的两个对角线。</p>
]]></content>
  </entry>
  <entry>
    <title>Reading</title>
    <url>/2020/02/24/Reading/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Third warning: This content is personal, please skip it." data-whm="Fourth warning: This content is personal, please skip it."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Warning again: This content is personal, please skip it." /><label>Warning again: This content is personal, please skip it.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="9ae4bd82d6695fbcb2e1c0d144e9375c64a42dd35001746e90f27ad33d85dfe8">e648fa61398e770b9057ad49cacb66a6420c704c1233ef9fc49a482ec83ede097b008f6580d850df49b01aed24e19f8b99836b93ff0463128a2829f7decb1b7216856f4ba8690428d52704b1ff079ce0497c03e5fe1a4b02a126878f822fffd0f4dcda5788db2681b118944214aa5bc74fb47e7ca82d0d94ca4d459a8a15706b845dc530cf5da7c22079f006ce09141d52e1d3fc5b8d26f6d5eb14756685e467046278c0116d8d615ef7585f9a3d177975f1cc640ead89a79708946ecf2810b674499036428deb0432d246d97b64cd67ddcc407d45a8426269e43dd19369113801ce6a60587a9d205c330229d6004f769019c0aa516f4756644b22bde6229d717fe20b92c152fdf25786a38eb3c3cb60c06a5f45451cf70eba881a6bd7752f11692267abb0dc0bd2620423abce1ee2ef887cde5a31237ac98135c237134c2169470d4ad833c5eb690578deafff9b5e91f48c7b94bd4d7dda593952cc9a95a40430f1019230ebffb0309eb599a3377d1987930269151fa65ce0081fd91b94046d00b18911c11dbf1adb60edc4d64310a36c6d39fe6c899a970f808bb81d27952874367b0f5a81c65ecdbb7c22862252c38ce7b07edc70b07960e6632b5153bbe513af6dddfd09ae968072177576a74c608d9257e9508d989067660a4d1fe65cf63c8fe96c3cd4f734802be57eb92bb9b1633823371c28d54f226c7ded911d11a6f8bf33efeb3cd500689221e74c9f46350b5bf3ff94b704bad361f80e372b732f335ce878e7b40c1753cb19ed25edc8a92950f023be274e53790b7fabcb8460c8ca05420cdbf1b8dc7485807cf395869666e60b9bdd3300cc79d0816d9f010e587afa2f8282f540ecead32f0af600f606c8522733faf6380ae632495ba537869e334cb8f01cf05f2fef6e6599bdba22e3d6eb023a98282b73b95bf3afb236c91463da54f6079b1a01add49e70545707b731a7d53bb452bae72f1abb682f638c01826d762659c7e3a764756e94b06336da7b91362168f70b6c561de1d230e7252ad1dbeda922e1c7361dd09cac4b32f91f59dc97fed4f3112035b5a9b90a19c74d1c69c764257eef67876f2b255daa870386626632a7333fe4b207a1f4205f45dae4cc66bc520981389c38938944a125f9c027c8b2af93012bad88c1fd7a500fbbf3572ec8f856c54a0ed6da5d1052da6a7d0b300b2849763db69995cc629f02631d1f18c7bfb4bcef2a00d07a0dc913a67559df7a2d98567e85ff10d7f8a261fa7d8aaf26f8b2271f3e3e5002d24ac89e6a5d44b2465bd0cf8139da85dbd58a63cd9a27e36e77e112ceb200a8b99f7ade6b5d72b897eff141cff9987968595476d1d935d39f525ca7afc488ff4b35582fc4f3f3501cc0cf1725a4c654d2a26131557a08ce90cecc8bacb2d8e8aa685340ac1a47a74482a4944f330482ce5b1b723c603c70aa07ac6bbae8aa75a33ea30c668551b5d198d324e02ee4c1751c8da63145d28b7c7d8bfc0934d9166f8ecaaed5a1f3e21488f608dac40475ee3718525043e9f7a365e334bc77b9463d850a61201831d759fa433a6f86094de86b8b94dce857d129e192a43c80f881f490b4be95257153eefdfac0ccd8849b0297a8ac6655ff665190dd76974ba8d469a66d44e101062fd1f6d92e0913244ee711f05deb2991f99ecc9ac36a09f0816fac614f5c043539ea20a344354ece5141928aa6f1e9f839d060bf070bc7ac671e0c61cdf6e004cf599705eec66b2e752d8cf0f712efc0878c5127361e52b4e769c5769dbab00dd9326bea63d79eef97fcbdc5ddea13fd5ebeebbce83b1bbafbe70b14068e0c37550a4cd606abc94b9bcce86d2a74f9327e2ef80bca9f1d02e4f3292ab7914cc1486f7e355ac6875a591ecd5ca87988b8c5d88a5e8a8132c211b5114aa23a0418a77be7b81a15b555af3b1b3f10ea067c42e351f981d0816b02931f5ba3ccac79927eda5bd78aae3fc0cc78073fd7448fac0e14ce713915c7651a3802afcb04433f55b9bfe67eb7e97bcb4d056219b2db8d2b743232b61ad0158d8681c779590e92310b1077fd75950719dd16f1415ad10212da560dfd31c5582b7e7cd7915e57301934c67d77992812f8bffe1fb89b7057f8ec9761d825a4f9285796f6079d6489be2ca2bba0cd7eb5c39da1e1ada485d9b118248e54e3fa5a2002cacc377fd274bd1a57ed1a2add634c62bda1147442ac73653b0a1f66215bf79e7bcbae64e6d121f439bb38aa40e3d5861dd3423d68236b42500c6ebde9ea69c69ac6608c1920b591add983e0d5b5fcb0bc2b98f06788f1e11263814d71a7cb780fd08c5368b1bc6b829bdba9b472bd060c39ee08bacb91cc2588124fdb090c8242d4951679f4dfe7959301ab4ce71dd6f4b902598a21c45b4333afc930f4412db03ca497f3cbb194ce4a4d1cedeaae32a2a2771c388968cf6f1a0a52e537445026a4213421a35c8edb5ee91198da09b0dba86c760dad42874e5f9280cabc16ded6189feb6cc736b18910d302e46a317cc1a62f8e13ee897aca3cbe3c2cffe857a316494939e32ab82d19ed8a5f3dfaf738bd64fbed3fc4d078f1698915ea123d52f72c1bb0a38034e3ce6930482f0bb45e3155d2f3a2cc30a42a4ac242cd362c4dca349572107ad23566e98ee4d14a5115b981987113ecc0b675b8fbf580b953cd22117cd3c63243915c3096ffcc6aa3194198a4468ba0b4a6e4a6fb185846ae5f022d92d70ba6923ea585ff68452bfbd2a5e5b3d9eb197afa7c18e9444b8b3d723ed4f479e8d89024089d3ebf0608736134033b7e5a8d9790c6f4c5ecefb0797913398c8fb7d5f2090cb3db6b3d98fd838197b68fcce30e51d9a71be1f9c67c062253318775bd75f07cbf3325bd69a58d9c8343c87b5332961974089fc237497a62ba4f4edf134bec10e253a6dc1a43f9fcfc8a747b8410f17b2aa6ed6f2e174057166e9bb3243ff3276071b21177c5b989cd8496a132511bc370c055cad37829009123ef336debfb02bbda43d4eb1084af15ffb6ed0ef4e846477ab4d6050eb81d1ebbc7d22d2303b7298bcbdb045584503e2b58de84c876e87e3857b4e4f95aac2327e842fa4c495e45cb7b5c81b12cbc26941b3bb215826a7f6326957496d976bb1cd2eed12e9f2de27df5a9f84bbf7c516dd7874bda85f524308e2a75d7a80a900fcae2652f76b6cc7c20d5f79b7bb7c0d4566b062548d771c43331de04b371891d8f6d859f6a46815bc6d944c11e877eb321b33a7ca3505b3731b0ae84630d867aa46895a6c47307cc1a109548ee4f42ff9c152d5fe02797c518d89ba85065bea6a5b615f22b8c4df3dc2dea88a7ac1228d90caf938dc26ae7bcdf096527878adc5260a79a2f65ec44c53cc44ba9bfebd097658dbfa9e094eb8fc8abf36814cb02e3680905df22ef3786663fd06df02cfc8e87c5ac6b79a6813253b0221baeeb4feedc5b73bd346dbc9a457200535f4be472d052c1d8984fbdbbc1a1751691b1fe1b992917f727949c75ff126f8688e18f5406a4c4e933cd49de29aba6d86a04e7c8e3afaa61d1298622d10a490460919e714df24f57982f89f3f80bb184131543e5021c7b16d8c59bf96c33c977faaa7835ac6586a42158b78c6b864c32b495d5596877cb8652df363ddc9417ced42439ccfae6647648b16d05fd3320313735fb5b6eb7fabb6cf2766cab30f8b5afed6386765ef4dd36f833fffe1bf1b0f7df9f781e357827f8dc3af6f0e3a9cbcea6ae8c78810d5a965e05a408256243712cace912d817ee4ab29d2e3df78602c3864397de9671901e5ef93e3c5ec5b05e46fc4684cc839676f15959926bdb0609c02f7edcc1d4297358487bc585e6381740af87291aaa4cafa7231ee2f06c9f0e3aeac9925842176384fa850dd4cfcef814aff82db9f7d652c99cbb1196ec21717ddb2a74df4ea2d3109ec03f9d3ae5183d93c9c7d9d1312567c9301580bcc9182d6990bee3b1bee64cc5b007b371e4b8ef05632465144d1665f28043b7f2454cde0b0a7d5238ca805216f47427adaaed9297fe417bcf1de94e6932512a135b1c6764afbd70b368ccedfe6a502aa0a339fbb4c923e16b50050a072a3654afc625a36b0d1f5c036735d19663b12fc9cbdba5307624e03530a69a53440942329163316103551db48af082297882f0421a1fdf7bed62de93b2d98db2aaf535e6a600c6b75925edb59d13564fd0658e50827288656961fb637ebf2373a7dc3c4fc0c4b5f99fa7c77d854ebd3790b9084eb7a9639afa853158f4063123f73f35548c3b88cf2e31214611a60b22fb17d1428fdd172c67ab91efdd1c4b5bb6b87728a6b222af75be61772d3562252090bdbe3fc92e6e4f549a89e7a2c983dcc092519bab</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
        <category>Good Habits</category>
        <category>Reading</category>
      </categories>
  </entry>
  <entry>
    <title>Qiniang Mountain</title>
    <url>/2020/07/10/Qiniang-Mountain/</url>
    <content><![CDATA[<img data-src="https://img.17you.com/attachment/portal/201612/13/092914gb271ssqfs2lxixe.jpg" width="100%"/>

<a id="more"></a>

<p>七娘山是大鹏半岛南岛的主要山峰，海拔869米，是深圳市内山脉中仅次于梧桐山<strong>第二高峰</strong>，山中森林茂盛，保存着未经人为破坏的常绿阔叶林，由于七娘山雨量充沛，云雾易于形成，云峰在无边无际的云海中穿梭，景象瞬息万变。</p>
<p>因山上有七座山峰而被称为“七娘山”，三面环海，七峰连绵。</p>
<p>注意事项：</p>
<ul>
<li>上山前带够充足的水和零食，山上无补给</li>
<li>做好防晒，入口两公里左右没有充足的植被遮阳</li>
<li>只有入口处有洗手间和更衣室</li>
</ul>
]]></content>
      <categories>
        <category>Tour</category>
      </categories>
      <tags>
        <tag>Tour</tag>
      </tags>
  </entry>
  <entry>
    <title>Rent Room</title>
    <url>/2020/03/22/Rent-Room/</url>
    <content><![CDATA[<img data-src="https://files.keepingcurrentmatters.com/wp-content/uploads/2016/08/07161903/20160822-KCM.jpg" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://www.douban.com/group/topic/152050687/" target="_blank" rel="noopener">【招舍友】【福田】【7号线-上沙站】金地花园两室一厅诚…</a></p>
<p><a href="https://www.douban.com/group/topic/168586980/" target="_blank" rel="noopener">福田上沙金地花园两室一厅</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Score</title>
    <url>/2020/02/24/Score/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Third warning: This content is personal, please skip it." data-whm="Fourth warning: This content is personal, please skip it."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Warning again: This content is personal, please skip it." /><label>Warning again: This content is personal, please skip it.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="8ead47400e79baa5dfb120e4b15d63de642d4ba7517ca46d00edb3291775236c">83c4f8ea343e795ea5cda9331adf7dc0ce4a134270323f562a9b86b9a0674133e3ec8c45f486404f28391e06f5a3f54421f9f785ac09675e45991f451b02bb62154c46e776f17e852f876bf48db898c831191d19a0a4cc5bda4cadcd60075c2791efa0c018b416ad4da9fde09feb412753693ad9586760a2ec9a2752654116fc50e4349f2d02ab621b2448767e7411eec5857173f8cf206c498e1d4f336deb8a6354a681c7505a572ed001e5a90d72f28af1c094c9c6fee3de3aa7184f9d0b8bfe3fed9788a7fce7e447d8e73b611ad4e4cc61489276c4b4a565d1630626765cb79374bf94bd4dbde9428b19acf19ba82e922c6684993a50bc6fbd7fb2abb15343f04f5ade5fe5cfe311e5c8658f62b83ecf048bcb1d3868605870019a08f19fe4bfa68d3a65ec5cdb5fb4f27cd7168e40942b083967da158879f85c7ca9cf63940806fe339ba12e8fd203cdb51f1b135ae7d8ecb2ccc99725b9695dfb2af3f2a0f31473dd1bb6a432a5bbc2602bcc9e08ad183eca56aae45dede30e428f5243e1abfa43d5609948a3d4907752a74b776647312807c1650226246e779910449b307763eb9792e423dea709206232bab92e72d907beee1c7fede769b2d339e068c5bd9ff17aad812a273fe128dc17f5d91278b291923f2cfca33fc91bc00af1ee8cdadda92af05462c5cc648b64c2ff66ebea0fec5626f074d0252831803251ce715dc7f4f78714cd96ced2b34ba27584ec9e4767f5876aff824dfc88cf4a0c7d30fcf67c67ec24f694dc6baa874b4c172c17ec6c35b350d2e870d5f22df7f8139b5094a07e67cd9f5b1f0f1909a8b44440168bb3d92815c39fa1def27a1fde49f1b7c817bfe77403beef8b60e27c6edeb11dd611bd16dbf618227a0272bd92224f7c477a8efe9a3fa3d1ad171651719115795cf10a2bcc185a20ecdd6a63575a2071ff9ffe66cd34cb7f7a7c8060635cfe5cbe2626ae56eb186149541d4d5c39c353efce8917f318b389e782ef114dd93740f696aee5e5ebbc681f9424d2357bd3a3dc38590fec8b2419a79e6066e82913db3e5d9a082eaa7d1fb9ca485c4acde7c09f9909ba7f19e0cabc5298ca1f7b349fb6f380605f67b4ce6788240bea49b96286645761b8e5f16b15cab1ba8c4d3070459884eb3aa292f984e9f02084eb35af13a147aef06a89c2fadc4bbb652fcadd407f7c755e40f5b978c3234518cd6b3b3d2ed86808bfe541fc09a6af7c3715708ec2bd7613d080632c544dc9e92aa59401e1aa8b90ef18135f544a6a27646acf53ab870d93bee7aad28800acd115c686abc0b30cf7a0a534b7b5d84eccf5c264f87347f0d5f081349179cf33fabb9f0ceee5b9eae56fd19301be08bc0be56f26619d427ee06a1f5fb3ba049ccd4a7ba9f48d595541e4bd9dbf159c589809b743ede431cafc3872352bfdd7e6fcdeda19e4d3e5adc8f8ef6266fa872e4a8c73e788f76d6ce8f7c86ed6c54227010d7eb03361dd2faf79cd9666a792eeae3836b1f7005b34a11df38438fc33e95f0003cb156ebee535272f6913cafd06b89327f5464fa0068d021c1425d1eb4e74ab5a4ce6223acb4a1f538041049b5c8346fbedfc994812bf22b4d52fd380d3346b523799130ba9dc1032a8b207f4b61ce89911ccca346c1afd8aa34d9bf658d6f13542f915bbe9d943af6817021f544c6bf952ba7b8b47c600e0ab2f5822a0ce0459f2bedb6057b199b3205240338f4f2b0f791537aa128ce1f3a1524d5179f416445c29baf3fdb4d287838011de21c8eed6c906cad3c82dd544e8a084239305fd17d1f2cccf6424ba90d5022b4d14b2cbc9a25aaf2f27321e71fd7f96d6523bf0b5497df14aad416c863defbe306df1e52f6130dfdf8bdede2348dfaa98194484428a20d5ae79102d76d9e1cb2f333f384b265a005f818dd4e935273404f27ff57d893736800089da2be17064a5398ea7ba8ba0bb240ee896818c6f6af88252940d2695666653a3f63a8287869b06d07b6aab16907abcab84554a3dd66c398800f5da0bc0a13985a66f9f9a02b81a056080d50f5c40a120ecd0d0ae3911733a667c919366ac4522db3197c0a54d01c7694480e6820b71a7c4a5959f54ee66a7fc765c276d6ced3fabf2de04c40eb65ee5539f17ecab20598b40e3d585551ac206fa8a17b2ec9a9fd1af1341b4a27643785cc37693c77d92d5e5be1707c680df5b8619b552342e328c6a150c75d56df8442bb1c4efce43a92b239f346caf4e8966d5e76e05efa0735b8f9c41c81670118f766d2e34d91d7cc6d6e7295e54d58c84ce6814555b88e18c982a6a506de31a8c8dfd7b6a976fb8f6ce6c0bf00a565db767b34bea75e212079caaa43a6037a5c1739e24c8631c3ae2a419a642fb51001a9c8207476bb01740601911e261bf6357e216c81efbb73e5c3199233fa67b9739e9d74a2d2d912df4292c56c9ab7e1c64db78f0b328372f950bc915847da78f4128c7f1926065566611f54148e693c6c955399b7407b8276d593f545642906f340b28adfa9c2d35adf300a7a44df0b10523a00a98aab19588e20991aa83b419aac59a5979f3694ce84a99cc7639cafcc87743ff45e64447848aa1a4aeb56958c238db90a98d8133eed1e5c405db2a91c30cd2c91b76fc19335f18903a11bd657092f930128b155ce4972f8d548f6d890158b3cc1f853a83e33a0d64fad7f00d1bf584e3d5fceac49f62cb8d77f0344549770f072640c1f07d36228f5dfd090b09f257c0030f3423e44f847e489383d559931913ef3d6afe7d38d3c5291fe412f4cf99df88c65bdb5c7e7863903f112e8af680f1a6e2762ded6e8a78775698777ab36369d8a996fd950e64198431cfc414e68177397cfced212cb8fa4ff0a10bdac9afb16096bfdfea35913cc7f2d41726b4c8ca04a1ca94465728030ebad501b4d2c978c9cea8ff707478a862f0889ad608903dc8bc35e591b2a08a8017b0e657bbd717b55fd552f55028d902180d6976782e587747255477b22e446bcd33eb3340222055486da6389f7c79e65297226640cced7e809543c6ca812dce9e0d3a3114ac483b8b6e7aa1d870f9c64e820a28570e9a6261d3282db3f3b755a432a2e03048413e2f2bf32d5172a55da47b93ed137bf69b5e4757b870e128bf6557d2152f6a505b85e5b905673e4daef71beec3855510da26ae53b16f1b66d7a9c4a78b130ee89ceeda1f64e30eb38da8166e74a41a3ffa0462a674c2adcc7de9b6504b4632f0e8f9f739928c811315241a45e4e5d8ee6246183316e6951d580503053343d1b536cda27fa26da1d1d7337b2fe1c82c640de943c3893fbf74349c1e4b7691471538cf69e37652108a578769887fb166c60d0fd1491b3f56b3ff1221804924816868d939a062a9b7d9c52ced68449a92ebb00492c587e2dc44909b4505632ac9df0f6814e174026329b25faea3e7ef3b73e931020d2bdb76adb9a26850083fe6e05313c35639521276f4c176f87c6640dff832c17f78117a72a11a8da30c2ee5f9b0b950de910250ae7ff832f116488a38cb146a208e460581f69434791f818d840a48212a428b2ffb7ec9110a35050e26efc4ff6fff7593a44ee29c607e362852fc1aba98875541a1e443008eed2485e11e474f9573e39e9341910437421a613f4055e1f129c1a0e4905ed801859a2b5f27c418d11d76a219b7234d09df5d1f05fe34ca5bd2256c55fbd6724f52a985049927f80f49760ae36c76e83568f25d8abf01494731678d7ff529b96ef0e78564f9d90a410f84c7eadecad31ff893ce0eb9e7c6cf76997c79d058f3daaea9ec703b2e7cc23fc60efe60a3dca2c33102fabf926e5fd9437606bfa9c2523f6464fce2a7981985cca6c21249fde871f87744999624807a9a80414bae71e331504a343e28d2625e96280f8de8d1b3c768fc046aae0bf633603d929261ec69800d6e6cd82b957633710157edff3c2f72d08aaf0c34e068cbbeb20603a9bf6643417f141c7ca67f9d89c7a6b122057d693faff75f42fc8670d1ca2a1506e7d7dfc4e36dc5c2ecf148ee8a2d9b8a0d396a7e78f8ed251c26461af7e9fb59bc84c5bfb93d6f36af77bc842ded18090ecec35435a5f789e504ccdaec9b1eeb28abab16e2a2ba9da5374efed4be70c39889d68a4e934e12fbaae766d302bfb7b6367033bb539f8d34b5d0dd58f51d19e669eca65ce7fccf28235412733bf2a530a1bfaae81341574ec9966e3ab8bc08c8422f31b205c2b13fd2cde6f00c2f3c627a0cd5e301941e28cf5005f1553659ca88056a63c4ed532933d76f517959d8617d4216acd283640786689b9c4d20ed5f7a566d16523b28e71e02b30e678a0da88e44400b5654d2a6837b51c1b7ee788c4b8a2164c08e0862f8c8f6e7b30a4ea394aa38eb08a39e0efb7a3963e30cfa3d5115609cd6d94acecc68076df30f91c7bb159b254ad0646d1679ffdcb852611a8c699e1c11b256e02691965c63c8f893377e7dca3d0fae64673fed57289a522ea004fe888825e31ec246055d6a7192aeff22582879b725c7f2e442eb131b13607a61b25ec6b5c34431505a2516459cae096e8a2a13d21b7ddca14396b805f502fb95f6ecbeb0ad2416ba14ce2499f118f834a8796b5a377733456f602362c46f224137327873897ead91942b7a1a86760b09aa5dd3a84fd4511a7a13a8103f9e22a8171d33e045203cd7d94af3409fd21fc3f0d5612986112588f521a5dcded644ad9647bf9596cafff8f8faa5fdf6a599c5d6577d3089d85bd21911bbafc91f6627ac75603ee139e0a3793c338f41b275298b95d85895079e1e9ac67a64ef65cc98</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
        <category>Conclusion</category>
      </categories>
  </entry>
  <entry>
    <title>Search Services For Blog</title>
    <url>/2020/02/16/Search-Services-For-Blog/</url>
    <content><![CDATA[<img data-src="https://codecamp.vn/blog/wp-content/uploads/2019/12/67e4f643-6b12-49a5-9f08-d2e3fef18633-760x400.jpeg" width="100%"/>

<a id="more"></a>

<h2 id="站内搜索服务"><a href="#站内搜索服务" class="headerlink" title="站内搜索服务"></a>站内搜索服务</h2><p>NexT 7 提供了 Algolia/Local/Swiftype 三种集成方式。</p>
<div class="note info">
            <p>目前博文数量并不多，搜索时长还在可接受范围内，所以选择最简单的本地搜索方式。</p>
          </div>

<div class="tabs" id="search-services"><ul class="nav-tabs"><li class="tab"><a href="#search-services-1">Algolia</a></li><li class="tab active"><a href="#search-services-2">Local</a></li><li class="tab"><a href="#search-services-3">Swiftype</a></li></ul><div class="tab-content"><div class="tab-pane" id="search-services-1"><p>还没用过</p></div><div class="tab-pane active" id="search-services-2"><div class="note ">
            <p>原理是通过 hexo-generator-search 插件在本地生成一个 search.xml 文件，通过这个文件实现搜索功能。</p>
          </div>

<div style="width: 100%;
            height: 300px;
            background-image: url(http://qn.mintools.net/mts/20180418/3853306637468672);
            background-repeat: no-repeat;
            background-size: 703px 756px;
            background-position: 0px 0px;"></div>

<ol>
<li><p>安装 <code>hexo-generator-searchdb</code> 插件</p>
<p>项目根目录下执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-searchdb</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>站点配置文件中添加以下内容</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主题配置文件中打开本地搜索</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one. 将 html 字符转义为可读性字符</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



</li>
</ol></div><div class="tab-pane" id="search-services-3"><p>只对企业邮箱开放注册，只能试用 14 天，之后收费！</p></div></div></div>]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Self Criticism of Carelessness</title>
    <url>/2019/04/10/Self-Criticism-of-Carelessness/</url>
    <content><![CDATA[<img data-src="https://www.moedict.tw/%E6%AA%A2%E8%A8%8E.png" width="100%"/>

<a id="more"></a>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Afternoon of April-09, 2019, the CEO of E-commerce sent a message in WeChat asking me if I had checked his messages carefully. It wasn’t until then that I went back and looked carefully at our chat records. Only then did I find that I failed to send my entry document in time as required. In the chat record on April 9, I was asked to send my entry document within two days. </p>
<p>In order to punish myself, I decided to write this review to learn the lesson.</p>
<h2 id="Self-Reflection"><a href="#Self-Reflection" class="headerlink" title="Self Reflection"></a>Self Reflection</h2><p>In April 9, when I received this long-awaited offer, I was very excited. So when I read the information, I read those words in a hurry with neglecting such key information. Then I shared the good news with my good friends, and asked them out for dinner and singing on Sunday. I hadn’t noticed this problem for four days unexpectedly until the CEO gave me a head-on blow. </p>
<p>I think I made the following mistakes in this incident:</p>
<ul>
<li>Carelessness: Not reading the information carefully enough.</li>
<li>Flighty and Impetuous: Eager to celebrate without scrutinizing the information.</li>
<li>Self Conjecture: Misunderstanding that I thought I was been asked to take the document to the company in my first day.</li>
</ul>
<p>This lesson taught me the following points:</p>
<ul>
<li>Do things carefully and conscientiously.</li>
<li>Keep a serious attitude until all dust is settled.</li>
<li>If there are any ambiguities, must ask clearly before proceeding.</li>
</ul>
<p>I must keep these lessons in mind and keep reminding myself to do better in my future work and life.</p>
]]></content>
      <categories>
        <category>self-criticism</category>
      </categories>
      <tags>
        <tag>self-criticism</tag>
      </tags>
  </entry>
  <entry>
    <title>Skin</title>
    <url>/2019/01/14/Skin/</url>
    <content><![CDATA[<img data-src="https://images-na.ssl-images-amazon.com/images/I/81N2Kuru-JL.jpg" width="100%"/>

<a id="more"></a>

<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>这是一本自传体散文集，讲述作者以往的经历。</p>
<p>苦难总是会感动人，想起同样的高中时期家里发生的变故，虽然没有像作者那样严重，但苦难本不应该拿来比较。没有真正的感同身受，每个人都经历着自己的苦难，我无法对他人的苦难做到“身历其境”的地步，也不奢求观客的“无微不至”。让我佩服的是哪些将苦难转化为动力的能力，每个人都有苦难，但不是每个人都有能力吸收苦难的力量，并转换为自身的能量。</p>
<p>但当总觉得作者在评论别人的时候给人一种对比的感觉，确实不是很舒服。每种生活方式可能都应该得到尊重，我不知道到底哪些东西可以对比，或许只有实物的对比会更加安心一些。</p>
<p>不过读书本该取其精华去其糟粕，奇怪的是精华，糟粕没有什么标准，因人而异。写写读后感也是简单的理一理思绪。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>蔡崇达是个新闻行业从业者。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>我不相信成熟能让我们接受任何东西，成熟只是让我们更能自欺欺人。——文中引用他一个朋友的话</li>
<li>当你坐在一个人对面，听他开口说话，看得到各种复杂、精密的境况和命运，如何最终雕刻出这样的性格、思想、做法、长相，这才是理解。</li>
<li>路过我们生命的每个人，都参与了我们，并最终成了我们本身。</li>
<li>每个读者只能督导已然存在于他内心的东西。书籍只不过是一种光学仪器，帮助读者发现自己的内心。——马塞尔·普鲁斯特</li>
<li>有生命力的地方在于浑浊。</li>
<li>用想象喂大的过度膨胀的理想幻想。</li>
<li>最离奇的理想所需要的建筑素材就是一个个庸常而枯燥的努力。</li>
<li>梦想原来是卑微的执着。</li>
<li>不合时宜的东西，如果自己虚弱，终究会成为人们嘲笑的对象，但有力量了，或坚持久了，或许反而能成为众人追捧的魅力和个性。</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Software and Tools</title>
    <url>/2025/07/22/Software%20and%20Tools/</url>
    <content><![CDATA[<img data-src="https://cdn.techopedia.com/images/uploads/92c11d5cff6e43f299d55f5e66fc9ebf.jpg?width=360&height=240&mode=crop" width="100%"/>

<a id="more"></a>

<h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><blockquote>
<p>一款非常强大的搜索软件</p>
</blockquote>
<h3 id="配置百度翻译"><a href="#配置百度翻译" class="headerlink" title="配置百度翻译"></a>配置百度翻译</h3><p>设置&gt;关键字&gt;+</p>
<p><img data-src="https://i.loli.net/2018/12/23/5c1efe97bccec.jpg" alt=""></p>
<p><img data-src="https://i.loli.net/2018/12/23/5c1efec5efec9.jpg" alt=""></p>
<h2 id="GUN-Wget"><a href="#GUN-Wget" class="headerlink" title="GUN Wget"></a>GUN Wget</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/28826000" target="_blank" rel="noopener">Wget for windows——优雅地实现批量下载</a></p>
</blockquote>
<h2 id="在线验证-yaml-格式"><a href="#在线验证-yaml-格式" class="headerlink" title="在线验证 yaml 格式"></a>在线验证 yaml 格式</h2><p><a href="http://www.yamllint.com/" target="_blank" rel="noopener">YAML Lint</a></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><blockquote>
<p><a href="https://www.52pojie.cn/thread-801613-1-1.html" target="_blank" rel="noopener">VMware Workstation 15 Pro+Key</a></p>
</blockquote>
<h2 id="MySQL图形化工具"><a href="#MySQL图形化工具" class="headerlink" title="MySQL图形化工具"></a>MySQL图形化工具</h2><blockquote>
<p><a href="https://www.52pojie.cn/thread-710976-1-1.html" target="_blank" rel="noopener">Webyog Sqlyog Ultimate_12.5.1官方最新版附注册码</a></p>
</blockquote>
<h2 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h2><blockquote>
<p><a href="https://www.jb51.net/softs/595166.html#downintro2" target="_blank" rel="noopener">Xshell 6 (SSH远程终端工具) 6.0 绿色中文注册授权激活版</a></p>
<p><a href="http://www.xshellcn.com/" target="_blank" rel="noopener">中文官网</a></p>
</blockquote>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><blockquote>
<p><a href="https://blog.csdn.net/cs4380/article/details/79158268" target="_blank" rel="noopener">maven下载和安装</a></p>
</blockquote>
<h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/32779910" target="_blank" rel="noopener">Lombok 看这篇就够了</a></p>
</blockquote>
<h2 id="PDF-阅读器"><a href="#PDF-阅读器" class="headerlink" title="PDF 阅读器"></a>PDF 阅读器</h2><blockquote>
<p><a href="https://www.sumatrapdfreader.org/free-pdf-reader.html" target="_blank" rel="noopener">sumatrapdf</a></p>
</blockquote>
<h2 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h2><blockquote>
<p><a href="https://blog.csdn.net/u014015972/article/details/47264371" target="_blank" rel="noopener">Potplayer 快捷键</a></p>
</blockquote>
<p>视频播放器。强大的内置解码器，强大的定制能力和个性化功能。</p>
<h2 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h2><h3 id="Clear-Cache"><a href="#Clear-Cache" class="headerlink" title="Clear Cache"></a>Clear Cache</h3><p>Clear your cache and browsing data with a single click of a button.</p>
<h3 id="SMMS"><a href="#SMMS" class="headerlink" title="SMMS"></a>SMMS</h3><blockquote>
<p>一个简单实用的图床插件</p>
</blockquote>
<h3 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a>Vimium</h3><blockquote>
<p><a href="https://blog.csdn.net/WPwalter/article/details/80933068" target="_blank" rel="noopener">像黑客一样！Chrome 完全键盘操作指南（原生快捷键 + Vimium 插件）</a></p>
</blockquote>
<h3 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h3><blockquote>
<p><a href="http://yifeng.studio/2017/09/06/recommended-extension-tools-about-github/" target="_blank" rel="noopener">强力推荐！那些你不能错过的 GitHub 插件和工具</a></p>
</blockquote>
<h3 id="Save-to-Pocket"><a href="#Save-to-Pocket" class="headerlink" title="Save to Pocket"></a>Save to Pocket</h3><blockquote>
<p>The best way to save articles, videos and more</p>
</blockquote>
]]></content>
      <categories>
        <category>Software</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Study Notes of Linux</title>
    <url>/2019/01/04/Study-Notes-of-Linux/</url>
    <content><![CDATA[<img data-src="cover" width="100%"/>

<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="ip-addr"><a href="#ip-addr" class="headerlink" title="ip addr"></a>ip addr</h3><p>查看IP地址</p>
]]></content>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2018/12/25/Study-Notes-of-Redis/</url>
    <content><![CDATA[<img data-src="https://guides.wp-bullet.com/wp-content/uploads/2016/09/redis-unix-socket-object-cache-wordpress.png" width="100%"/>

<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis-GitHbu</a></p>
</blockquote>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><h2 id="有哪些公司在使用Redis"><a href="#有哪些公司在使用Redis" class="headerlink" title="有哪些公司在使用Redis"></a>有哪些公司在使用Redis</h2><p>GitHub, Twitter, Stackoverflow, Alibaba, 百度，微博，美团，搜狐</p>
<h2 id="Redis的八大特性"><a href="#Redis的八大特性" class="headerlink" title="Redis的八大特性"></a>Redis的八大特性</h2><ol>
<li>速度快</li>
<li>支持持久化</li>
<li>存在多种数据结构</li>
<li>支持多种语言</li>
<li>功能丰富</li>
<li>简单（代码量小，使用方便）</li>
<li>主从复制</li>
<li>高可用，分布式</li>
</ol>
<h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p>官方给的指标是10w OPS（每秒十万次读写）</p>
<p>这么快的原因：</p>
<ul>
<li><p>数据存放在内存中</p>
</li>
<li><p>使用C语言编写（大约五万行代码），C语言离操作系统较近</p>
</li>
<li><p>线程模型为单线程</p>
</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis所有数据保存在内存中，对数据的更新将异步的保存到磁盘上。</p>
<h3 id="多种数据结构"><a href="#多种数据结构" class="headerlink" title="多种数据结构"></a>多种数据结构</h3><p>五大数据结构：</p>
<ol>
<li>Strings</li>
<li>Hash Tables</li>
<li>Linked Lists</li>
<li>Sets</li>
<li>Sorted Sets</li>
</ol>
<p>其他新结构：</p>
<ol start="6">
<li>BitMaps: 位图（本质是字符串，可以实现类似<a href="https://china.googleblog.com/2007/07/bloom-filter_7469.html" target="_blank" rel="noopener">布隆过滤器</a>的功能）</li>
<li>HyperLogLog：超小内存唯一值计数（本质是字符串）</li>
<li>GEO：地理信息定位（本质是有序集合，Redis-3.2后提供）</li>
</ol>
<h3 id="支持多种客户端语言"><a href="#支持多种客户端语言" class="headerlink" title="支持多种客户端语言"></a>支持多种客户端语言</h3><p>Java，PHP，python，Ruby，Lua，nodejs</p>
<h3 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h3><ol>
<li>发布订阅模式</li>
<li>Lua脚本</li>
<li>事务</li>
<li>pipeline（提高客户端并发效率）</li>
</ol>
<h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><ul>
<li>缓存系统</li>
<li>计数器（微博的转发数，评论数以及视频网站的播放数等）</li>
<li>消息队列系统 </li>
<li>排行榜</li>
<li>社交网络（粉丝数，关注数，共同关注数）</li>
<li>实时系统（垃圾邮件处理系统，布隆过滤器）</li>
</ul>
<h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h3 id="Linux系统下安装Redis"><a href="#Linux系统下安装Redis" class="headerlink" title="Linux系统下安装Redis"></a>Linux系统下安装Redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 下载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 解压缩</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-5.0.3.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 建立一个软连接</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> In -s redis-5.0.3 redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-5.0.3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure>



<h2 id="可执行文件说明"><a href="#可执行文件说明" class="headerlink" title="可执行文件说明"></a>可执行文件说明</h2><table>
<thead>
<tr>
<th>可执行文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>redis-server</td>
<td>Redis服务器</td>
</tr>
<tr>
<td>redis-cli</td>
<td>Redis命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>Redis性能测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>AOF文件修复工具</td>
</tr>
<tr>
<td>redis-check-dump</td>
<td>RDB文件修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>Sentinel服务器（2.8以后）</td>
</tr>
</tbody></table>
<h2 id="三种启动方法"><a href="#三种启动方法" class="headerlink" title="三种启动方法"></a>三种启动方法</h2><h3 id="最简启动"><a href="#最简启动" class="headerlink" title="最简启动"></a>最简启动</h3><p>直接使用<code>redis-server</code></p>
<h3 id="动态参数启动"><a href="#动态参数启动" class="headerlink" title="动态参数启动"></a>动态参数启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server --port 6380 # 默认端口是6379</span><br></pre></td></tr></table></figure>

<h3 id="配置文件启动"><a href="#配置文件启动" class="headerlink" title="配置文件启动"></a>配置文件启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server configPath</span><br></pre></td></tr></table></figure>

<h3 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep redis</span><br><span class="line">netstat -antpl|grep redis</span><br><span class="line">redis-cli -h ip -p port ping</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>生产环境推荐配置启动</li>
<li>单机多实例配置文件可以用端口区分开</li>
</ul>
<h2 id="简单的客户端连接"><a href="#简单的客户端连接" class="headerlink" title="简单的客户端连接"></a>简单的客户端连接</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.10.79.150 -p 6384</span><br><span class="line">ping</span><br><span class="line">set hello world</span><br><span class="line">get hello</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ol>
<li>状态回复（如<code>ping</code>返回<code>PONG</code>）</li>
<li>错误回复（如<code>(error) WRONGTYPE Operation against</code>）</li>
<li>整数回复（如<code>incr hello</code>回复<code>(integer) 1</code>）</li>
<li>字符串回复（如<code>get hello</code>回复<code>&quot;world&quot;</code>）</li>
<li>多行字符串回复（如<code>mget hello foo</code>返回<code>&quot;world&quot; &quot;bar&quot;</code>）</li>
</ol>
<h2 id="Redis常用配置"><a href="#Redis常用配置" class="headerlink" title="Redis常用配置"></a>Redis常用配置</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>是否是守护进程（no默认|yes推荐）</td>
</tr>
<tr>
<td>port</td>
<td>Redis对外端口号，默认为6379<br />7379对应手机按键上MERZ对应的号码，MERZ取自意大利歌女Alessia Merz的名字</td>
</tr>
<tr>
<td>logfile</td>
<td>Redis系统日志</td>
</tr>
<tr>
<td>dir</td>
<td>Redis工作目录</td>
</tr>
</tbody></table>
<h1 id="Redis-API"><a href="#Redis-API" class="headerlink" title="Redis API"></a>Redis API</h1><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ol>
<li><p>keys</p>
<p>eg：<code>keys *</code> 遍历所有的key</p>
<p>怎么用：</p>
<p>​    热备从节点</p>
<p>​    scan</p>
</li>
<li><p>dbsize</p>
<p>计算key的总数</p>
</li>
<li><p>exists key</p>
<p>检查key是否存在，存在返回1，否则返回0</p>
</li>
<li><p>del key [key …]</p>
<p>删除指定key-value，成功返回1，否则返回0</p>
</li>
<li><p>expire key seconds</p>
<p><code>ttl key</code>查看key剩余的过期时间</p>
<p><code>persist key</code>去掉key的过期时间</p>
</li>
<li><p>type key</p>
<p>返回key的类型（string，hash，list，set，zset，none）</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>keys</td>
<td>O(n)</td>
</tr>
<tr>
<td>dbsize</td>
<td>O(1)</td>
</tr>
<tr>
<td>del</td>
<td>O(1)</td>
</tr>
<tr>
<td>exists</td>
<td>O(1)</td>
</tr>
<tr>
<td>expire</td>
<td>O(1)</td>
</tr>
<tr>
<td>type</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h2><h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p><img data-src="https://i.loli.net/2018/12/25/5c2240654f22b.png" alt="Redis 内部编码"></p>
<h3 id="字符串键值结构"><a href="#字符串键值结构" class="headerlink" title="字符串键值结构"></a>字符串键值结构</h3><table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>hello</td>
<td>world</td>
</tr>
<tr>
<td>counter</td>
<td>1</td>
</tr>
<tr>
<td>bits</td>
<td>|1|0|1|1|1|0|1|</td>
</tr>
<tr>
<td></td>
<td>{<br />“prodduct”:{<br />“id”: “3242”<br />“name”: “test423”<br />}<br />}</td>
</tr>
</tbody></table>
<p>Value up to 512MB，up to 100k is recommended</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>缓存</li>
<li>计数器</li>
<li>分布式锁</li>
</ul>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 获取key对应的value O(1)</span></span><br><span class="line">get key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 设置key-value O(1)</span></span><br><span class="line">set key value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 删除key-value O(1)</span></span><br><span class="line">del key</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. key自增1，如果key不存在，自增后get（key）=1 O(1)</span></span><br><span class="line">incr key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. key自减1，如果key不存在，自减后get（key）=-1 O(1)</span></span><br><span class="line">decr key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. key自增k，如果key不存在，自增后get（key）=k O(1)</span></span><br><span class="line">incrby key k</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. key自减k，如果key不存在，自减后get（key）=-k O(1)</span></span><br><span class="line">decrby key k</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 不管key是否存在，都设置 O(1)</span></span><br><span class="line">set key value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. key不存在，才设置 O(1)</span></span><br><span class="line">setnx key value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. key存在，才设置 O(1)</span></span><br><span class="line">set key value xx</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 批量获取key，原子操作 O(n)</span></span><br><span class="line">mget key1 key2 key3...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 批量设置key-value O(n)</span></span><br><span class="line">mset key1 value1 key2 vlaue2 key3 value3</span><br></pre></td></tr></table></figure>

<p>n次get = n次网络时间 + n次命令时间</p>
<p>1次mget = 1次网络时间 + n次命令时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. <span class="built_in">set</span> key newvalue并返回旧的value O(1)</span></span><br><span class="line">getset key newvalue</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将value追加到旧的value O(1)</span></span><br><span class="line">append key value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 返回字符串的长度（注意中文） O(1)</span></span><br><span class="line">strlen key</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 增加key对应的值3.5 O(1)</span></span><br><span class="line">incrbyfloat key 3.5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 获取字符串指定下标范围内的值 O(1)</span></span><br><span class="line">getrange key start end</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 设置指定下标范围内对应的值 O(1)</span></span><br><span class="line">setrange key index value</span><br></pre></td></tr></table></figure>

<h5 id="复杂度总结"><a href="#复杂度总结" class="headerlink" title="复杂度总结"></a>复杂度总结</h5><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>是指key-value</td>
<td>O(1)</td>
</tr>
<tr>
<td>get key</td>
<td>获取key-value</td>
<td>O(1)</td>
</tr>
<tr>
<td>del key</td>
<td>删除key-value</td>
<td>O(1)</td>
</tr>
<tr>
<td>setnx setxx</td>
<td>根据key是否存在设置key-value</td>
<td>O(1)</td>
</tr>
<tr>
<td>Incr decr</td>
<td>计数</td>
<td>O(1)</td>
</tr>
<tr>
<td>mget mset</td>
<td>批量操作key-value</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ol>
<li><p>记录网站每个用户个人主页的访问量？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">incr userid:pageview</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存视频的基本信息（数据源在MySQL中）伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VideoInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">    String redisKey = redisPrefix + id;</span><br><span class="line">    VideoInfo videoInfo = redis.get(redisKey);</span><br><span class="line">    <span class="keyword">if</span>(videoInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">        videoInfo = mysql.get(id);</span><br><span class="line">        <span class="keyword">if</span>(videoInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            redis.set(redisKey, serialize(videoInfo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> videoInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分布式计数器</p>
<p>incr id (原子操作)</p>
</li>
</ol>
<h3 id="Hash键值结构"><a href="#Hash键值结构" class="headerlink" title="Hash键值结构"></a>Hash键值结构</h3><table>
<thead>
<tr>
<th>key</th>
<th>field</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>user:1:info</td>
<td>name<br />age<br />Date</td>
<td>Ronaldo<br />32<br />239</td>
</tr>
</tbody></table>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>是一个<code>value</code>为<code>Map</code>的<code>Map</code></p>
</li>
<li><p><code>field</code>不能相同，<code>value</code>可以相同</p>
</li>
</ol>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>所有以哈希为结构的命令都是以<code>H</code>开头的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 获取<span class="built_in">hash</span> key对应的field的value O(1)</span></span><br><span class="line">hget key field</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 设置<span class="built_in">hash</span> key对应field的value O(1)</span></span><br><span class="line">hset key field value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 删除<span class="built_in">hash</span> key对应field的value O(1)</span></span><br><span class="line">hdel key field</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 判断<span class="built_in">hash</span> key是否有field O(1)</span></span><br><span class="line">hexists key field</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 获取<span class="built_in">hash</span> key field的数量 O(1)</span></span><br><span class="line">hlen key</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 批量获取<span class="built_in">hash</span> key的一批field对应的值 O(n)</span></span><br><span class="line">hmget key field1 field2... fieldN</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 批量设置<span class="built_in">hash</span> key的一批field value O(n)</span></span><br><span class="line">hmset key field1 value1 field2 value2...fieldN valueN</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 返回<span class="built_in">hash</span> key对应所有的field和value O(n)</span></span><br><span class="line">hgetall key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 返回<span class="built_in">hash</span> key对应所有field的value O(n)</span></span><br><span class="line">hvals key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 返回<span class="built_in">hash</span> key对应多有field O(n)</span></span><br><span class="line">hkeys key</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 设置<span class="built_in">hash</span> key对应field的value（若field已存在，则失败） O(1)</span></span><br><span class="line">hsetnx key field value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. <span class="built_in">hash</span> key对应的filed的value自增intCounter O(1)</span></span><br><span class="line">hincrby key field intCounter</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. hincrby浮点数版 O(1)</span></span><br><span class="line">hincrbyfloat key field floatCounter</span><br></pre></td></tr></table></figure>

<h5 id="复杂度总结-1"><a href="#复杂度总结-1" class="headerlink" title="复杂度总结"></a>复杂度总结</h5><table>
<thead>
<tr>
<th>命令</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>hget hset hdel</td>
<td>O(1)</td>
</tr>
<tr>
<td>hexists</td>
<td>O(1)</td>
</tr>
<tr>
<td>hincrby</td>
<td>O(1)</td>
</tr>
<tr>
<td>hgetall hvals hkeys</td>
<td>O(n)</td>
</tr>
<tr>
<td>hmget hmset</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>有序（根据插入顺序得到遍历顺序）</li>
<li>可以重复</li>
<li>左右两边都可以插入和弹出</li>
</ol>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>列表的API都以<code>L</code>开头</p>
<h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 从列表右端插入值 O(1)</span></span><br><span class="line">rpush key value1 value2 ... valueN</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 从列表左端插入值 O(1)</span></span><br><span class="line">lpush key value1 value2 ... valueN</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 在list指定的值前|后插入newValue O(n)</span></span><br><span class="line">linsert key before|after value newValue</span><br></pre></td></tr></table></figure>

<h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 从列表左侧弹出一个item O(1)</span></span><br><span class="line">lpop key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 从列表右侧弹出一个item O(1)</span></span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3. 根据count值，从列表中删除所有value相等的项 O(n)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> （1）count&gt;0，从左到右，删除最多count个value相等的项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> （2）count&lt;0，从右到左，删除最多Math。abs（count）个value相等的项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> （3）count=0，删除所有value相等的项</span></span><br><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 4. 按照索引范围修剪列表 O(n)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	 如ltrime listkey 1 4 是指删除除了下标为1-4（包括1和4）其他项</span></span><br><span class="line">ltrim key start end</span><br></pre></td></tr></table></figure>

<h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 获取列表指定索引范围所有item O(n)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  	 如lrange listKey 0 2获取的是下标0-2（包括0和2）的项</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  	 再如lrange listKey 1 -1获取的是下标1-（len-1）的项</span></span><br><span class="line">lrange key start end</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2. 获取列表指定索引的item O(n)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    如lindex listkye -1 取到的是最后一个元素</span></span><br><span class="line">lindex key index</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3. 获取列表长度 O(1)</span></span><br><span class="line">llen key</span><br></pre></td></tr></table></figure>

<h5 id="改"><a href="#改" class="headerlink" title="改"></a>改</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 设置列表指定索引值为newValue O(n)</span></span><br><span class="line">lset key index newValue</span><br></pre></td></tr></table></figure>

<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. lpop阻塞版本，timeout是阻塞超时时间，timeout=0为永远不阻塞 O(1)</span></span><br><span class="line">blpop key timeout</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. rpop阻塞版本，timeout是阻塞超时时间，timeout=0为永远不阻塞 O(1)</span></span><br><span class="line">brpop key timeout</span><br></pre></td></tr></table></figure>

<h5 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h5><ol>
<li>LPUSH + LPOP = Stack</li>
<li>LPUSH + RPOP = Queue</li>
<li>LPUSH + LTRIM = Capped Collection</li>
<li>LPUSH + BRPOP = Message Queue</li>
</ol>
<h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><ol>
<li>TimeLine</li>
</ol>
<h4 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h4><ol>
<li><p>记录网站每个用户个人主页的访问量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hincrby user:1:info pageview count</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存视频的基本信息（数据源在mysql中）伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> VideoInfo <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">    String redisKey = redisPrefix + id;</span><br><span class="line">    Map&lt;String, String&gt; hashMap = redis.hgetAll(redisKey);</span><br><span class="line">    VideoInfo videoInfo = transferMapToVideo(hashMap);</span><br><span class="line">    <span class="keyword">if</span>(videoInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">        videoInfo = mysql.get(id);</span><br><span class="line">        <span class="keyword">if</span>(videoInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            redis.hmset(redisKey, transferVideoToMap(videoInfo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> videoInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h2><p>Redis在同一时刻只会执行一条命令</p>
<h3 id="单线程为什么这么快"><a href="#单线程为什么这么快" class="headerlink" title="单线程为什么这么快"></a>单线程为什么这么快</h3><ol>
<li><p>纯内存</p>
</li>
<li><p>非阻塞IO</p>
</li>
<li><p>避免线程切换和竞态消耗</p>
</li>
<li><p>拒绝长（慢）命令</p>
<p>​    keys, flushall, flushdb, slow lua script, mutil/exec, operate big value(collection)</p>
</li>
<li><p>其实不是单线程</p>
<p>fysnc file descriptor</p>
<p>close file descriptor</p>
</li>
</ol>
<h1 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h1><h2 id="Java客户端：Jedis"><a href="#Java客户端：Jedis" class="headerlink" title="Java客户端：Jedis"></a>Java客户端：Jedis</h2><h3 id="获取Jedis"><a href="#获取Jedis" class="headerlink" title="获取Jedis"></a>获取Jedis</h3><ol>
<li>添加<code>Maven</code>依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Jedis直连（TCP连接）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">String value = jedis.get(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<p><code>Jedis(String host, int port, int connectionTimeout, int soTimeout)</code></p>
<ul>
<li>host : Redis节点所在机器的IP</li>
<li>port : Redis节点的端口</li>
<li>connectionTimeout : 客户端连接超时时间（内部使用socket技术）</li>
<li>soTimeout : 客户端读写超时时间</li>
</ul>
</li>
</ol>
<h3 id="Jedis基本使用"><a href="#Jedis基本使用" class="headerlink" title="Jedis基本使用"></a>Jedis基本使用</h3><h3 id="Jedis连接池使用"><a href="#Jedis连接池使用" class="headerlink" title="Jedis连接池使用"></a>Jedis连接池使用</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化Jedis连接池，通常来讲JedisPool是单例的。</span></span><br><span class="line">GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从连接池获取jedis对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">// 2. 执行操作</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrance();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(jedis != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果使用JedisPool，close操作不是关闭连接，二十代表归还连接池。</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>直连</td>
<td>- 简单方便<br />- 适用于少量长期连接的场景</td>
<td>- 存在每次新建/关闭TCP开销<br />- 资源无法控制，存在连接泄露的可能<br />- Jedis对象线程不安全</td>
</tr>
<tr>
<td>连接池</td>
<td>- Jedis预先生成，降低开销使用<br />- 连接池的形式保护和控制资源的使用</td>
<td>相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题。</td>
</tr>
</tbody></table>
<h2 id="python客户端：redis-py"><a href="#python客户端：redis-py" class="headerlink" title="python客户端：redis-py"></a>python客户端：redis-py</h2><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><blockquote>
<p><a href="https://redis.io/clients#python" target="_blank" rel="noopener">Redis-clients-python</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/andymccurdy/redis-py/archive/3.0.0.zip</span><br><span class="line">unzip redis-3.0.0.zip</span><br><span class="line">cd redis-3.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装redis-py</span></span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>

<h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">client = redis.StrictRedis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">key = <span class="string">"hello"</span></span><br><span class="line">setResult = client.set(key, <span class="string">"python-redis"</span>)</span><br><span class="line"><span class="keyword">print</span> setResult</span><br><span class="line">value = client.get(key)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"key:"</span> + key + <span class="string">", value:"</span> + value</span><br></pre></td></tr></table></figure>

<h2 id="Go客户端"><a href="#Go客户端" class="headerlink" title="Go客户端"></a>Go客户端</h2> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c,err := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:6379"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">v, err := c.Do(<span class="string">"SET"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">v, err = redis.String(c.Do(<span class="string">"GET"</span>, <span class="string">"hello"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="瑞士军刀Redis"><a href="#瑞士军刀Redis" class="headerlink" title="瑞士军刀Redis"></a>瑞士军刀Redis</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img data-src="https://i.loli.net/2018/12/27/5c2419d644e00.png" alt=""></p>
<ol>
<li>慢查询发生在第三阶段</li>
<li>客户端超时不一定是慢查询导致的，慢查询只是导致客户端超时的一个可能因素</li>
</ol>
<h3 id="两个配置"><a href="#两个配置" class="headerlink" title="两个配置"></a>两个配置</h3><h4 id="slowlog-max-len"><a href="#slowlog-max-len" class="headerlink" title="slowlog-max-len"></a>slowlog-max-len</h4><ol>
<li>先进先出队列</li>
<li>固定长度</li>
<li>保存在内存内</li>
</ol>
<h4 id="slowlog-log-slower-than"><a href="#slowlog-log-slower-than" class="headerlink" title="slowlog-log-slower-than"></a>slowlog-log-slower-than</h4><ol>
<li>慢查询阈值（单位：微妙，1毫秒等于1000微秒）</li>
<li>slowlog-log-slower-than=0，记录所有命令</li>
<li>slowlog-log-slower-than&lt;0，不记录任何命令</li>
</ol>
<h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><ol>
<li>默认值<ul>
<li>config get slowlog-max-len = 128</li>
<li>config get slowlog-log-slower-than = 10000</li>
</ul>
</li>
<li>修改配置文件后重启（适用于未启动时）</li>
<li>动态配置<ul>
<li>config set slowlog-max-len 1000</li>
<li>config set slowlog-log-slower-than 1000</li>
</ul>
</li>
</ol>
<h3 id="三个命令"><a href="#三个命令" class="headerlink" title="三个命令"></a>三个命令</h3><ol>
<li>slowlog get [n] ：获取慢查询队列</li>
<li>slowlog len ：获取慢查询队列长度</li>
<li>slowlog reset ：清空慢查询队列</li>
</ol>
<h3 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h3><ol>
<li>slowlog-max-len不要是指过大，默认10ms，通常是指1ms</li>
<li>slowlog-log-slower-than不要设置太小，通常设置1000左右</li>
<li>理解命令生命周期</li>
<li>定期持久化慢查询</li>
</ol>
<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><h3 id="什么是流水线"><a href="#什么是流水线" class="headerlink" title="什么是流水线"></a>什么是流水线</h3><p>流水线就是一次网络连接里传输一批命令，节省网络传输时间</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>N个命令操作</th>
<th>1次pipeline</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>n次网络 + n次命令</td>
<td>1次网络 + n次命令</td>
</tr>
<tr>
<td>数据量</td>
<td>1条命令</td>
<td>n条命令</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>Redis的命令时间是微秒级别。</li>
<li>pipeline每次条数要控制（网络）。</li>
</ol>
<h3 id="客户端实现-pipeline-Jedis"><a href="#客户端实现-pipeline-Jedis" class="headerlink" title="客户端实现 pipeline-Jedis"></a>客户端实现 pipeline-Jedis</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before pipeline</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    jedis.hset(<span class="string">"hashkey:"</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// after pipeline</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">100</span>; j &lt; (i+<span class="number">1</span>)*<span class="number">100</span>; j++)&#123;</span><br><span class="line">        pipeline.hset(<span class="string">"hashkey:"</span> + j, <span class="string">"field"</span> + j, <span class="string">"value"</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    pipeline.syncAndReturnAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="与原生M操作做对比"><a href="#与原生M操作做对比" class="headerlink" title="与原生M操作做对比"></a>与原生M操作做对比</h3><p>M操作是原子操作，pipeline是非原子操作。</p>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ol>
<li>注意每次pipeline携带数据量</li>
<li>pipeline每次只能作用在一个Redis节点上</li>
<li>M操作与pipeline区别</li>
</ol>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>发布者（publisher）</li>
<li>订阅者（subscriber）</li>
<li>频道（channel）</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>Redis server中有各个频道。</p>
<p>发布者向频道中发布消息</p>
<p>订阅者收到其所订阅频道的消息，只能收到订阅时刻之后的消息，之前的收不到。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/7432257-f91184b81f782b4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt=""></p>
<p>需要注意的是，redis没有消息堆积的能力。</p>
<h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> publish sohu:tv <span class="string">"hello world"</span></span></span><br><span class="line">(integer) 3 # 订阅者个数</span><br></pre></td></tr></table></figure>

<h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">subscribe [channel] # 一个或多个</span><br></pre></td></tr></table></figure>

<h4 id="unsubscribe"><a href="#unsubscribe" class="headerlink" title="unsubscribe"></a>unsubscribe</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unsubcribe [channle] # 一个或多个</span><br></pre></td></tr></table></figure>

<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 订阅模式</span></span><br><span class="line">psubscribe [pattern]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 推定指定的模式</span></span><br><span class="line">punsubscribe [pattern]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 列出至少有一个订阅者的频道</span></span><br><span class="line">pubsub channels</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 列出给定频道的订阅者数量</span></span><br><span class="line">pubsub numsub [channel]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 列出被订阅模式的数量</span></span><br><span class="line">pubsub numpat</span><br></pre></td></tr></table></figure>

<h3 id="发布订阅与消息队列"><a href="#发布订阅与消息队列" class="headerlink" title="发布订阅与消息队列"></a>发布订阅与消息队列</h3><p>发布订阅是所有订阅者可以收到所有的消息</p>
<p>消息队列是订阅者要进行消息抢夺，一条消息只有一个订阅者能够抢到。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><table>
<thead>
<tr>
<th>b</th>
<th>i</th>
<th>g</th>
</tr>
</thead>
<tbody><tr>
<td>01100010</td>
<td>01101001</td>
<td>01100111</td>
</tr>
</tbody></table>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 给位图指定索引设置值</span></span><br><span class="line">setbit key offset value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 获取位图指定索引的值</span></span><br><span class="line">getbit key offset</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 获取位图指定范围（start到end，单位为字节，如果不指定就是获取全部）位值为1的个数</span></span><br><span class="line">bitcount key [start end]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 做多个Bitmap的and（交集）、or（并集）、not（非）、xor（抑或）操作并将结果保存在destkey中</span></span><br><span class="line">bitop op destkey key [key...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 计算位图指定范围（start到end，单位为字节，如果不指定就是取全部）第一个偏移量对应的值等于targetBit的位置</span></span><br><span class="line">bitpos key targetBit [start][end]</span><br></pre></td></tr></table></figure>

<h3 id="独立用户统计"><a href="#独立用户统计" class="headerlink" title="独立用户统计"></a>独立用户统计</h3><ol>
<li>使用set和Bitmap</li>
<li>总共1亿用户，每日5千万独立访问。</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>每个userid只用空间</th>
<th>需要存储的用户量</th>
<th>全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>32位<br />（假设userid用的是整型，<br />实际很多网站用的是长整型）</td>
<td>50，000，000</td>
<td>32位*50，000，000=100MB</td>
</tr>
<tr>
<td>Bitmap</td>
<td>1位</td>
<td>100，000，000</td>
<td>12.5MB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>一天</th>
<th>一个月</th>
<th>一年</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>200M</td>
<td>6G</td>
<td>72G</td>
</tr>
<tr>
<td>Bitmap</td>
<td>12.5M</td>
<td>375M</td>
<td>4.5G</td>
</tr>
</tbody></table>
<p>如果只有10万对立用户：<br>| 数据类型 | 每个userid占用空间 | 需要存储的用户量 | 全部内存量             |<br>| ——– | —————— | —————- | ———————- |<br>| set      | 32位               | 1,000,000        | 32位<em>1,000,000=4MB     |<br>| Bitmap   | 1位                | 100,000,000      | 1位</em>100,000,000=12.5MB |</p>
<h3 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h3><ol>
<li>type=string，最大512MB</li>
<li>注意setbit时的偏移量，可能有较大耗时</li>
<li>位图不是绝对好。</li>
</ol>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="是否是新的数据结构"><a href="#是否是新的数据结构" class="headerlink" title="是否是新的数据结构"></a>是否是新的数据结构</h3><ol>
<li>基于 HyperLogLog 算法：极小空间完成独立数量统计。</li>
<li>本质还是字符串</li>
</ol>
<h3 id="三个命令-1"><a href="#三个命令-1" class="headerlink" title="三个命令"></a>三个命令</h3><ol>
<li><p>向 hyperloglog 添加元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 hyperloglog 的独立总数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并多个 hyperloglog</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h3><h3 id="使用经验-1"><a href="#使用经验-1" class="headerlink" title="使用经验"></a>使用经验</h3><ol>
<li>存在错误率（0.81%）</li>
<li>无法取出单条数据</li>
</ol>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><h3 id="GEO是什么"><a href="#GEO是什么" class="headerlink" title="GEO是什么"></a>GEO是什么</h3><p>GEO(地理信息定位)：存储经纬度，计算两地距离，范围计算等。</p>
<h3 id="5个城市经纬度"><a href="#5个城市经纬度" class="headerlink" title="5个城市经纬度"></a>5个城市经纬度</h3><table>
<thead>
<tr>
<th>城市</th>
<th>经度</th>
<th>纬度</th>
</tr>
</thead>
<tbody><tr>
<td>北京</td>
<td>116.28</td>
<td>39.55</td>
</tr>
<tr>
<td>天津</td>
<td>117.12</td>
<td>39.08</td>
</tr>
<tr>
<td>石家庄</td>
<td>114.29</td>
<td>38.02</td>
</tr>
<tr>
<td>唐山</td>
<td>118.01</td>
<td>39.38</td>
</tr>
<tr>
<td>保定</td>
<td>115.29</td>
<td>38.51</td>
</tr>
</tbody></table>
<h3 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 添加地理位置信息</span></span><br><span class="line">geo key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 获取地理位置信息</span></span><br><span class="line">geopos key member [member ...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 获取两个地理位置的距离</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    unit: m(米)、km(千米)、mi(英里)、ft(尺)</span></span><br><span class="line">geodist key member1 member2 [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 获取指定位置范围内的地理位置信息集合</span></span><br><span class="line">georadius</span><br></pre></td></tr></table></figure>

<h3 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h3><ol>
<li>since 3.2+</li>
<li>type geoKey = zset</li>
<li>没有删除 API：zrem key member</li>
</ol>
<h2 id="持久化-1"><a href="#持久化-1" class="headerlink" title="持久化"></a>持久化</h2><h2 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h2><p>（1）什么是持久化</p>
<p>redis 所有数据保存在内存中，对数据的更新将异步的保存到磁盘上。</p>
<p>（2）持久化的实现方式</p>
<ol>
<li>快照<ul>
<li>MySQL Dump</li>
<li>Redis RDB</li>
</ul>
</li>
<li>写日志<ul>
<li>MySQL Binlog</li>
<li>Hbase Hlog</li>
<li>Redis AOF</li>
</ul>
</li>
</ol>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>（1）什么是RDB</p>
<p>​    redis 通过命令创建 RDB 文件（二进制）保存在硬盘中。当 redis 重启时通过命令将 RDB 文件载入到内存。实质是一个复制媒介。</p>
<p>（2）触发机制-主要三种方式</p>
<ol>
<li><p>save（同步）</p>
<ul>
<li>新文件将会替换老文件</li>
<li>复杂度位 O(n)</li>
</ul>
</li>
<li><p>bgsave（异步）</p>
<ul>
<li><p>利用 Linux fork() 异步执行</p>
</li>
<li><p>文件策略及复杂度与 save 相同</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞</td>
<td>是</td>
<td>是（阻塞发生在fork)</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork，消耗内存</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>自动</p>
<p>redis 提供了 save 配置</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>seconds</th>
<th>changes</th>
</tr>
</thead>
<tbody><tr>
<td>save</td>
<td>900</td>
<td>1</td>
</tr>
<tr>
<td>save</td>
<td>300</td>
<td>10</td>
</tr>
<tr>
<td>save</td>
<td>60</td>
<td>10000</td>
</tr>
</tbody></table>
<p>满足任意一个条件，redis 会自动创建（bgsave）RDB 文件</p>
<p>默认配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">dbfiename dump.rdb</span><br><span class="line">dir ./</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbcheksum yes</span><br></pre></td></tr></table></figure>

<p>最佳配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line">dir /bigdiskpath</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbcheksum yes</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>（3）触发机制-不容忽视方式</p>
<pre><code>1. 全量复制
2. debug reload
3. shutdown </code></pre><p>（4）总结</p>
<pre><code>1. RDB是 Redis 内存到硬盘的快照，用于持久化。
2. save 通常会阻塞 Redis
3. bgsave 不会阻塞 Redis，但是会 fork 新进程。
4. save 自动配置满足任意一个条件就会被执行。</code></pre><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="RDB-现存问题"><a href="#RDB-现存问题" class="headerlink" title="RDB 现存问题"></a>RDB 现存问题</h3><ul>
<li><p>耗时，耗性能</p>
<ul>
<li><p>O(n): 耗时</p>
</li>
<li><p>fork(): 消耗内存，copy-on-write 策略</p>
</li>
<li><p>Disk I/O: IO 性能</p>
</li>
</ul>
</li>
<li><p>不可控，丢失数据</p>
</li>
</ul>
<h3 id="什么是-AOF"><a href="#什么是-AOF" class="headerlink" title="什么是 AOF"></a>什么是 AOF</h3><p>每执行一条命令，就将该命令写入到 AOF 日志文件中。</p>
<h3 id="AOF-三种策略"><a href="#AOF-三种策略" class="headerlink" title="AOF 三种策略"></a>AOF 三种策略</h3><p>（1）always</p>
<p>​    每条写命令都会出发刷新，将缓冲区的命令日志刷新到 AOF 文件中。</p>
<p>（2）everysec</p>
<p>​    每秒（默认值）刷新一次</p>
<p>（3）no</p>
<p>​    由操作系统决定什么时候刷新。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>always</th>
<th>everysec</th>
<th>no</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>不丢失数据</td>
<td>每秒一次 fsync <br />丢失一秒数据</td>
<td>不用管</td>
</tr>
<tr>
<td>缺点</td>
<td>IO 开销较大，一般的 sata 盘只有几百 TPS</td>
<td>丢失1秒数据</td>
<td>不可控</td>
</tr>
</tbody></table>
<h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><table>
<thead>
<tr>
<th>原生 AOF</th>
<th>AOF 重写</th>
</tr>
</thead>
<tbody><tr>
<td>set hello world<br />set hello java<br />set hello hehe<br />incr counter<br />incr counter<br />rpush mylist a<br />rpush mylist b<br />rpush mylist c<br />过期数据</td>
<td>set hello hehe<br />set counter 2<br />rpush mylist a b c</td>
</tr>
</tbody></table>
<p>AOF 重写的作用：</p>
<ol>
<li>减少磁盘占用量</li>
<li>加速恢复速度</li>
</ol>
<p>AOF 重写的两种实现方式</p>
<ol>
<li><p>berewriteaof</p>
</li>
<li><p>AOF 重写配置</p>
<table>
<thead>
<tr>
<th>配置名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>autoaof-rewrite-min-size</td>
<td>AOF 文件重写需要的尺寸</td>
</tr>
<tr>
<td>auto-aof-rewrite-percentage</td>
<td>AOF 文件增长率</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>统计名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>aof_current_size</td>
<td>AOF 当前尺寸（单位：字节）</td>
</tr>
<tr>
<td>aof_base_size</td>
<td>AOF 上次启动和重写的尺寸（单位：字节）</td>
</tr>
</tbody></table>
<p>自动触发时机：</p>
<ul>
<li>aof_current_size &gt; auto-aof-rewrite-min-size</li>
<li>aof_current_size - aof_base_size / aof_base_size &gt; auto-aof-rewrite-percentage</li>
</ul>
<p>AOF 重写流程</p>
<p><img data-src="data:image/jpeg;base64,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" alt=""></p>
<p>常用配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename "appendonly-$&#123;port&#125;.aof"</span><br><span class="line">appendfsync everysec</span><br><span class="line">dir /bigdiskpath</span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="RDB-和-AOF-的抉择"><a href="#RDB-和-AOF-的抉择" class="headerlink" title="RDB 和 AOF 的抉择"></a>RDB 和 AOF 的抉择</h2><h3 id="RDB-和-AOF-比较"><a href="#RDB-和-AOF-比较" class="headerlink" title="RDB 和 AOF 比较"></a>RDB 和 AOF 比较</h3><table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h3 id="RDB-最佳策略"><a href="#RDB-最佳策略" class="headerlink" title="RDB 最佳策略"></a>RDB 最佳策略</h3><ol>
<li>“关”</li>
<li>集中管理</li>
<li>主从，从开</li>
</ol>
<h3 id="AOF-最佳策略"><a href="#AOF-最佳策略" class="headerlink" title="AOF 最佳策略"></a>AOF 最佳策略</h3><ol>
<li>”开“：缓存和存储</li>
<li>AOF 重写集中管理</li>
<li>everysec</li>
</ol>
<h3 id="最佳策略"><a href="#最佳策略" class="headerlink" title="最佳策略"></a>最佳策略</h3><ol>
<li>小分片</li>
<li>缓存或者存储</li>
<li>监控（硬盘、内存、负载、网络）</li>
<li>足够的内存</li>
</ol>
<h2 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h2><h3 id="fork-操作"><a href="#fork-操作" class="headerlink" title="fork 操作"></a>fork 操作</h3><ol>
<li>同步操作</li>
<li>与内存量息息相关：内存越大，耗时越长（与机器类型有关）</li>
<li>info: latest_fork_usec 查询上一次 fork 的时间</li>
</ol>
<p>如何改善fork</p>
<ol>
<li>优先使用物理机或者高效支持 fork 操作的虚拟化技术</li>
<li>控制 Redis 实例最大可用内存：maxmemory</li>
<li>合理配置 Linux 内存分配策略：vm.overcommit_memory = 1</li>
<li>降低 fork 频率：例如放宽 AOF 重写自动触发时机，不必要的全量复制</li>
</ol>
<h3 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h3><p>子进程开销和优化</p>
<ol>
<li>CPU：<ul>
<li>开销：RDB 和 AOF 文件生成，属于 CPU 密集型</li>
<li>优化：不做 CPU 绑定，不和 CPU 密集型部署</li>
</ul>
</li>
<li>内存：<ul>
<li>开销：fork 内存开销，copy-on-write。</li>
<li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li>
</ul>
</li>
<li>硬盘<ul>
<li>开销：AOF 和 RDB 文件写入，可以结合 iostat，iotop 分析</li>
<li>优化：<ul>
<li>不要和高硬盘负责服务部署在一起：存储服务、消息队列等</li>
<li>no-appendfsync-on-rewrite = yes</li>
<li>根据写入量决定磁盘类型：例如 ssd</li>
<li>单机多实例持久化文件目录可以考虑分盘</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h3><p><img data-src="https://upload-images.jianshu.io/upload_images/12588973-ed80e9c29a4d1ef2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>AOF 阻塞定位</p>
<p>​    Reids 日志：</p>
<p>​    Asynchronous AOF fsync is taking too long (disk is busy?).</p>
<p>​    Writing the AOF buffer without waiting for fsync to complete,this may slow down Redis.</p>
<p>​    info Persistence:</p>
<p>​    …</p>
<p>​    aof_delayed_fsync: 100</p>
<p>​    …</p>
<h3 id="单机多实例部署"><a href="#单机多实例部署" class="headerlink" title="单机多实例部署"></a>单机多实例部署</h3><h2 id="Redis-复制的原理与优化"><a href="#Redis-复制的原理与优化" class="headerlink" title="Redis 复制的原理与优化"></a>Redis 复制的原理与优化</h2><h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>（1）单机有什么问题？</p>
<p>​    机器故障</p>
<p>​    容量瓶颈</p>
<p>​    QPS 瓶颈</p>
<p>（2）作用</p>
<p>​    数据副本</p>
<p>​    扩展读性能</p>
<h3 id="复制的配置"><a href="#复制的配置" class="headerlink" title="复制的配置"></a>复制的配置</h3><p>两种实现方式</p>
<ol>
<li><p>slaveof 命令</p>
</li>
<li><p>配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof ip port</span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h3><p>查看 run_id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6379 info server | grep run</span><br></pre></td></tr></table></figure>

<p>查看偏移量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6379 info replication</span><br></pre></td></tr></table></figure>

<p>全量复制开销：</p>
<ol>
<li>bgsave 时间</li>
<li>RDB文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载 RDB 的时间</li>
<li>可能的 AOF 重写时间</li>
</ol>
<h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><h3 id="开发运维常见问题-1"><a href="#开发运维常见问题-1" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h3><ol>
<li><p>读写分离</p>
<p>将读流量分摊到从节点</p>
<p>可能遇到的问题：</p>
<ul>
<li>复制数据延迟</li>
<li>读到过期数据</li>
<li>从节点故障</li>
</ul>
</li>
<li><p>主从配置不一致</p>
</li>
<li><p>规避全量复制</p>
<ul>
<li>第一次不可避免</li>
<li>系欸但运行 ID  不匹配<ul>
<li>主节点重启</li>
<li>故障转移</li>
</ul>
</li>
<li>复制积压缓冲区不足<ul>
<li>网络中断，部分复制无法满足</li>
<li>增大复制缓冲区配置 rel_backlog_size，网络“增强”。</li>
</ul>
</li>
</ul>
</li>
<li><p>规避复制风暴</p>
<ul>
<li>单主节点复制风暴<ul>
<li>问题：主节点重启，多从节点复制</li>
<li>解决：更换复制拓扑</li>
</ul>
</li>
<li>单机器复制风暴<ul>
<li>机器宕机后，大量全量复制</li>
<li>主节点分散多机器</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h2><h3 id="主从复制高可用存在的问题"><a href="#主从复制高可用存在的问题" class="headerlink" title="主从复制高可用存在的问题"></a>主从复制高可用存在的问题</h3><ol>
<li>手动故障转移</li>
<li>写能力和存储能力受限</li>
</ol>
<h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>客户端不直接访问 redis，而是通过 sentinel 来访问。由 sentinel 来负责主从节点的管理。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>sentinel 的默认端口为 26379</p>
<ol>
<li>配置开启主从节点</li>
<li>配置开启 sentinel 监控主节点（sentinel 是特殊的 redis）</li>
</ol>
<h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>请求相应流程</p>
<p>jedis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JedisSentinelPool sentinelPool = new JedisSentinelPool(masterName, sentinelSet, poolConfig, timeout);</span><br><span class="line">Jedis jedis = null;</span><br><span class="line">try &#123;</span><br><span class="line">    jedis = redisSentinelPool.getResource();</span><br><span class="line">    // jedis command</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (jedis != null)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>redis-py</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h3 id="常见开发运维问题"><a href="#常见开发运维问题" class="headerlink" title="常见开发运维问题"></a>常见开发运维问题</h3><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><h3 id="呼唤集群"><a href="#呼唤集群" class="headerlink" title="呼唤集群"></a>呼唤集群</h3><ol>
<li>超高并发量需求</li>
<li>超大数据量需求</li>
</ol>
<h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><p>顺序分布</p>
<p>哈希分布</p>
<ul>
<li>节点取余<ul>
<li>使用多倍扩容降低迁移率</li>
</ul>
</li>
<li>一致性哈希<ul>
<li>顺时针取余</li>
<li>只影响邻近节点</li>
<li>扩容后会存在负载不均衡的情况</li>
</ul>
</li>
<li>虚拟槽<ul>
<li>每个槽映射一个数据子集</li>
<li>良好的哈希函数：例如 CRC16</li>
<li>服务端管理节点、槽、数据：例如 Redis Cluster</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>分布方式</th>
<th>特点</th>
<th>典型产品</th>
</tr>
</thead>
<tbody><tr>
<td>哈希分布</td>
<td>数据分散度高<br />键值分布业务无关<br />无法顺序访问<br />支持批量操作</td>
<td>一致性哈希 Memcache<br />Redis Cluster<br /></td>
</tr>
<tr>
<td>顺序分布</td>
<td>数据分散度易倾斜<br />键值业务相关<br />可顺序访问<br />不支持批量操作</td>
<td>BigTable<br />HBase</td>
</tr>
</tbody></table>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><h3 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h3><h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><h3 id="开发运维常见问题-2"><a href="#开发运维常见问题-2" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h3><h3 id="Redis-Cluster-架构"><a href="#Redis-Cluster-架构" class="headerlink" title="Redis Cluster 架构"></a>Redis Cluster 架构</h3><ol>
<li>节点</li>
<li>meet</li>
<li>指派槽</li>
<li>复制</li>
</ol>
<h3 id="Redis-Cluster-特性"><a href="#Redis-Cluster-特性" class="headerlink" title="Redis Cluster 特性"></a>Redis Cluster 特性</h3><ol>
<li>复制</li>
<li>高可用</li>
<li>分片</li>
</ol>
<h3 id="两种安装方式"><a href="#两种安装方式" class="headerlink" title="两种安装方式"></a>两种安装方式</h3><h4 id="原生命令安装"><a href="#原生命令安装" class="headerlink" title="原生命令安装"></a>原生命令安装</h4><ol>
<li><p>配置开启节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port $&#123;port&#125;</span><br><span class="line">daemonize yes</span><br><span class="line">dir "/opt/redis/data"</span><br><span class="line">dbfilename "dump-$&#123;port&#125;.rdb"</span><br><span class="line">logfile "$&#123;port&#125;.log"</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-$&#123;port&#125;.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>meet</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster meet ip port</span><br></pre></td></tr></table></figure>
</li>
<li><p>指派槽</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster addslots slot [slot ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>分配主从关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster replicate node-id</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="官方工具安装"><a href="#官方工具安装" class="headerlink" title="官方工具安装"></a>官方工具安装</h4><blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1Y0_Aq8UOzIDoqluORSuCww" target="_blank" rel="noopener">https://pan.baidu.com/s/1Y0_Aq8UOzIDoqluORSuCww</a><br>提取码：5r0v</p>
</blockquote>
]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>The Golden Age</title>
    <url>/2019/02/18/The-Golden-Age/</url>
    <content><![CDATA[<img data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01DiTrLMPp1/xdcwC9VHWIpC8g.jpg!l" width="100%"/>

<a id="more"></a>

<h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><blockquote>
<p>黑色而幽默，特立而独行，一把独立思考的匕首，扎进时代荒谬的肺中。 ——豆瓣网评<a href="https://www.douban.com/people/luhua/" target="_blank" rel="noopener">芦哲峰</a></p>
<p>王小波该是个有趣的人，多黑暗的年代偏写得这么喜感，但两人相处细节部分又觉得他真是天才，写得出糙也写得出美。性很动人，情感挣扎很动人，最后终于承认的爱也很动人。PS,看全文实在太顺溜实在让人以为作者信手拈来，后来看他自己的评才知道这故事写了二十年，果然状似不经意的作品原来最费心力。 ——豆瓣网评<a href="https://www.douban.com/people/missleftonly/" target="_blank" rel="noopener">missleft</a></p>
</blockquote>
<p>从小说的字里行间能够体会到王小波有趣的灵魂，他对生活唯一的要求就是“有趣”，活得真实，洒脱。整篇小说都贯穿了对“性”的描写，起先可能因为高中时看过像《爬上姐姐的床》这类都市题材的网络小说，受其影响认为这本好像也差不多是这个样子，但后来慢慢发现还是有不同的地方，不同之处在于对“性”的描述方式，《黄金时代》谈的更多的是“性欲”，不是描写具体的“性”在行为上的表现。“食色性也。” 想爱和想吃都是人性的一部分，小说里的性就如同生命本身，健康、干净。</p>
<p>《黄金时代》里的王二即是介入者又是旁观者，介入的时候激情澎湃，旁观的时候又冷静深邃。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="创作背景"><a href="#创作背景" class="headerlink" title="创作背景"></a>创作背景</h3><p>1968年， 王小波在云南兵团劳动，并开始尝试写作。这段经历成为《黄金时代》的写作背景。<br>1982年三十岁大学毕业后，王小波在中国人民大学一分校教书，教师生活是《三十而立》等小说的写作背景。这个时期王小波开始写作《黄金时代》。<br>1986年王小波获硕士学位，他开始写作以唐传奇为蓝本的仿古小说，继续修改《黄金时代》。其间得到他深为敬佩的老师许倬云的指点。</p>
<h3 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h3><p>六七十年代，中国处于非性的年代。在非性的年代里，性才会成为生活的主题。</p>
<p>《黄金时代》还原了“文革”时期荒诞的社会现象。只是在“集体遗忘”的氛围里，敢于或者愿意将此揭露出来的作家并不多，王小波算是其中一个。他的文字以一针见血的迅猛气势，让被普通民众甚至有些文人学者刻意“神秘化”的荒诞现象，在读者面前赤裸裸地重现。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>王小波，1952年5月13日出生于北京。1968～1970年 云南农场知青。1971～1972年 山东牟平插队；后担任民办教师。1972～1973年 北京牛街教学仪器厂工人。1974～1978年 北京西城区半导体厂工人。1978～1982年 中国人民大学贸易经济系学生。1982～1984年 中国人民大学一分校教师。1984～1988年 美国匹兹堡大学东亚研究中心研究生，获硕士学位。1988～1991年 北京大学社会学系讲师。1991～1992年 中国人民大学会计系讲师。1992～1997年 自由撰稿人。1997年4月11日 逝世于北京。终年45岁。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ul>
<li>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了槌的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也槌不了我。</li>
<li>当我沿着一条路走下去的时候，心里总想着另一条路上的事。这种时候，我心里很乱。</li>
<li>好危险，差一点爱上你。</li>
<li>寂寞就是可以做一切事的自由。</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>The world owes you nothing</title>
    <url>/2019/01/27/The-world-owes-you-nothing/</url>
    <content><![CDATA[<img data-src="https://img3.doubanio.com/view/subject/l/public/s29585922.jpg" width="100%"/>

<a id="more"></a>

<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>总体的感觉是应该不会再读第二遍吧，主要是越来越排斥标题很吸睛的帖子或文章。可能是我先入为主了吧。</p>
<p>文章全部节选自作者公众号的文章，描述的都是当今社会上热点的话题，但都是描述，然后作者自己的感想，这类文章大多读完后只能是你赞同或反对作者的观点，如果反对的话可能更能促发深度思考些，但这本书带给我的启发性并不大，很多都是都知道的道理，虽然作者有一些角度还行，但像历史这种角度，不够深的话可能说服力确实不够。</p>
<p>有一个最讨厌的点是每篇文章都会抽出来一段乍一听很吸引人的句子放在开头，然后再文章中又出现，有的甚至出现好几次，读到的时候有点烦。</p>
<p>吸睛的文章堆砌成书真的不好，读着读着容易疲劳。</p>
<p>这本书没有我想摘录的句子，不指定为什么，提不起兴趣。</p>
<p>读到最后的后序时还好一些，作者显得还比较谦虚些的样子。我不希望我是这样的态度，我希望我能抱有“取其精华弃其糟粕”的态度来阅读。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p><strong>慧超，本名吴会超</strong>。一名公关，【思维补丁】公众号作者。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>TenSquare</title>
    <url>/2019/01/03/TenSquare/</url>
    <content><![CDATA[<img data-src="http://cdn3.img.sputniknews.cn/images/101711/57/1017115745.jpg" width="100%"/>

<a id="more"></a>

<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><blockquote>
<p><a href="https://www.cnblogs.com/mike-mei/p/7707915.html" target="_blank" rel="noopener">软件开发中对架构、构架、结构、框架的理解</a></p>
</blockquote>
<p><strong>架构 Architecture</strong></p>
<p>​    架构不是软件，而是关于软件如何设计的重要<strong>策略</strong>。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中。</p>
<p>​    软件架构是指构成一个软件系统核心（主体、基础）结构的<strong>组成元素</strong>，以及这些核心组成元素之间的相互依赖、交互、协作等<strong>关系</strong>。一个软件架构（模型）是<strong>动静结合</strong>的，既包含了核心元素之间的静态结构（static structural）关系，也包含了它们之间的动态行为（dynamic behavioral）关系。</p>
<p><strong>框架 Framework</strong></p>
<p>​    框架是半成品。典型地，框架是系统或子系统的半成品。</p>
<p><strong>小节</strong></p>
<p>​    框架技术和架构技术的出现，都是为了解决软件系统日益复杂所带来的困难而采取“分而治之”思维的结果—–先大局后局部，就出现了<strong>架构</strong>；先通用后专用，就出现了<strong>框架</strong>。</p>
<p>​    架构是问题的抽象解决方案，它关注大局而忽略细节；而框架是通用半成品，还必须根据具体需求进一步定制开发才能变成应用系统。</p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p><strong>微服务是一种架构风格</strong></p>
<p>微服务的目的是有效的拆分应用，实现敏捷开发和部署 。</p>
<p>把需要搭建成服务的功能制作成镜像，然后把镜像做成容器，微服务就是同类容器的集合。</p>
<p>spring cloud实现微服务之间的通信。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/rational/r-uml/" target="_blank" rel="noopener">统一建模语言简介</a></p>
<p><a href="https://www.cnblogs.com/downmoon/archive/2009/02/18/1393047.html" target="_blank" rel="noopener">UML建模的要点总结(一）</a></p>
<p><a href="https://alleniverson.gitbooks.io/java-design-patterns/content/Chapter%2030%20UML/UML%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF.html" target="_blank" rel="noopener">UML用例建模解析</a></p>
<p><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">UML教程_w3cschool</a></p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    UML（Unified Modeling Language），也称<strong>统一建模语言</strong>或<strong>标准建模语言</strong>。是用来做软件建模的。用于表达软件的操作，对象等信息。</p>
<p>UML 是一种 Language（语言）<br>UML 是一种 Modeling（建模）Language<br>UML 是 Unified（统一）Modeling Language</p>
<h3 id="PowerDesigner"><a href="#PowerDesigner" class="headerlink" title="PowerDesigner"></a>PowerDesigner</h3><blockquote>
<p><a href="https://zh.wikipedia.org/zh-hans/PowerDesigner" target="_blank" rel="noopener">PowerDesigner - 维基百科，自由的百科全书</a></p>
</blockquote>
<p>为传统的<strong>软件开发周期管理</strong>提供<strong>业务分析</strong>和规范的<strong>数据库设计</strong>解决方案。</p>
<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">RESTful API 最佳实践</a></p>
<p><a href="http://restcookbook.com/" target="_blank" rel="noopener">restcookbook.com</a></p>
</blockquote>
<p>​    REST，即 Representational State Transfer 的缩写。阮大大对这个词组的翻译是”<strong>表现层状态转化</strong>“。</p>
<p>​    一种软件架构风格、设计风格，而<strong>不是</strong>标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<h3 id="安全性和幂等性"><a href="#安全性和幂等性" class="headerlink" title="安全性和幂等性"></a>安全性和幂等性</h3><blockquote>
<p><a href="https://icbd.github.io/wiki/notes/2018/01/16/http-safe-idempotent.html" target="_blank" rel="noopener">HTTP方法的幂等性与安全性</a></p>
</blockquote>
<p>​    RestFul service 架构是基于 http 协议的。Http 有两个非常重要的特性，安全性和幂等性。</p>
<p>安全，幂等</p>
<p>安全性: 请求一次或多次, 不会改变实例的表现形式. 重点强调无副作用. </p>
<p>幂等性: 请求一次或多次, 响应结果相同. 重点强调副作用的一致性.</p>
<p>增删改查，三个不安全，三个幂等</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>idempotent</th>
<th>safe</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>YES</td>
<td>YES</td>
<td>获取实例</td>
</tr>
<tr>
<td>HEAD</td>
<td>YES</td>
<td>YES</td>
<td>获取响应头</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>YES</td>
<td>YES</td>
<td>获取支持的请求方式</td>
</tr>
<tr>
<td>TRACE</td>
<td>YES</td>
<td>YES</td>
<td>追踪查看最终的请求</td>
</tr>
<tr>
<td>PUT</td>
<td>YES</td>
<td>NO</td>
<td>全量覆盖某个实例</td>
</tr>
<tr>
<td>POST</td>
<td>NO</td>
<td>NO</td>
<td>创建新实例</td>
</tr>
<tr>
<td>PATCH</td>
<td>NO</td>
<td>NO</td>
<td>修改实例的某些属性</td>
</tr>
<tr>
<td>DELETE</td>
<td>YES</td>
<td>NO</td>
<td>删除某个实例</td>
</tr>
</tbody></table>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol>
<li>docker images</li>
<li>systemctl start docker</li>
<li>docker run -di –name=tensquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</li>
<li>docker ps -a</li>
</ol>
<h2 id="分布式ID生成器"><a href="#分布式ID生成器" class="headerlink" title="分布式ID生成器"></a>分布式ID生成器</h2><p>Twitter 的 SnowFlake（雪花）算法。</p>
<blockquote>
<p><a href="https://github.com/twitter-archive/snowflake" target="_blank" rel="noopener">snowflake</a></p>
<p><a href="https://www.lanindex.com/twitter-snowflake%EF%BC%8C64%E4%BD%8D%E8%87%AA%E5%A2%9Eid%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Twitter-Snowflake，64位自增ID算法详解</a></p>
<p><a href="https://blog.csdn.net/yangding_/article/details/52768906" target="_blank" rel="noopener">Twitter Snowflake算法详解</a></p>
</blockquote>
<p>jpa 原生sql 语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query</span>(value = <span class="string">"SELECT * FROM tb_problem, tb_pl WHERE id = problemid AND labelid = ? AND reply = 0 ORDER BY createtime DESC"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Problem&gt; <span class="title">waitlist</span><span class="params">(String labelid, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>



<p>  jpa  @Modifying</p>
<h3 id="spring-boot-data-redis"><a href="#spring-boot-data-redis" class="headerlink" title="spring boot data redis"></a>spring boot data redis</h3><p>80% 都用的是 redisTemplate.opsForValue()</p>
<h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><ol>
<li>@EnableCaching</li>
<li>@Cacheable(value = “gathering”, key = “#id”)</li>
<li>@CacheEvict(value = “gathering”, key = “#id”)</li>
</ol>
<p>需要过期时间使用redis，不需要过期时间使用spring cache</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>并没有共享session，分布式的单点登录最流行的是JWT（GWT?），CAS也是一种，但是是有状态的（服务的要存储登录信息）</p>
<p>qq登录后，qq音乐等都默认也是登录的，这就是单点登录</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>为大数据而生</p>
<p>非关系型数据库中最像关系型数据库的数据库</p>
<p>关系型数据库与非关系型数据库的区别：关系型数据库就是表与表之间有关系（1：1 ，（靠主外键）1：n，（靠主外键）n:n（靠中间表））。</p>
<p>数据库选型原因：</p>
<p>mongodb的客户端与服务器是二合一的。</p>
<p>默认端口是27017</p>
<p>逐渐名必须为 _id</p>
<p>emp表，树形结构</p>
<p>_id 一般都是手动指定，不要用自动生成。</p>
<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>ctrl + alt + v</p>
<p>Java原生操作mogodb</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"192.168.235.128"</span>);</span><br><span class="line">    <span class="comment">// 得到要操作的数据库</span></span><br><span class="line">    MongoDatebase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);</span><br><span class="line">    <span class="comment">// 得到要操作的集合</span></span><br><span class="line">    MongoCollection spit = spitdb.getCollection(<span class="string">"spit"</span>);</span><br><span class="line">    <span class="comment">// 得到集合中所有的文档</span></span><br><span class="line">    FindIterable&lt;Document&gt; documents = spit.find();</span><br><span class="line">    <span class="comment">// 遍历数据</span></span><br><span class="line">    <span class="keyword">for</span>(Document document:documents)&#123;</span><br><span class="line">        System.out.println(<span class="string">"内容："</span>+document.getString(<span class="string">"content"</span>));</span><br><span class="line">        System.out.println(<span class="string">"用户ID："</span>+document.getString(<span class="string">"userid"</span>));</span><br><span class="line">        System.out.println(<span class="string">"访问量："</span>+document.getString(<span class="string">"visits"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"192.168.235.128"</span>);</span><br><span class="line">    MongoDatebase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);</span><br><span class="line">    MongoCollection spit = spitdb.getCollection(<span class="string">"spit"</span>);</span><br><span class="line">    <span class="comment">// 封装查询条件，值查询用户id为1013的</span></span><br><span class="line">    <span class="comment">// BasicDBObject bson = new BasicDBObject("userid", "1013");</span></span><br><span class="line">    <span class="comment">// 封装查询条件，查询访问量大于1000的 find(&#123;visits:&#123;$gt:1000&#125;&#125;)</span></span><br><span class="line">    BasicDBObject bson = <span class="keyword">new</span> BasicDBObject(<span class="string">"visits"</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">"$gt"</span>, <span class="number">1000</span>));</span><br><span class="line">    FindIterable&lt;Document&gt; documents = spit.find(bson);</span><br><span class="line">    <span class="keyword">for</span>(Document document:documents)&#123;</span><br><span class="line">        System.out.println(<span class="string">"内容："</span>+document.getString(<span class="string">"content"</span>));</span><br><span class="line">        System.out.println(<span class="string">"用户ID："</span>+document.getString(<span class="string">"userid"</span>));</span><br><span class="line">        System.out.println(<span class="string">"访问量："</span>+document.getString(<span class="string">"visits"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"192.168.235.128"</span>);</span><br><span class="line">    MongoDatebase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);</span><br><span class="line">    MongoCollection spit = spitdb.getCollection(<span class="string">"spit"</span>);</span><br><span class="line">    <span class="comment">// 插入文档</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"content"</span>, <span class="string">"lalalalallala"</span>);</span><br><span class="line">    map.put(<span class="string">"userid"</span>, <span class="string">"1029"</span>);</span><br><span class="line">    map.put(<span class="string">"visits"</span>, <span class="number">1249</span>);</span><br><span class="line">	Document document = <span class="keyword">new</span> Document(map);</span><br><span class="line">    FindIterable&lt;Document&gt; documents = spit.insert(document);</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h2><p>idea 切换窗口快捷键：alt + 左右方向键</p>
<p>数据库</p>
<p>逻辑主外键。公司基本上不会真正使用物理主外键</p>
<p>避免 * 的出现，避免全表扫描</p>
<h2 id="Autowired-与-Resource的区别"><a href="#Autowired-与-Resource的区别" class="headerlink" title="@Autowired 与 @Resource的区别"></a>@Autowired 与 @Resource的区别</h2><p>@Autowired默认按类型查找，类型找不到会按名称找。可以通过@Quligier()来指定按名称查找</p>
<p>@Resource默认按名称查找，（未指定name属性时）找不到按类型查找。</p>
<h2 id="分布式搜索引擎ElasticSearch"><a href="#分布式搜索引擎ElasticSearch" class="headerlink" title="分布式搜索引擎ElasticSearch"></a>分布式搜索引擎ElasticSearch</h2><h2 id="Head插件"><a href="#Head插件" class="headerlink" title="Head插件"></a>Head插件</h2><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><h2 id="使用SpringDataElasticsearch完成搜索微服务的开发"><a href="#使用SpringDataElasticsearch完成搜索微服务的开发" class="headerlink" title="使用SpringDataElasticsearch完成搜索微服务的开发"></a>使用SpringDataElasticsearch完成搜索微服务的开发</h2><h2 id="使用logstash完成mysql与Elasticsearch的同步工作"><a href="#使用logstash完成mysql与Elasticsearch的同步工作" class="headerlink" title="使用logstash完成mysql与Elasticsearch的同步工作"></a>使用logstash完成mysql与Elasticsearch的同步工作</h2><p>搜索分两大类：搜索引擎（百度，谷歌），站内搜索（淘宝，京东）</p>
<p>cnpm里没有grunt</p>
<p>ik分词器，为了兼容不同系统，一般自定义词条时要加空行</p>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="CentOs命令"><a href="#CentOs命令" class="headerlink" title="CentOs命令"></a>CentOs命令</h3><ol>
<li>vi</li>
<li>shift+zz</li>
<li>reboot</li>
</ol>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>docker exec -it tensquare_es /bin/bash</li>
<li>docker ps ik tensquare_es:/usr/share/elasticsearch/plugins</li>
<li>挂载</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>系统调优</p>
<p>修改/etc/security/limits.conf ，追加内容</p>
<ul>
<li>soft nofile 65536</li>
<li>hard nofile 65536<br>nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制<br>修改/etc/sysctl.conf，追加内容<br>vm.max_map_count=655360<br>限制一个进程可以拥有的VMA(虚拟内存区域)的数量<br>执行下面命令 修改内核参数马上生效<br>sysctl ‐p</li>
</ul>
<p>elasticsearch solr lucene 倒排索引</p>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>速度</p>
<p>Kafka&gt;RabbitMQ&gt;ActiveMQ</p>
<p>安全</p>
<p>ActiveMQ&gt;RabbitMQ&gt;Kafka</p>
<p>kafka用在大数据中。</p>
<p>rabbitmq有交换机的概念，activemq没有</p>
<p>spring boot</p>
<p>@Runwith（）</p>
<p>@SpringBootTest（）</p>
<p>@RabbitLisener</p>
<p>@RabbitHandler</p>
<p>RoutingKey # * 匹配规则</p>
<p>rabbitmq直连模式，分列模式，主题模式</p>
<p>org.apache.commons.lang3.RandomStringUtils</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成6位随机数</span><br><span class="line">String checkcode &#x3D; RandomStringUtils.randomNumeric(6);</span><br></pre></td></tr></table></figure>



<p>阿里云发短信</p>
<p><a href="https://blog.csdn.net/wangjian1204/article/details/54563988" target="_blank" rel="noopener">Maven导入本地jar包</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br></pre></td></tr></table></figure>



<p>SHA算法（啥算法），MD5算法（妈的5算法）</p>
<p>BCrypt 加密算法</p>
<p>认证 就是登录，就是告诉系统你是谁。</p>
<p>认证后才进行授权。</p>
<p>只使用spring security的加密算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// authorizeRequests()：所有security全注解是实现形式的开端，表示开始说明需要的权限</span></span><br><span class="line">        <span class="comment">// 需要的权限分为两部分，第一部分时拦截的路径，第二部分是访问该路径所需要的权限。</span></span><br><span class="line">        <span class="comment">// antMatchers：拦截的路径，permitAll：任何权限都可以访问，直接放行所有。</span></span><br><span class="line">        <span class="comment">// .and().csrf().disable()：固定写法， 表示使csrf拦截失效。</span></span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用spring而不是spring boot时有一个原则：自己写的类用注解，框架的类用配置文件。</p>
<p>web.xml时web工程的入口。</p>
<p>web.xml就是为了初始化servlet容器。</p>
<p>spring boot强就强在省了一个web.xml</p>
<p>讲义第六章.2 常见的认证机制（即登录机制）</p>
<p>有状态登录：服务端要存登录信息，就是有状态登录</p>
<p>cookie在pc端浏览器里有，在移动端是没有的。</p>
<p>签名算法：HS256</p>
<p>用户 USER</p>
<p>角色 role</p>
<p>权限 permission</p>
<p>用户和角色是多对多，角色和权限是多对多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private HttpServletRequest request;</span><br></pre></td></tr></table></figure>



<p>quartz 定时任务，默认是多线程，但公司里都是用单线程。</p>
<p>如果没有在规定时间执行完，可以将concurrent属性改为false，使得下次任务必须等上次任务执行完后再执行。</p>
<p>七子表达式，即Cron表达式，共7位，周和日不能同时出现。</p>
<p>单点登录，CAS, SSO</p>
<p>单点登录与有无状态之间的区别</p>
<p>eureka 实现服务之间的通信。</p>
<p>feign 实现服务之间的调用。</p>
<p>dependencyManager 锁版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;Finchley.M9&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>



<p>eureka.instance.prefer-ip-address=true 服务器各服务之间跨域访问</p>
<p>@FeignClient(“”) 应用名不能有下划线。</p>
<p>feign接口 @PaathVariable 必须加name属性。</p>
<p>@IdClass(Friend.class)</p>
<p>公司一般再使用第三方提供的技术，比如利用阿里云发短信等，由于异常无法把控，所以使用消息队列异步调用的方式。</p>
<p>嵌套子查询效率特别低，公司中一般不允许出现，一般都会使用连接查询替代，或者使用EXITS关键字</p>
<p>POI报表导入导出，apache poi，excel 转成 csv 格式poi处理更快。</p>
<p>熔断器可以在服务恢复后不用重启项目就直接回复系统。</p>
<p>bootstrap.yml 比 application.yml 优先级高。</p>
<p>一般系统性的配置使用bootstrap.yml</p>
<p>@RefreshScope</p>
<p><a href="https://segmentfault.com/a/1190000008743806" target="_blank" rel="noopener">VMware NAT方式创建虚拟机网络并配置固定IP</a></p>
<h3 id="No-plugin-found-for-prefix-‘docker’-in-the-current-project-…"><a href="#No-plugin-found-for-prefix-‘docker’-in-the-current-project-…" class="headerlink" title="No plugin found for prefix ‘docker’ in the current project …"></a><a href="https://www.baidu.com/link?url=C_kRnV807hpm-ZfqxZKw6JTTRbV1e2XvsElDGu3jZGPteYyk2jC7WUAZu8e6VLSkH0GyQijQtaFOoYV2tjyfIfnuM311gC05LtiKLf95Unm&wd=&eqid=f044666f000176b5000000065c692626" target="_blank" rel="noopener"><em>No</em> <em>plugin</em> <em>found</em> <em>for</em> <em>prefix</em> <em>‘docker’</em> <em>in</em> <em>the</em> <em>current</em> <em>project</em> …</a></h3><h3 id="…emergency-mode-Exit-the-shell-to-continue-迷…-CSDN博客"><a href="#…emergency-mode-Exit-the-shell-to-continue-迷…-CSDN博客" class="headerlink" title="…emergency mode. Exit the shell to continue. - 迷…_CSDN博客"></a><a href="https://www.baidu.com/link?url=NHt_nwnhwAd1m5qObs6qzpb8NjkZKHNpQc4xvtJLJsHsv5d21V9XHl82PM0WF9OvSqvq8byKFlYLs6cJ_NOQMHtY352kYAEOzlJR7v87Uae&wd=&eqid=8bc297890004f215000000065c6cb0b6" target="_blank" rel="noopener">…<em>emergency</em> <em>mode</em>. <em>Exit</em> <em>the</em> <em>shell</em> <em>to</em> <em>continue</em>. - 迷…_CSDN博客</a></h3><h2 id="相关账号"><a href="#相关账号" class="headerlink" title="相关账号"></a>相关账号</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>账号：root</p>
<p>密码：itcast</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>账号：root</p>
<p>密码：root</p>
]]></content>
  </entry>
  <entry>
    <title>Use of OmniFocus</title>
    <url>/2020/04/16/Use-of-OmniFocus/</url>
    <content><![CDATA[<img data-src="https://is3-ssl.mzstatic.com/image/thumb/Purple113/v4/a9/ac/b9/a9acb983-76e2-d76d-fbc8-c35388dcee48/pr_source.png/1000x1000bb.jpg" width="100%"/>

<a id="more"></a>

<p>编辑截止日期</p>
<p>year/month/day hh:mm:ss</p>
]]></content>
  </entry>
  <entry>
    <title>Use of PotPlayer</title>
    <url>/2019/01/10/Use-of-PotPlayer/</url>
    <content><![CDATA[<img data-src="https://www.neowin.net/images/uploaded/2018/07/1532514381_potplayer.jpg" width="100%"/>

<a id="more"></a>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>Ctrl + Enter 全屏拉伸</li>
</ul>
]]></content>
      <categories>
        <category>Softs</category>
        <category>Video</category>
      </categories>
      <tags>
        <tag>PotPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title>YunNan Tour at National Day 2019</title>
    <url>/2019/09/19/YunNan-Tour-at-National-Day-2019/</url>
    <content><![CDATA[<img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Qing_Dynasty_Yunnan_map_1911.svg/250px-Qing_Dynasty_Yunnan_map_1911.svg.png" width="100%"/>

<a id="more"></a>

<h2 id="2019年国庆云南游"><a href="#2019年国庆云南游" class="headerlink" title="2019年国庆云南游"></a>2019年国庆云南游</h2><h3 id="总体安排"><a href="#总体安排" class="headerlink" title="总体安排"></a>总体安排</h3><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>02/10 晚上 - 07/10 早上</p>
<p>由于 2 号晚上才到，7 号早上要走，故游玩时间为中间的 4 天时间。</p>
<h4 id="地点"><a href="#地点" class="headerlink" title="地点"></a>地点</h4><p>昆明（1天）、大理（两天）、丽江（1天）</p>
<p>由于大理相对景点比较多，所以多给一天时间。</p>
<h4 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h4><p>有两种路线：</p>
<ul>
<li>昆明 → 大理 → 丽江 → 昆明</li>
<li>昆明 → 丽江 → 大理 → 昆明</li>
</ul>
<p>由于第一条路线丽江到昆明在 6 号的票太多紧张，加上丽江酒店消费偏高，所以建议使用第二条路线。</p>
<h3 id="路线-1"><a href="#路线-1" class="headerlink" title="路线"></a>路线</h3><h4 id="路线一"><a href="#路线一" class="headerlink" title="路线一"></a>路线一</h4><ul>
<li><p>2 号晚上到了住昆明</p>
</li>
<li><p>3 号白天逛昆明到景点</p>
</li>
<li><p>3 号晚上从昆明坐车到大理</p>
<p><img data-src="https://i.loli.net/2019/09/19/uFXLgV5P6esSHBa.png" alt=""></p>
</li>
<li><p>3 号晚上住大理</p>
</li>
<li><p>4 号白天逛大理景点</p>
</li>
<li><p>4 号晚上住大理</p>
</li>
<li><p>5 号白天逛大理景点</p>
</li>
<li><p>5 号晚上从大理坐车到丽江</p>
<p><img data-src="https://i.loli.net/2019/09/19/Rz8ypmZlXKxUud7.png" alt=""></p>
</li>
<li><p>5 号晚上住丽江</p>
</li>
<li><p>6 号白天逛丽江的景点</p>
</li>
<li><p>6 号晚上从丽江坐车到昆明</p>
<p><img data-src="https://i.loli.net/2019/09/19/kVzFGocCRZagmTL.png" alt=""></p>
<p><img data-src="https://i.loli.net/2019/09/19/lrkIpWoZOstzf91.png" alt=""></p>
<p><img data-src="https://i.loli.net/2019/09/19/vpUMFiEzWBRCAqY.png" alt=""></p>
<p><img data-src="https://i.loli.net/2019/09/19/Xy8xU3Wnj1rzOqP.png" alt=""></p>
<p><img data-src="https://i.loli.net/2019/09/19/sVgykCFrOcJhQoW.png" alt=""></p>
<p><img data-src="http://ww1.sinaimg.cn/large/005M2pcYgy1g747csa62kj30u00yyjt1.jpg" alt="WechatIMG8.jpeg"></p>
</li>
</ul>
<h4 id="路线二"><a href="#路线二" class="headerlink" title="路线二"></a>路线二</h4><ul>
<li><p>2 号晚上到了住昆明</p>
</li>
<li><p>3 号早上从昆明坐车到丽江</p>
<p><img data-src="https://i.loli.net/2019/09/19/qYbAGXDla6Etmu9.png" alt=""></p>
</li>
<li><p>3 号白天逛丽江的景点</p>
</li>
<li><p>3 号晚上从丽江坐车到大理</p>
<p><img data-src="http://ww1.sinaimg.cn/large/005M2pcYgy1g746p2czg4j31ki0qaah2.jpg" alt="WechatIMG6.png"></p>
</li>
<li><p>3 号晚上住大理</p>
</li>
<li><p>4 号白天逛大理的景点</p>
</li>
<li><p>4 号晚上住大理</p>
</li>
<li><p>5 号白天逛大理的景点</p>
</li>
<li><p>5 号晚上从大理坐车到昆明</p>
<p><img data-src="http://ww1.sinaimg.cn/large/005M2pcYgy1g746s5bm7bj31lq0z6gup.jpg" alt="WechatIMG7.png"></p>
</li>
<li><p>5 号晚上住昆明</p>
</li>
<li><p>6 号白天逛昆明的景点</p>
</li>
<li><p>6 号晚上住昆明</p>
</li>
<li><p>7 号早上从昆明坐车返程</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Why BiliBili and YouTube Attract you</title>
    <url>/2020/03/18/Why-BiliBili-and-YouTube-Attract-you/</url>
    <content><![CDATA[<img data-src="https://ib11.go2yd.com/image.php?url=0LQrZAhRZy" width="100%"/>

<a id="more"></a>

<h2 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h2><h3 id="BiliBili"><a href="#BiliBili" class="headerlink" title="BiliBili"></a>BiliBili</h3><blockquote>
<p><a href="https://www.zhihu.com/question/39269323" target="_blank" rel="noopener">为什么b站会受这么多人喜欢？？ - 知乎</a></p>
<p><a href="https://36kr.com/p/5272775" target="_blank" rel="noopener">你复制不了B站的社区氛围_详细解读_最新资讯_热点事件_36氪</a></p>
</blockquote>
<ul>
<li><p>相关视频推荐</p>
<p>这个是几乎每个视频网站都有。每个视频播放页面的右侧都是推荐视频的列表，加上标题党的影响，本身就是根据你的喜好推荐的，所以很容易会被这些内容吸引，进而沉迷其中。</p>
</li>
<li><p>没有广告</p>
<p>没人愿意看个视频先看个几十秒甚至100多秒的广告，看到精彩的时候插入十几秒广告。</p>
</li>
<li><p>弹幕多、质量高</p>
<p>虽然有很多撕X的，但是类比起其他网站，B站的弹幕至少还有科普类、预警系列、吐槽类、字幕类的弹幕。</p>
</li>
<li><p>社区氛围好</p>
<p>B站的答题机制、监管力度，保证了在B站发声的人确实发自内心想要融入社区来表达自我。</p>
</li>
</ul>
<h2 id="如何克制"><a href="#如何克制" class="headerlink" title="如何克制"></a>如何克制</h2><blockquote>
<p>娱乐要适度，要尽量克制自己不要沉迷。</p>
</blockquote>
<ul>
<li><p>避免推荐视频的诱惑</p>
<ul>
<li>在选中一个要观看的视频后直接全屏观看</li>
<li>在快结束的时候直接快捷键关闭当前页</li>
</ul>
</li>
<li><p>吃饭时不要看</p>
<p>吃饭时是比较放松的时候，放松的状态下最容易沉迷。</p>
</li>
<li><p>安排一定的时间用来娱乐放松</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Windows</title>
    <url>/2025/07/22/Windows/</url>
    <content><![CDATA[<img data-src="https://www.windowscentral.com/sites/wpcentral.com/files/styles/xlarge/public/field/image/2017/03/cloudwallpaper.jpg?itok=VC2ajDrI" width="100%" />

<a id="more"></a>

<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><blockquote>
<p><a href="https://blog.csdn.net/AinUser/article/details/79247841" target="_blank" rel="noopener">win10专业版激活方法——亲测可行！！！</a></p>
</blockquote>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>Win + L</strong>：锁屏</p>
<p><strong>Shift + F10</strong>：相当于鼠标右键</p>
<h2 id="快速打开"><a href="#快速打开" class="headerlink" title="快速打开"></a>快速打开</h2><h3 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h3><ol>
<li><code>Win + R</code></li>
<li>输入<code>control.exe</code></li>
<li>回车</li>
</ol>
<h3 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h3><ol>
<li><code>Win + R</code></li>
<li>输入<code>sysdm.cpl</code></li>
<li>回车</li>
</ol>
<h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><ol>
<li>Win + R`</li>
<li>输入<code>cacl</code></li>
<li>回车</li>
</ol>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><ol>
<li>Win + R`</li>
<li>输入<code>services.msc</code></li>
<li>回车</li>
</ol>
<h2 id="当前目录下打开控制台"><a href="#当前目录下打开控制台" class="headerlink" title="当前目录下打开控制台"></a>当前目录下打开控制台</h2><p>直接在当前目录栏中输入<code>cmd</code>，然后回车即可。</p>
<h2 id="自动隐藏任务栏"><a href="#自动隐藏任务栏" class="headerlink" title="自动隐藏任务栏"></a>自动隐藏任务栏</h2><p>设置&gt;任务栏&gt;勾选自动隐藏任务栏</p>
<p><img data-src="https://i.loli.net/2018/12/23/5c1f24bb8cc78.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>temp file</title>
    <url>/2019/04/12/temp-file/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="请输入密码，不知道可以联系我" /><label>请输入密码，不知道可以联系我</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="920a4bf78b03bfb8f963c7a7f73e59289435f6ebf73ccf72693bdb8361a437d0">360c8b1eeca3965725cfb73328dc4265664518d1dd3577f99a9ec33dd741c867863947d2159fd7ee5899fa2b39e1c9a3059ee24e2daff7989a42075c3d8dcc7fce9173347a81e96614a635fbbc02920e78c7d4822f2282eaee6bf7434367973913a62b36932e8795f2d3a8cacdc15162f2ac92f84702b179b85ec33caa1d91ba9e83d3ae325b6913d396ee15d32fe99385ac173e3a8031daadf016ac7145085c77666daa48cee79d838a03301c54265870425e9736bcc06f6e77d57064a497c8857939ec56b085134278b88cf7d8f1fc23061f17cff93d874d5b5d547b008a72d8101a6a042a36af00488d622781b04e08e99f2a6e335914d034969b4b452763bcb509c3c24f814f8d3dd7492737c44a50d57d19553e032e737844cf4e4a23df990283221fc1fb3c3840ab298a29a632ec6b0267da5e043b67f22e1a54fb2b6b60a8b068abdd172b40b3eb7a66f074c40e43c15850d286234f8c59527ba9ecfd4382cf88e6870622a0f641b400a871393d8d64bd519ace38e8c34e60b1e2041f49b7834ab292a807bef6969a45aadcf32c47529beb4ddebec0596196ce65171bee8575dee6a1cc5438fec015ffe7bf4b98b0d19faecbafe3b750cb2d729901bf91e9d12251d55cd6a19316fdfffaf62ac2ce3df013746be8ab7eb1cda03b696b950919a4b68ce3d38ceffcd256a9dce02d0605fabacf6e5dfab7fa935cba51697dc59c6cfd75d3fa7e78fdd40ac1f36565ffacd120d698818cab367def22107b59026ed7e9633630cbaec0e7148ff4bf9499d405b8c36df9b59690f1a45773ca59f277b1f55ad73e94d20b8fbfd8ab50e0944ba95c6ccf992071934b2f178aa5a573ca97a508b993b82a9df89905b7358eeaffc17aa4229235595fc92461c79d6dae74f0f70a2b70d629c93ff22cb5fd2217740d53f93b1f44dd94603c0afea837218c64609821b1a3942c1a90834e0b0cda04687efc0d7108ff35e07b1d278bad3cc26123bb98dfb7bfc998e72418c2cae1c17f897a0444de9dd19f577b25964008490fe6f1a20c3412fec299167d85b8310aad655f8c17a9abfaa7d9d93b26f2f8b0dc7aebf21912a5d0a6d968142bfa4c53fed483404cd1665b06f2aa8f4196ca4dcbdaa7c83db9fd1b5cd34865944809b464cae1f0e92f1f9018fcc5af0e971bb696d78f1921156a5050d604a9ac8c0414c211234f28b2f215d2d95284ea958984ecc9047801cbaefd6e7250f3414882f9da42d3e6be39f6667d1486b5da36c2d42b636dbc2e119f97e62b9d69c3a433ede0b0d2ac921b9c8c4077d977615b728ffb4cf8101e6b8dc0bb8a5f27cff3d0df870a79207ca2239e8007f2aa0987bff412ef728e5892f76eb850d9eadd2bbab166ca151bff22c9d6673745c2ec0433111d3ef8d75bbdde28f054dd36afb72213b4cf535549708aaf537770fb69e49ec811dfd313dd0aff486bfda8b43da66fb3714640a0c75e2a10bba406d8dd899841437565a67e53c3f9b8912e4491f1dbc3a3519b677b9c37d3d9af6d555381d6494f8cd04d82c7f39217b103e59818180d4b74c970abaf0ecc51e723bd36a1c2224c8cf33bcdec3311af901ce31c83079eb5ac1031b1e3f29a66c09063c1947d568162047ba677f76d95cc3482831a0bb193d32bc9c8edcc5e3c7e441f425c03a8772b3926bb02f83cb5fe5e602481f5f9a2c158730aa82bb1405001f5829c23be37c098bd5c2bc8ddb3ea328d441cc198814b5366dce7e0d3fd78673c9e1066cfcb16b1aa61551dc8c5c56d5468cd50cefeda3ea43fcfac13a54e74dabe</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Interview</title>
    <url>/2020/10/21/Interview/</url>
    <content><![CDATA[<img data-src="https://resources.workable.com/wp-content/uploads/2018/05/prepare-interviews-featured.png" width="100%"/>

<a id="more"></a>

<blockquote>
<p><a href="https://github.com/Snailclimb" target="_blank" rel="noopener">Snailclimb</a>/<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></p>
<p><a href="https://github.com/CyC2018" target="_blank" rel="noopener">CyC2018</a>/<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-Notes</a></p>
<p><a href="https://xiaozhuanlan.com/javainterview?rel=javaguide" target="_blank">《Java 面试进阶指南》</a> </p>
</blockquote>
<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><blockquote>
<p><a href="https://v2ex.com/t/671405" target="_blank" rel="noopener">前天面试被怼哭,找工作找到崩溃,求各路上仙指点 | V2EX</a></p>
</blockquote>
<p>给些建议，望加油：<br>\1. 写简历不能只站在自己角度思考，需要站在 HR 和面试官角度多多思考，这是他们需要的候选人么？如果自己是面试官，看到这份简历，自己会满意么？<br>\2. 如果你能理解我第一个问题，你就会意识到简历不能只有一份<br>\3. 简历太多 general words，如”负责处理用户使用过程中遇到的问题,数据不一致, 代码行数统计错误相关“这条，我很难看出你到底用了什么解决方案解决了这个问题，另这个问题是大问题么？可能就是个小 bug ？这些疑问过多，让我难以判断你的价值</p>
<p>小老弟 性格有点意思 我就说几句 你简历的问题吧<br>英语六级 是我觉得简历的最大亮点<br>学校太一般。<br>外包确实不好，但是你的简历呈现出外包的水准是你的问题，不是面试官的问题！</p>
<p>用熟悉 理解 了解 ，对个人技能 比如消息队列 多线程 并发 GC 进行描述<br>不要出现工具 IDEA Eclipse svn<br>最多写个人开发工具比如 iterm+idea+git<br>中间件 redis rabbitmq kafka es 等 会的写上去 ，最好要看过这些中间件特点的核心源码。不然就只能写 liaojie<br>springboot 这个要源码级别了解 对于你这样工作经验少的人来说，</p>
<p>项目描述上 用 什么样的技术方案实现什么业务场景，用什么技术，或者技术选型解决特定场景问题，诸如性能问题，查询吞吐量提升。是 star 法则的描述。<br>简历不要写得太八婆</p>
<p>简历可以用 QQ 邮箱简历模块，然后网页选择打印 就可以以 pdf 形式出来了</p>
<p>不聊外包是不是低下，学历会不会被筛，楼主心态够不够好，错别字是不是太多这些废话。我就说下简历怎么改会更好一些。<br>我认为简历应该是一个引子，是一个提纲，甚至像一个预告片，用最短的句子介绍你的工作经验，告诉面试官你具备解决哪些业务问题的能力。让面试官看完简历以后对你的能力有一个感知上的预期：</p>
<p>“这个人应该是知道怎么做视频直播”<br>“这个人对 web 富文本编辑器的经验好像还 OK”<br>“这个人对状态管理有自己的经验”<br>“这个人能把自动化测试、构建效率提升起来”</p>
<p>这样才产生“这个人值得一面的想法”。<br>不管个人能力如何，突出这些重点的简历，才算是到达了目的的简历。下面逐条说明你简历里的问题：</p>
<p>\1. 项目描述应该精简地说这个项目干了什么。你的表述废话太多，例如：<br>“产出看板项目主要是对公司个人产出的一个度量，该项目从其他各个系统采集数据，主要包括项目管理，开发，测试，设计等四个岗位人员各个指标的数据。以个人维度和部门维度来展示个人或者部门某天或者某几个月的产出活动和所作的贡献。”107 个字。</p>
<p>改为：“展示每个员工各项量化工作数据的考评面板。通过接入不同岗位的数据库完成数据的采集。”40 个字。</p>
<p>一句话讲清楚这个系统就是一个用来展示量化后的工作产出的面板。<br>那么这个系统的核心就是量化的工作数据，自然看简历的人就会有疑问，这些数据是哪里来的？是需要主动录入到你这个系统，还是你这个系统从别的地方采集的？因为这决定了这个项目的复杂度。<br>那么第二句话就解释了这个可能的疑问：是从其他系统采集来的。<br>这样面试官就能获得一个信息“这个人是知道不同的后台业务系统之间是怎么通信的”。</p>
<p>再回过头看那 107 个字的原表述，有两句废话，分别可以归纳为“杂余信息”和“复读常识”两点。</p>
<p>1.1 杂余信息<br>比如“要包括项目管理，开发，测试，设计等四个岗位人员各个指标的数据”，就是不重要的杂余细节，面试官不关心你们公司到底有多少种不同的岗位。当然，如果在处理“接入不同岗位的数据库”这件事时，因为岗位不同而作了一些兼容逻辑并且做的也不错的话，可以在面试的时候详细展开。这是值得讲的。</p>
<p>1.2 复读常识<br>比如“以个人维度和部门维度来展示个人或者部门某天或者某几个月的产出活动和所作的贡献.”，这就是一句话废话。这不就是“工作产出”吗？<br>我知道你想说这个面板可以以月 /日、人 /部门等不同纬度去查看工作产出，可这难道不是一个考评面板本该有的基本能力吗？房产中介会跟你提房子的采光、通风、学区，但他不会和你强调“这个房子是有厕所的”。</p>
<p>再比如“畜牧专家电商平台”这个项目，原表述是 122 个字，可以改为“兽药商城、问答社区、咨询阅读”。<br>那么面试官大致就会知道，这个人做过商城、问答、文章阅读这些业务，也就对你会掌握的一些能力有一个大致的预期。<br>（虽然我觉得你这个项目应该水分很大，商城和问答都是很重的业务，怎么可能放在一起都做了。）</p>
<p>\2. 技术架构不是堆砌技术词汇。架构二字至少从中文上理解，也是一个结构性的东西，陈列“springboot+Tomcat+Mysql+git+Maven” 5 个技术词汇只能说你用到了这些工具，不能称之为架构，你这么写反而显得你非常不专业。比如产出面板这个项目其实就简单到没什么所谓的架构值得一提，你就不应该单独列出来。</p>
<p>\3. “负责内容”首先要写清晰，到达清晰了再去追求“写出亮点”。下面举几个不清晰的例子：</p>
<p>- “负责技术文章模块的开发,富文本编辑器, 实现了文章的新增编辑和查找, 同时支持用户对文章评论功能”<br>其实你只是做了文章的发布、搜索和评论（应该就是很简单的搜索），富文本编辑器应该是你直接用了第三方的库。但是你“技术文章模块的开发，富文本编辑器”这样的表述会让人一眼扫过去，以为富文本编辑器是你做的，但是细品了一下会想到这估计不可能，进而产生这个人在给工作内容灌水的感觉。</p>
<p>- “对于一些商品重复显示的页面, 为了提高效率降低代码重复率, 采用了 freemarker 页面静态技术优化”<br>这句话完全是不可理解的，我看到以后脑子里只有三个问号：<br>商品在页面里重复显示不是很正常的吗？一个商品出现在搜索结果里的同时可能也会出现在侧栏的推荐位里啊<br>这和代码重复率有什么关系？<br>freemarker 又是什么？<br>HTML 页面本身不就是静态的吗？静态技术优化这种只在特定语境里才能理解的抽象的、自我发明的技术词汇究竟是什么？</p>
<p>如果简历是一份代码的话，我现在要给你报 5 个 not undefined 的 Error 。</p>
<p>- “负责合同管理工作流对应的数据表对应关系,及相关业务逻辑代码的编写”<br>你做了相关业务逻辑的编写，那你写的应该是“实现工作流和数据表的对应”吧。你没解释工作流是什么，数据表又是什么，以及为什么需要这个对应关系。全靠人猜，而且很难猜。<br>以及，对应关系就是在数据层面做了一个关联吧？难点在哪里？你没有解释清楚，是时效性的维护？还是一致性的维护？我猜不出来，看你简历的人更没耐心去猜。</p>
<p>总之负责内容这块看下来，直觉就是很不清晰。靠自己去猜了一下你实际上做的工作内容是什么，然后感觉比较碎、有些水。<br>但是可以先做到把工作内容讲清楚，无论如何这是第一步。</p>
<p>4 用 xx 第三方库实现了 xx 这种就不要写了，比如法务系统里那个“合同页面导出到 word”。这不是你做的，是这个 xx 库做的，你只是一个搬运工。除非这个第三方库有坑，你改这个库或者做了一层 cover 把坑填了，这才值得写。</p>
<p>5.版本管理工具这种就不要提了。还是那句话，不要复读常识。当然除非你在工作中根据自己的项目情况制定了一套类似 git flow 的版本管理经验，这才值得写。</p>
<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>你好，我叫李博，木子李，博士的博。94年的，今年是26。籍贯是陕西。</p>
<p>17年毕业于延安大学，专业是信息与计算科学。</p>
<p>毕业后就来了深圳工作，到目前为止是有三年多的工作经验。</p>
<p>平常工作中主要使用的是 Spring Boot、MyBatis 等框架，数据库使用过关系型的 MySQL 和 Oracle，文档型的使用过 MongDB，以及内存型的数据库 Redis。</p>
<p>目前最近的项目是前后端分离开发的项目，后端使用的 Spring Cloud 的微服务架构，前段使用的是 Vue.js 结合 Element-UI 组件库开发的。</p>
<p>大体的情况就是这些。</p>
<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="OPP"><a href="#OPP" class="headerlink" title="OPP"></a>OPP</h3><p>面向过程编程（英语：Procedure-oriented Programming，缩写：OPP）</p>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>面向对象编程（英语：Object-oriented programming，缩写：OOP）</p>
<h4 id="OPP-vs-OOP"><a href="#OPP-vs-OOP" class="headerlink" title="OPP vs OOP"></a>OPP vs OOP</h4><p>面向过程的程序设计<span style="color: red">把</span>计算机程序<span style="color: red">视为</span>一系列的<strong>命令集合</strong>，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计<span style="color: red">把</span>计算机程序<span style="color: red">视为</span>一组<strong>对象的集合</strong>，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，<strong>计算机程序的执行就是一系列消息在各个对象之间传递</strong>。</p>
<h4 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h4><p>面向对象的三大特征：封装、继承、多态</p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>把数据以及对数据的操作封装在一个类里。</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>父类引用指向子类对象。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>在软件行业，AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程</p>
<p>Spring AOP 的实现原理：动态代理</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器是一种用来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</p>
<p>布隆过滤器（Bloom Filter）是由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ol>
<li>使用哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<h4 id="判断一个元素是否存在"><a href="#判断一个元素是否存在" class="headerlink" title="判断一个元素是否存在"></a>判断一个元素是否存在</h4><ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li><p>判断给定数据是否存在：</p>
<ul>
<li>比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）</li>
<li>防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）</li>
<li>邮箱的垃圾邮件过滤</li>
<li>黑名单功能</li>
</ul>
</li>
<li><p>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</p>
</li>
</ol>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Google-Guava-的布隆过滤器"><a href="#Google-Guava-的布隆过滤器" class="headerlink" title="Google Guava 的布隆过滤器"></a>Google Guava 的布隆过滤器</h5><p>创建了一个最多存放 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之一（0.01）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">  Funnels.integerFunnel(),</span><br><span class="line">  <span class="number">1500</span>,</span><br><span class="line">  <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h5><p>Guava 提供的布隆过滤器的实现只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，就需要用到 Redis 中的布隆过滤器了。</p>
<p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。</p>
<p>官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module。</p>
<h6 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h6><ol>
<li><strong><code>BF.ADD</code></strong>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD {key} {item}</code>。</li>
<li><strong><code>BF.MADD</code></strong>: 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD {key} {item} [item ...]</code> 。</li>
<li><strong><code>BF.EXISTS</code></strong> : 确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS {key} {item}</code>。</li>
<li><strong><code>BF.MEXISTS</code></strong> ： 确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS {key} {item} [item ...]</code>。</li>
</ol>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.ADD myFilter javaguide</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter javaguide</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS myFilter github</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>B树（balance tree）可以认为是 m 叉的多路平衡查找树</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><blockquote>
<p><a href="https://blog.csdn.net/login_sonata/article/details/75268075" target="_blank" rel="noopener">b树和b+树的区别</a></p>
</blockquote>
<ul>
<li>B+树的中间节点不保存数据，只在叶子结点中保存数据；而B树数据分布在整颗树中。</li>
<li>B+树的叶子结点按顺序链接，可以很方便的进行<strong>范围查找</strong>。</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="5-个特性"><a href="#5-个特性" class="headerlink" title="5 个特性"></a>5 个特性</h4><ol>
<li>每个节点要么是红色，要么是黑色；</li>
<li>根节点永远是黑色的；</li>
<li>所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；</li>
<li>每个红色节点的两个子节点一定都是黑色；</li>
<li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li>
</ol>
<p>HashMap 为什么要使用红黑树？</p>
<p>红黑树是基于二叉查找树的改造，二叉查找树具有平衡性和有序性的特点，能够支持快速的查找功能，但完全平衡树的维护成本比较高，红黑树采用的“适度平衡”标准，可以保证每次插入或删除操作后的重平衡过程，全树拓扑结构的更新仅涉及常数个节点。<strong>尽管最坏情况下需对多达logn个节点重染色，但就分摊意义而言仅为O(1)个。</strong></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>排序算法的成本模型是比较和交换的次数。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p>
<p><a href="https://camo.githubusercontent.com/7d5779d6bf5f57e00e5e48e49437a74a4d7e3cf7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62633662653264302d656435652d346465662d383965352d3361646139616661383131612e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/7d5779d6bf5f57e00e5e48e49437a74a4d7e3cf7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62633662653264302d656435652d346465662d383965352d3361646139616661383131612e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> min = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(nums[j], nums[min])) &#123;</span><br><span class="line">          min = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p>
<p><a href="https://camo.githubusercontent.com/c121fd9d4776aa05f1577a863250cacce1f9fb93/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30663864313738622d353264382d343931622d396466642d3431653035613935323537382e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/c121fd9d4776aa05f1577a863250cacce1f9fb93/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30663864313738622d353264382d343931622d396466642d3431653035613935323537382e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">boolean</span> isSorted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !isSorted; i--) &#123;</span><br><span class="line">      isSorted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(nums[j + <span class="number">1</span>], nums[j])) &#123;</span><br><span class="line">          isSorted = <span class="keyword">false</span>;</span><br><span class="line">          swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p>
<p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p>
<p>插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p>
<ul>
<li>平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；</li>
<li>最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；</li>
<li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/3e2e38e4ded17c7d4cd6945710d1d51d26118268/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33353235336661342d663630612d346533622d616165632d3866633833356161626461632e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/3e2e38e4ded17c7d4cd6945710d1d51d26118268/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33353235336661342d663630612d346533622d616165632d3866633833356161626461632e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j], nums[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">        swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p>
<p><a href="https://camo.githubusercontent.com/1ca2add89effbf569df135b2ae0c1057a5de1049/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37383138633537342d393761382d343864622d386536322d3862666230333062303262612e706e67" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/1ca2add89effbf569df135b2ae0c1057a5de1049/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37383138633537342d393761382d343864622d386536322d3862666230333062303262612e706e67" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">      h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) &#123;</span><br><span class="line">          swap(nums, j, j - h);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p>
<p><a href="https://camo.githubusercontent.com/ad8dbcf111d93c5fe575e1ce147599aefcabdd36/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65633834303936372d643132372d346461332d623662622d3138363939366335363734362e706e67" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/ad8dbcf111d93c5fe575e1ce147599aefcabdd36/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65633834303936372d643132372d346461332d623662622d3138363939366335363734362e706e67" alt="img"></a></p>
<h5 id="1-归并方法"><a href="#1-归并方法" class="headerlink" title="1. 归并方法"></a>1. 归并方法</h5><p>归并方法将数组中两个已经排序的部分归并成一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> T[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= h; k++) &#123;</span><br><span class="line">      aux[k] = nums[k]; <span class="comment">// 将数据复制到辅助数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= h; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; m) &#123;</span><br><span class="line">        nums[k] = aux[j++];</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; h) &#123;</span><br><span class="line">        nums[k] = aux[i++];</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i].compareTo(aux[j]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums[k] = aux[i++]; <span class="comment">// 先进行这一步，保证稳定性</span></span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nums[k] = aux[j++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-自顶向下归并排序"><a href="#2-自顶向下归并排序" class="headerlink" title="2. 自顶向下归并排序"></a>2. 自顶向下归并排序</h5><p>将一个大数组分成两个小数组去求解。</p>
<p>因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Up2DownMergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    aux = (T[]) <span class="keyword">new</span> Comparable[nums.length];</span><br><span class="line">    sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h &lt;= l) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">    sort(nums, l, mid);</span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">    merge(nums, l, mid, h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-自底向上归并排序"><a href="#3-自底向上归并排序" class="headerlink" title="3. 自底向上归并排序"></a>3. 自底向上归并排序</h5><p>先归并那些微型数组，然后成对归并得到的微型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Down2UpMergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    aux = (T[]) <span class="keyword">new</span> Comparable[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz += sz) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz) &#123;</span><br><span class="line">        merge(nums, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="1-基本算法"><a href="#1-基本算法" class="headerlink" title="1. 基本算法"></a>1. 基本算法</h5><ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/eda7de5fb7b862056b35daa26b290481a66f4475/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323334656233642d636366322d343938372d613732342d3233356165663639353762312e706e67" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/eda7de5fb7b862056b35daa26b290481a66f4475/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323334656233642d636366322d343938372d613732342d3233356165663639353762312e706e67" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    shuffle(nums);</span><br><span class="line">    sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h &lt;= l)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">    sort(nums, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(nums, j + <span class="number">1</span>, h);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Comparable&gt; list = Arrays.asList(nums);</span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    list.toArray(nums);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-切分"><a href="#2-切分" class="headerlink" title="2. 切分"></a>2. 切分</h5><p>取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</p>
<p><a href="https://camo.githubusercontent.com/ffc612e3e9f579a35c1bf2a68b368055cd5eabfc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63343835393239302d653237642d346631322d626563662d6532613563316633613237352e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/ffc612e3e9f579a35c1bf2a68b368055cd5eabfc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63343835393239302d653237642d346631322d626563662d6532613563316633613237352e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">  T v = nums[l];</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (less(nums[++i], v) &amp;&amp; i != h) ;</span><br><span class="line">    <span class="keyword">while</span> (less(v, nums[--j]) &amp;&amp; j != l) ;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    swap(nums, i, j);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(nums, l, j);</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h5><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p>
<h5 id="4-算法改进"><a href="#4-算法改进" class="headerlink" title="4. 算法改进"></a>4. 算法改进</h5><h6 id="4-1-切换到插入排序"><a href="#4-1-切换到插入排序" class="headerlink" title="4.1 切换到插入排序"></a>4.1 切换到插入排序</h6><p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</p>
<h6 id="4-2-三数取中"><a href="#4-2-三数取中" class="headerlink" title="4.2 三数取中"></a>4.2 三数取中</h6><p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。</p>
<h6 id="4-3-三向切分"><a href="#4-3-三向切分" class="headerlink" title="4.3 三向切分"></a>4.3 三向切分</h6><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeWayQuickSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">QuickSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h &lt;= l) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lt = l, i = l + <span class="number">1</span>, gt = h;</span><br><span class="line">    T v = nums[l];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">      <span class="keyword">int</span> cmp = nums[i].compareTo(v);</span><br><span class="line">      <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(nums, lt++, i++);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(nums, i, gt--);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, l, lt - <span class="number">1</span>);</span><br><span class="line">    sort(nums, gt + <span class="number">1</span>, h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-基于切分的快速选择算法"><a href="#5-基于切分的快速选择算法" class="headerlink" title="5. 基于切分的快速选择算法"></a>5. 基于切分的快速选择算法</h5><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p>
<p>可以利用这个特性找出数组的第 k 个元素。</p>
<p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">(T[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (h &gt; l) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">      h = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h5><p>堆中某个节点的值总是大于等于或小于等于其子节点的值，并且堆是一颗完全二叉树。</p>
<p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p>
<p><a href="https://camo.githubusercontent.com/e35f8858d4eef74d1f2ebd9e375f712ed30ba7c1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66343838383363382d396438612d343934652d393961342d3331376438646462383535322e706e67" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/e35f8858d4eef74d1f2ebd9e375f712ed30ba7c1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66343838383363382d396438612d343934652d393961342d3331376438646462383535322e706e67" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T[] heap;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.heap = (T[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    T t = heap[i];</span><br><span class="line">    heap[i] = heap[j];</span><br><span class="line">    heap[j] = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-上浮和下沉"><a href="#2-上浮和下沉" class="headerlink" title="2. 上浮和下沉"></a>2. 上浮和下沉</h5><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p>
<p><a href="https://camo.githubusercontent.com/8834662976c5fff405ba8b697a5a694dfd53f3d0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39396435653834652d666332612d343961332d383235392d3864653237343631373735362e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/8834662976c5fff405ba8b697a5a694dfd53f3d0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39396435653834652d666332612d343961332d383235392d3864653237343631373735362e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">    swap(k / <span class="number">2</span>, k);</span><br><span class="line">    k = k / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p>
<p><a href="https://camo.githubusercontent.com/ed9e4c1c03e7af351d0e312ddd2e574e458a3be9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34626635653366622d613238352d343133382d623362362d3738303935366562316466312e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/ed9e4c1c03e7af351d0e312ddd2e574e458a3be9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34626635653366622d613238352d343133382d623362362d3738303935366562316466312e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">      j++;</span><br><span class="line">    <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    swap(k, j);</span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h5><p>将新元素放到数组末尾，然后上浮到合适的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable v)</span> </span>&#123;</span><br><span class="line">  heap[++N] = v;</span><br><span class="line">  swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4. 删除最大元素"></a>4. 删除最大元素</h5><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T max = heap[<span class="number">1</span>];</span><br><span class="line">  swap(<span class="number">1</span>, N--);</span><br><span class="line">  heap[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">  sink(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h5><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p>
<h6 id="5-1-构建堆"><a href="#5-1-构建堆" class="headerlink" title="5.1 构建堆"></a>5.1 构建堆</h6><p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p>
<p><a href="https://camo.githubusercontent.com/e0c6925e9a108b4a2a959993770d7d28431dba2c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63326361386464322d386430302d346133652d626563652d6462373834396163396366642e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/e0c6925e9a108b4a2a959993770d7d28431dba2c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63326361386464322d386430302d346133652d626563652d6462373834396163396366642e676966" alt="img"></a></p>
<h6 id="5-2-交换堆顶元素与最后一个元素"><a href="#5-2-交换堆顶元素与最后一个元素" class="headerlink" title="5.2 交换堆顶元素与最后一个元素"></a>5.2 交换堆顶元素与最后一个元素</h6><p>交换之后需要进行下沉操作维持堆的有序状态。</p>
<p><a href="https://camo.githubusercontent.com/832b0a4113917a79bffa3b94ccc57f0840d2b912/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64313536626364612d616338642d343332342d393565302d3063386466343135363763392e676966" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/832b0a4113917a79bffa3b94ccc57f0840d2b912/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64313536626364612d616338642d343332342d393565302d3063386466343135363763392e676966" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">      sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">      sink(nums, <span class="number">1</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(T[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; N &amp;&amp; less(nums, j, j + <span class="number">1</span>))</span><br><span class="line">        j++;</span><br><span class="line">      <span class="keyword">if</span> (!less(nums, k, j))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      swap(nums, k, j);</span><br><span class="line">      k = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(T[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-分析"><a href="#6-分析" class="headerlink" title="6. 分析"></a>6. 分析</h5><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p>
<p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p>
<p>堆排序是一种原地排序，没有利用额外的空间。</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="1-排序算法的比较"><a href="#1-排序算法的比较" class="headerlink" title="1. 排序算法的比较"></a>1. 排序算法的比较</h5><table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>×</td>
<td>N2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N2</td>
<td>1</td>
<td>时间复杂度和初始顺序有关</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
<td>改进版插入排序</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
<td></td>
</tr>
<tr>
<td>三向切分快速排序</td>
<td>×</td>
<td>N ~ NlogN</td>
<td>logN</td>
<td>适用于有大量重复主键</td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
<td>无法利用局部性原理</td>
</tr>
</tbody></table>
<p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p>
<p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h3 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h3><h2 id="Java-语言"><a href="#Java-语言" class="headerlink" title="Java 语言"></a>Java 语言</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h4><p>多态的三个条件：</p>
<ol>
<li>要有继承关系</li>
<li>子类要重写父类的方法</li>
<li>父类引用指向子类对象</li>
</ol>
<h4 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h4><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>
<h4 id="Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"><a href="#Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？" class="headerlink" title="Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"></a>Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</h4><p>Java<strong>中</strong>有8种基本数据类型，分别为：</p>
<ol>
<li>6种数字类型 ：byte、short、int、long、float、double</li>
<li>1种字符类型：char</li>
<li>1种布尔型：boolean。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<h4 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h4><p>Java 对对象的传递，传递的是对象引用的一份拷贝，虽然会可以通过引用修改对象的状态，但出了方法后原变量的引用并没有改变，即对象引用是按值传递的。</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="哪些地方会自动拆装箱"><a href="#哪些地方会自动拆装箱" class="headerlink" title="哪些地方会自动拆装箱"></a>哪些地方会自动拆装箱</h4><ol>
<li>将基本数据类型放入集合类</li>
<li>包装类型和基本类型的大小比较</li>
<li>包装类型的运算</li>
<li>函数参数与返回值</li>
</ol>
<h4 id="java-是否存在使得语句-i-gt-j-i-lt-j-结果为-false-的-i、j-值？"><a href="#java-是否存在使得语句-i-gt-j-i-lt-j-结果为-false-的-i、j-值？" class="headerlink" title="java 是否存在使得语句 i &gt; j || i &lt;= j 结果为 false 的 i、j 值？"></a>java 是否存在使得语句 <code>i &gt; j || i &lt;= j</code> 结果为 false 的 i、j 值？</h4><p>存在，java 的数值 NaN 代表 not a number，无法用于比较，例如使 <code>i = Double.NaN; j = i;</code> 最后 i == j 的结果依旧为 false。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p><strong>JDK 1.8 之前：</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM运行时数据区域.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="img"></a></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/2019-3Java运行时数据区域JDK1.8.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" alt="img"></a></p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM堆内存结构-JDK7.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt="JVM堆内存结构-JDK7"></a></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM堆内存结构-jdk8.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt="JVM堆内存结构-JDK8"></a></p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">存储内容</th>
<th align="left">锁标记</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无锁</td>
<td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">偏向锁</td>
<td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">指向栈中锁记录的指针</td>
<td align="left">00</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">指向互斥量（重量级锁）的指针</td>
<td align="left">10</td>
</tr>
</tbody></table>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h5 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h5><blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/对象的访问定位-使用句柄.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="对象的访问定位-使用句柄"></a></li>
<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>
</ol>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/对象的访问定位-直接指针.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="对象的访问定位-直接指针"></a></p>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><h5 id="类的生命周期-类加载过程"><a href="#类的生命周期-类加载过程" class="headerlink" title="类的生命周期/类加载过程"></a>类的生命周期/类加载过程</h5><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括 <span style="color: red">7 个阶段</span>。其中准备、验证、解析 3 个部分统称为连接（Linking）。</p>
<p>加载(loading) –&gt; 验证(Verification) –&gt;准备(Preparation) –&gt; 解析(Resolution) –&gt; 初始化(Initialization) –&gt; 使用(Using) –&gt; 卸载(Unloading)</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f14bd8d34554d94a925fab4bbdc7911~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>将 <code>.class</code> 文件加载到 JVM 运行时数据区的<strong>方法区</strong>内，然后在堆中创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。</p>
<p><code>.class</code> 文件来源：</p>
<ol>
<li>本地磁盘</li>
<li>网络下载</li>
<li>zip、jar 等归档文件中</li>
<li>数据库</li>
<li>动态编译 Java 源文件</li>
</ol>
<h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。</p>
<p>包括以下四个阶段的验证：</p>
<ol>
<li><p>文件格式的验证</p>
<p>是否以 <code>0xCAFEBABE</code> 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
</li>
<li><p>元数据的验证</p>
<p>对字节码描述的信息进行语义分析。例如：这个类是否有父类，除了java.lang.Object 之外。</p>
</li>
<li><p>字节码验证</p>
<p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
</li>
<li><p>符号引用验证</p>
</li>
</ol>
<h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p>为类的<span style="color: red">静态变量</span>分配内存，并根据数据类型将其初始化为默认的<span style="color: red">零值</span>(注意不是程序中设置的值)</p>
<p><span style="color: red">注意</span>：如果是常量(static final)，且在声明时就指定了初始值，则会直接赋值为指定值。</p>
<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>将常量池中的符号引用转换为直接引用。</p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>初始化<strong>类变量</strong></p>
<p><strong>类初始化时机</strong>：</p>
<ol>
<li>创建类的实例，也就是 new 一个对象</li>
<li>访问某个类或接口的静态变量</li>
<li>调用类的静态方法</li>
<li>反射 <code>Class.forName(&quot;&quot;)</code></li>
<li>初始化一个类的子类（会首先初始化子类的父类）</li>
<li>JVM 启动时标明的启动类</li>
</ol>
<h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ol>
<li><p>启动类加载器</p>
<p>负责加载 <code>JAVA_HOME\lib</code> 目录中能被虚拟机识别的类，可以通过 <code>Launcher.getBootstrapClassPath().getURLs()</code> 查看。</p>
<p>由 C++ 实现，无法被 Java 程序直接引用。</p>
</li>
<li><p>扩展类加载器</p>
<p>负责加载 <code>JAVA_HOME\lib\ext</code> 目录下的类</p>
</li>
<li><p>应用类加载器</p>
<p>责加载用户类路径（ClassPath）所指定的类</p>
</li>
</ol>
<h6 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h6><p>通过组合的方式实现的继承关系。</p>
<ul>
<li><p>启动类加载器没有父类</p>
</li>
<li><p>扩展类加载器的父类为 null</p>
</li>
<li><p>应用类加载器继承自扩展类加载器</p>
</li>
<li><p>自定义类加载器继承自引用类加载器</p>
</li>
</ul>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>当类加载器收到了类加载的请求，它首先把请求委托给父加载器去完成，当父加载器无法加载时，子加载器才会尝试自己去加载该类。</p>
<h6 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h6><ol>
<li>防止重复加载</li>
<li>保证 Java 基础类的安全性</li>
</ol>
<h6 id="双亲委派模型的破坏者-线程上下文类加载器"><a href="#双亲委派模型的破坏者-线程上下文类加载器" class="headerlink" title="双亲委派模型的破坏者-线程上下文类加载器"></a>双亲委派模型的破坏者-线程上下文类加载器</h6><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI 等，这些 SPI 的接口属于 Java 核心库，一般存在 rt.jar 包中，由 Bootstrap 类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在 classpath 路径下，由于启动类加载器无法直接加载 SPI 的实现类，同时由于双亲委派模式的存在，Bootstrap 类加载器也无法反向委托AppClassLoader 加载器SPI的实现类。在这种情况下，我们就需要线程上下文类加载器。</p>
<p>线程上下文类加载器（contextClassLoader）可以通过<code>java.lang.Thread</code> 类中的<code>getContextClassLoader()</code> 和 <code>setContextClassLoader(ClassLoader cl)</code> 方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是应用类加载器，在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
<p><img data-src="https://img-blog.csdn.net/20170625143404387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>“破坏”是指破坏了父类加载器无法加载子类加载器范围的类这样的规则。</p>
<p>就是通过在父类加载器中使用 <code>Thread.getContextClassLoader()</code> 获取到子类加载器，然后再调用子类加载器的 <code>findClass()</code> 方法去加载。</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt=""></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。</p>
<h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<p>分配担保机制就是进行了 Minor GC 还是无法满足，则将对象存到老年代。</p>
<p><img data-src="https://camo.githubusercontent.com/4d68bf3180587d6c478ff9af5b768bbac73a483aea41fdcd01d37ee6f3a92678/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323032302d382f62343832323863322d616330302d343636382d613738662d3666323231663835363362352e706e67" alt=""></p>
<h4 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h4><ul>
<li><strong>那些内存需要回收？</strong>(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)</li>
<li><strong>什么时候回收？</strong>(堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC)</li>
<li><strong>如何回收？</strong>(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)</li>
</ul>
<h4 id="监测垃圾对象"><a href="#监测垃圾对象" class="headerlink" title="监测垃圾对象"></a>监测垃圾对象</h4><p><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11034259.png" alt=""></p>
<h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> </p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>可作为GC Roots的对象包括下面几种:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<h4 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h4><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/垃圾收集算法.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt="垃圾收集算法分类"></a></p>
<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ol>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/标记-清除算法.jpeg" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpeg" alt="img"></a></p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/90984624.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/90984624.png" alt="复制算法"></a></p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/94057049.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/94057049.png" alt="标记-整理算法 "></a></p>
<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<h4 id="JVM-两种模式的区别"><a href="#JVM-两种模式的区别" class="headerlink" title="JVM 两种模式的区别"></a>JVM 两种模式的区别</h4><p>JVM工作在Server模式可以大大提高性能，但应用的启动会比client模式慢大概10%。</p>
<p>最主要的差别在于：-Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。原因是：</p>
<p>当虚拟机运行在-client模式的时候，使用的是一个代号为C1的轻量级编译器，而-server模式启动的虚拟机采用相对重量级，代号为C2的编译器。C2比C1编译器编译的相对彻底，服务起来之后，性能更高。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/垃圾收集器.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器分类"></a></p>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/46873026.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/46873026.png" alt=" Serial 收集器 "></a></p>
<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短。</p>
<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/22018368.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22018368.png" alt="ParNew 收集器 "></a></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure>

<p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/parllel-scavenge收集器.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/parllel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel Scavenge 收集器 "></a></p>
<p><strong>是JDK1.8默认收集器</strong><br>使用 java -XX:+PrintCommandLineFlags -version命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize&#x3D;262921408 -XX:MaxHeapSize&#x3D;4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">java version &quot;1.8.0_211&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<p>JDK1.8 默认使用的是Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC来禁用该功能</p>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/jvm垃圾回收/CMS收集器.png" target="_blank" rel="noopener"><img data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS 垃圾收集器 "></a></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h5 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h5><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h4 id="JDK-监控和故障处理工具"><a href="#JDK-监控和故障处理工具" class="headerlink" title="JDK 监控和故障处理工具"></a>JDK 监控和故障处理工具</h4><h5 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h5><p>这些命令在 JDK 安装目录下的 bin 目录下：</p>
<ul>
<li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>
<li><strong><code>jstat</code></strong>（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>
<li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li>
<li><strong><code>jmap</code></strong> (Memory Map for Java) :生成堆转储快照;</li>
<li><strong><code>jhat</code></strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li>
<li><strong><code>jstack</code></strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
</ul>
<h5 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h5><h6 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h6><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p>
<h6 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h6><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。</p>
<h4 id="synchronized-锁"><a href="#synchronized-锁" class="headerlink" title="synchronized 锁"></a>synchronized 锁</h4><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>锁一共四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>锁状态存放在JVM对象头中的 Mark Word 中。</p>
<h5 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h5><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，CAS原理及应用即是无锁的实现。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不是通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。</p>
<p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果此时有另一个新线程请求锁，虚拟机会检查对象的Mark Word是否指向该线程的栈帧，没有则说明多个线程竞争锁。该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁(monitor)的指针，此时等待锁的线程都会进入阻塞状态。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>偏向锁通过对象头的Mark Word存储线程ID来减少过多的CAS操作，提高在无竞争环境下的Synchronized效率。</p>
<p>轻量级锁则是通过CAS自旋等待来避免线程的阻塞和唤醒操作，提高在竞争不激烈环境下synchronized的效率。</p>
<h5 id="Synchronized和ReentrantLock在唤醒被挂起线程竞争的时候有什么区别？"><a href="#Synchronized和ReentrantLock在唤醒被挂起线程竞争的时候有什么区别？" class="headerlink" title="Synchronized和ReentrantLock在唤醒被挂起线程竞争的时候有什么区别？"></a>Synchronized和ReentrantLock在唤醒被挂起线程竞争的时候有什么区别？</h5><p>Synchronized和ReentrantLock他们的开销差距是在释放锁时唤醒线程的数量,Synchronized是唤醒锁池里所有的线程+刚好来访问的线程,而ReentrantLock则是当前线程后进来的第一个线程+刚好来访问的线程.</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock上锁的时候如果只有一个线程进来,是不会有线程挂起的操作的,也就是说只需要在AQS里使用CAS改变一个state的值为1</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p><img data-src="https://camo.githubusercontent.com/d1efb1abc3173aa2a607316dda79bea560fe333f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67" alt=""></p>
<table>
<thead>
<tr>
<th>线程不安全</th>
<th>线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>Arraylist</td>
<td>Vector/CopyOnWriteArrayList</td>
</tr>
<tr>
<td>LinkedList</td>
<td>ConcurrentLinkedQueue</td>
</tr>
<tr>
<td>HashMap</td>
<td>ConcurrentHashMap</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h6><blockquote>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析" target="_blank" rel="noopener">通过源码一步一步分析 ArrayList 扩容机制</a></p>
</blockquote>
<ol>
<li><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></li>
<li><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数. </li>
</ol>
<h5 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h5><ol>
<li><strong>底层数据结构：</strong><ul>
<li><code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；</li>
<li><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li>
</ul>
</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>HashSet 底层就是基于 HashMap 实现的。set 中的元素作为 key 存储在 hashmap 中，value 对应set中定义的同一个 Object。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><img data-src="https://camo.githubusercontent.com/bcc4885b038529bc66a48f637c14cc7933ce63da/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303230313130313233343333353833372e706e67" alt=""></p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><h6 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h6><p><img data-src="https://upload-images.jianshu.io/upload_images/13947009-afee4ea47109f9c3.jpg" alt=""></p>
<ol>
<li>计算 key 的 hash 值(hashcode 高位抑或运算)</li>
<li>判断哈希表是否为空，如果为空则进行 <code>resize()</code></li>
<li>根据 hash 值计算数组下标，查看数组对应位置是否有值，没有就直接创建新节点存入</li>
<li>如果存在值则判断 hash 值是否相等、key 是否 equal，如果相等则覆盖旧值。</li>
<li>如果不等，则判断是否是红黑树节点，如果是则进入红黑树 put 操作。</li>
<li>如果不是则表示为链表，循环遍历链表进行插入操作</li>
<li>插入后链表后，链表长度如果大于 8，而哈希表数组长度小于 64，则扩容后 reHash，数组长度大于 64，则将链表转化为红黑树</li>
<li>最后 <code>++modCount</code>，<code>++size</code>，如果size 大与阀值则进行 <code>resize()</code>。</li>
</ol>
<h6 id="哈希表数组长度为什么必须为-2-的幂次方？"><a href="#哈希表数组长度为什么必须为-2-的幂次方？" class="headerlink" title="哈希表数组长度为什么必须为 2 的幂次方？"></a>哈希表数组长度为什么必须为 2 的幂次方？</h6><p>为了通过减法结合按位与操作<strong>代替</strong>取模运算提高性能。</p>
<p><code>a % b == (b-1) &amp; a</code></p>
<p>而只有当 b 是 2 的指数时，等式才成立。</p>
<h6 id="为什么要把-hashcode-与其高位进行抑或运算？"><a href="#为什么要把-hashcode-与其高位进行抑或运算？" class="headerlink" title="为什么要把 hashcode 与其高位进行抑或运算？"></a>为什么要把 hashcode 与其高位进行抑或运算？</h6><p>为了减少哈希碰撞。</p>
<h6 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h6><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h6 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h6><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p>
<h5 id="ConcurentHashMap"><a href="#ConcurentHashMap" class="headerlink" title="ConcurentHashMap"></a>ConcurentHashMap</h5><p>1.8以前的ConcurrentHashMap 的时候, 会初始化一个Segment数组, 容量为16,每个Segment都继承了ReentrantLock类,也就是说每个Segment类本身就是一个锁,之后Segment内部又有一个table数组,而每个table数组里的索引数据又对应着一个HashEntry链表.</p>
<h6 id="ConcurrentHashMap1-8为什么用CAS-Synchronized取代Segment-ReentrantLock"><a href="#ConcurrentHashMap1-8为什么用CAS-Synchronized取代Segment-ReentrantLock" class="headerlink" title="ConcurrentHashMap1.8为什么用CAS+Synchronized取代Segment+ReentrantLock?"></a>ConcurrentHashMap1.8为什么用CAS+Synchronized取代Segment+ReentrantLock?</h6><p>1.8 中的 ConcurrentHashMap，Synchronized是将每一个Node对象作为了一个锁,将锁粒度进一步细化了,也就是说,除非两个线程同时操作一个Node,注意,是一个Node而不是一个Node链表哦,那么才会争抢同一把锁.</p>
<p>如果使用ReentrantLock其实也可以将锁细化成这样的,只要让Node类继承ReentrantLock就行了,这样的话调用f.lock()就能做到和Synchronized(f)同样的效果,但为什么不这样做呢?</p>
<p>请大家试想一下,锁已经被细化到这种程度了,那么出现并发争抢的可能性还高吗?还有就是,哪怕出现争抢了,只要线程可以在30到50次自旋里拿到锁,那么Synchronized就不会升级为重量级锁,而等待的线程也就不用被挂起,我们也就少了挂起和唤醒这个上下文切换的过程开销.</p>
<p>但如果是ReentrantLock呢?它则只有在线程没有抢到锁,然后新建Node节点后再尝试一次而已,不会自旋,而是直接被挂起,这样一来,我们就很容易会多出线程上下文开销的代价.当然,你也可以使用tryLock(),但是这样又出现了一个问题,你怎么知道tryLock的时间呢?在时间范围里还好,假如超过了呢?</p>
<p>所以,在锁被细化到如此程度上,使用Synchronized是最好的选择了.这里再补充一句,Synchronized和ReentrantLock他们的开销差距是在释放锁时唤醒线程的数量,Synchronized是唤醒锁池里所有的线程+刚好来访问的线程,而ReentrantLock则是当前线程后进来的第一个线程+刚好来访问的线程.</p>
<p>如果是线程并发量不大的情况下,那么Synchronized因为自旋锁,偏向锁,轻量级锁的原因,不用将等待线程挂起,偏向锁甚至不用自旋,所以在这种情况下要比ReentrantLock高效</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>四大基类：</p>
<ol>
<li><code>java.io.InputStream</code></li>
<li><code>java.io.OutputStream</code></li>
<li><code>java.io.Reader</code></li>
<li><code>java.io.Writer</code></li>
</ol>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<h4 id="Files-和-Paths"><a href="#Files-和-Paths" class="headerlink" title="Files 和 Paths"></a>Files 和 Paths</h4><p>从 Java 7 开始，提供了 Files 和 Paths 这两个工具类，能极大地方便我们读写文件。</p>
<p>虽然 Files 和 Paths 是 java.nio 包里面的类，但他俩封装了很多读写文件的简单方法。</p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</p>
<h5 id="NIO核心组件"><a href="#NIO核心组件" class="headerlink" title="NIO核心组件"></a>NIO核心组件</h5><p>NIO 包含下面几个核心的组件：</p>
<ul>
<li>Channel(通道)</li>
<li>Buffer(缓冲区)</li>
<li>Selector(选择器)</li>
</ul>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<h4 id="BIO-NIO-AIO-总结"><a href="#BIO-NIO-AIO-总结" class="headerlink" title="BIO,NIO,AIO 总结"></a>BIO,NIO,AIO 总结</h4><p>Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。</p>
<h5 id="如何区分-“同步-异步-”和-“阻塞-非阻塞”-呢？"><a href="#如何区分-“同步-异步-”和-“阻塞-非阻塞”-呢？" class="headerlink" title="如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？"></a>如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？</h5><p>同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。</p>
<h5 id="NIO的特性-NIO与IO区别"><a href="#NIO的特性-NIO与IO区别" class="headerlink" title="NIO的特性/NIO与IO区别"></a>NIO的特性/NIO与IO区别</h5><ol>
<li><p><strong>IO流是阻塞的，NIO流是非阻塞的。</strong></p>
</li>
<li><p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p>
<p>任何时候访问NIO中的数据，都是通过缓冲区进行操作。最常用的缓冲区是 ByteBuffer。</p>
</li>
<li><p>NIO 通过Channel（通道） 进行读写。</p>
<p>通道是双向的，可读也可写，而流的读写是单向的。</p>
</li>
<li><p>NIO有选择器，而IO没有。</p>
<p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。</p>
</li>
</ol>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p><code>java.lang.Thread.State</code>枚举类中定义了六种线程的状态，可以调用线程Thread中的<code>getState()</code>方法<strong>获取当前线程的状态</strong>。</p>
<table>
<thead>
<tr>
<th align="left">线程状态</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NEW</td>
<td align="left">尚未启动的线程状态，即线程创建，<strong>还未调用start方法</strong></td>
</tr>
<tr>
<td align="left">RUNNABLE</td>
<td align="left"><strong>就绪状态</strong>（调用start，等待调度）+<strong>正在运行</strong></td>
</tr>
<tr>
<td align="left">BLOCKED</td>
<td align="left"><strong>等待监视器锁</strong>时，陷入阻塞状态</td>
</tr>
<tr>
<td align="left">WAITING</td>
<td align="left">等待状态的线程正在<strong>等待</strong>另一线程执行特定的操作（如notify）</td>
</tr>
<tr>
<td align="left">TIMED_WAITING</td>
<td align="left">具有<strong>指定等待时间</strong>的等待状态</td>
</tr>
<tr>
<td align="left">TERMINATED</td>
<td align="left">线程完成执行，<strong>终止状态</strong></td>
</tr>
</tbody></table>
<p>下图源自《Java并发编程艺术》图4-1<br><a href="https://img2018.cnblogs.com/blog/1771072/202002/1771072-20200209204908012-1070559737.png" target="_blank" rel="noopener"><img data-src="https://img2018.cnblogs.com/blog/1771072/202002/1771072-20200209204908012-1070559737.png" alt="img"></a></p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><strong><code>volatile</code> 关键字除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p>
<p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h5 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h5><ol>
<li><p>两者都是可重入锁</p>
</li>
<li><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p>
</li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能</p>
<p>主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
</li>
</ol>
<h5 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h5><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong>volatile 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile 性能肯定比 synchronized 关键字要好</strong>。但是<strong>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</li>
<li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong></li>
<li><strong>volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>因为直接调用 run() 方法不会创建新线程去执行，而是当作普通方法在当前线程里执行。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。</li>
</ol>
<h6 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a><code>ThreadPoolExecutor</code> 饱和策略</h6><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h5 id="execute-方法和-submit-方法的区别？"><a href="#execute-方法和-submit-方法的区别？" class="headerlink" title="execute()方法和 submit()方法的区别？"></a>execute()方法和 submit()方法的区别？</h5><ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><h5 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="AtomicInteger 类的原理"></a>AtomicInteger 类的原理</h5><p>AtomicInteger 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    valueOffset = unsafe.objectFieldOffset</span><br><span class="line">      (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ol>
<li><p>ABA问题</p>
<p>假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：</p>
<p>(1)线程1读取内存中数据为A；</p>
<p>(2)线程2将该数据修改为B；</p>
<p>(3)线程2将该数据修改为A；</p>
<p>(4)线程1对数据进行CAS操作</p>
<p>在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。</p>
<p>在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。</p>
<p>对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。</p>
</li>
<li><p>高竞争下的开销问题</p>
<p>在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。</p>
</li>
<li><p>功能限制</p>
<p>CAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，这意味着：(1)原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；(2)当涉及到多个变量(内存值)时，CAS也无能为力。</p>
<p>除此之外，CAS的实现需要硬件层面处理器的支持，在Java中普通用户无法直接使用，只能借助atomic包下的原子类使用，灵活性受到限制。</p>
</li>
</ol>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>AQS 的全称为（AbstractQueuedSynchronizer）</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h5 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h5><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h5 id="用过-CountDownLatch-么？什么场景下用的？"><a href="#用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="用过 CountDownLatch 么？什么场景下用的？"></a>用过 CountDownLatch 么？什么场景下用的？</h5><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h5><ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>
</ul>
<p>乐观锁的实现方式主要有两种：CAS机制和版本号机制。</p>
<h5 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h5><h6 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h6><p>公平锁是指多个线程按照申请锁的顺序来获取锁，锁被占用时直接进入队列中排队。</p>
<p>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐率相对非公平锁要低，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h6 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h6><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p>
<p>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐率高。</p>
<p>缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h5 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h5><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法再获取锁时会自动获得锁，不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<h5 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h5><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，读锁是共享锁，写锁是独享锁。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img data-src="https://images2017.cnblogs.com/blog/401339/201709/401339-20170928225241215-295252070.png" alt=""></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><a href="https://libo9527.github.io/2020/10/22/Design-Pattern-Singleton/" target="_blank" rel="noopener">单例模式</a></h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><blockquote>
<p>Static initializers are run by the JVM at class initialization time, after class loading but before the class is used by any thread. Because the JVM acquires a lock during initialization [JLS 12.4.2] and this lock is acquired by each thread at least once to ensure that the class has been loaded, memory writes made during static initialization are automatically visible to all threads. Thus statically initialized objects require no explicit synchronization either during construction or when being referenced</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载机制保障了饿汉模式的线程安全。JVM 在类加载时会获取一把锁，这把锁在线程访问对象时也会先去争取，确保类已经被加载了。</p>
<h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双重校验锁模式（DCL，即-double-checked-locking）"><a href="#双重校验锁模式（DCL，即-double-checked-locking）" class="headerlink" title="双重校验锁模式（DCL，即 double-checked locking）"></a>双重校验锁模式（DCL，即 double-checked locking）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="为什么要两次判空？"><a href="#为什么要两次判空？" class="headerlink" title="为什么要两次判空？"></a>为什么要两次判空？</h6><p>第一次判空是为了减少无谓的抢夺锁，提升销量。</p>
<p>第二次判空是为了保障不会破坏单例，假设没有第二次判空，线程 1，线程 2 同时通过第一次判空，之后线程 1 获得了锁，并实例化了 instance，之后线程 2 获得锁，又会实例化一遍，破坏了单例模式。</p>
<h6 id="为什么要加-volatile-关键字？"><a href="#为什么要加-volatile-关键字？" class="headerlink" title="为什么要加 volatile 关键字？"></a>为什么要加 volatile 关键字？</h6><blockquote>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/64127789" target="_blank" rel="noopener">彻头彻尾理解单例模式与多线程</a></p>
</blockquote>
<p><code>instance = new Singleton4();</code> 可以被拆解为三条机器指令（伪代码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory &#x3D; allocate();        &#x2F;&#x2F;1:分配对象的内存空间</span><br><span class="line">ctorInstance(memory);       &#x2F;&#x2F;2:初始化对象</span><br><span class="line">instance &#x3D; memory;        &#x2F;&#x2F;3:使 instance 引用指向刚分配的内存地址</span><br></pre></td></tr></table></figure>

<p>由于存在指令重排序，上述三条指令的顺序可能会变成 1、3、2</p>
<p>如果没有使用 volatile，那假设线程 1 已经执行到创建对象的语句了，且刚好执行到重排序后到机器指令 3，此时 instance 已经不是 null 了，其他线程就会获取到一个没有完整初始化的 instance 对象，进而造成未知错误。</p>
<h5 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类模式综合了懒汉和饿汉模式，既满足线程安全，又满足延迟加载。</p>
<h5 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a>枚举单例模式</h5><blockquote>
<p>《Effective Java》作者认为该模式是单例模式的最佳实践。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h4><p>私有化构造器并不能阻止反射攻击。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">  Singleton1 instance = Singleton1.getInstance();</span><br><span class="line"></span><br><span class="line">  Constructor&lt;Singleton1&gt; declaredConstructor = Singleton1<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">  declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Singleton1 instance1 = declaredConstructor.newInstance();</span><br><span class="line">  System.out.println(instance == instance1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>反射攻击枚举单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">  Singleton6 instance = Singleton6.INSTANCE;</span><br><span class="line"></span><br><span class="line">  Constructor&lt;Singleton6&gt; declaredConstructor = Singleton6<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">  declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Singleton6 instance2 = declaredConstructor.newInstance();</span><br><span class="line">  System.out.println(instance == instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.gzhennaxia.demo.singleton.Singleton6.&lt;init&gt;()</span><br><span class="line">	at java.lang.Class.getConstructor0(Class.java:3082)</span><br><span class="line">	at java.lang.Class.getDeclaredConstructor(Class.java:2178)</span><br></pre></td></tr></table></figure>

<p>报错说找不到空构造方法，但即使手动添加了空构造方法同样会报这个错，因为 Java 编译器会为每个构造器自动添加两个参数，这点从反编译文件中可以看出（只有一个 <code>com/gzhennaxia/demo/singleton/Singleton6.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</code> 双参构造器）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /Users/libo/Documents/GitHub/projects/demo/src/main/java/com/gzhennaxia/demo/singleton/Singleton6<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020年10月22日</span>; size <span class="number">921</span> bytes</span><br><span class="line">  MD5 checksum bf867cdc275213b5182d9e511c593cad</span><br><span class="line">  Compiled from <span class="string">"Singleton6.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">gzhennaxia</span>.<span class="title">demo</span>.<span class="title">singleton</span>.<span class="title">Singleton6</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">com</span>.<span class="title">gzhennaxia</span>.<span class="title">demo</span>.<span class="title">singleton</span>.<span class="title">Singleton6</span>&gt;</span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">56</span></span><br><span class="line">  flags: (<span class="number">0x4031</span>) ACC_PUBLIC, ACC_FINAL, ACC_SUPER, ACC_ENUM</span><br><span class="line">  this_class: #4                          // com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">  super_class: #10                        // java/lang/Enum</span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">2</span>, methods: <span class="number">4</span>, attributes: <span class="number">2</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Fieldref           #4.#29         // com/gzhennaxia/demo/singleton/Singleton6.$VALUES:[Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">   #2 = Methodref          #30.#31        // "[Lcom/gzhennaxia/demo/singleton/Singleton6;".clone:()Ljava/lang/Object;</span><br><span class="line">   #3 = Class              #14            // "[Lcom/gzhennaxia/demo/singleton/Singleton6;"</span><br><span class="line">   #4 = Class              #32            // com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">   #5 = Methodref          #10.#33        // java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">   #6 = Methodref          #10.#34        // java/lang/Enum."&lt;init&gt;":(Ljava/lang/String;I)V</span><br><span class="line">   #7 = String             #11            // INSTANCE</span><br><span class="line">   #8 = Methodref          #4.#34         // com/gzhennaxia/demo/singleton/Singleton6."&lt;init&gt;":(Ljava/lang/String;I)V</span><br><span class="line">   #9 = Fieldref           #4.#35         // com/gzhennaxia/demo/singleton/Singleton6.INSTANCE:Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #10 = Class              #36            // java/lang/Enum</span><br><span class="line">  #11 = Utf8               INSTANCE</span><br><span class="line">  #12 = Utf8               Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #13 = Utf8               $VALUES</span><br><span class="line">  #14 = Utf8               [Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #15 = Utf8               values</span><br><span class="line">  #16 = Utf8               ()[Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #17 = Utf8               Code</span><br><span class="line">  #18 = Utf8               LineNumberTable</span><br><span class="line">  #19 = Utf8               valueOf</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #21 = Utf8               &lt;init&gt;</span><br><span class="line">  #22 = Utf8               (Ljava/lang/String;I)V</span><br><span class="line">  #23 = Utf8               Signature</span><br><span class="line">  #24 = Utf8               ()V</span><br><span class="line">  #25 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #26 = Utf8               Ljava/lang/Enum&lt;Lcom/gzhennaxia/demo/singleton/Singleton6;&gt;;</span><br><span class="line">  #27 = Utf8               SourceFile</span><br><span class="line">  #28 = Utf8               Singleton6.java</span><br><span class="line">  #29 = NameAndType        #13:#14        // $VALUES:[Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #30 = Class              #14            // "[Lcom/gzhennaxia/demo/singleton/Singleton6;"</span><br><span class="line">  #31 = NameAndType        #37:#38        // clone:()Ljava/lang/Object;</span><br><span class="line">  #32 = Utf8               com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">  #33 = NameAndType        #19:#39        // valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">  #34 = NameAndType        #21:#22        // "&lt;init&gt;":(Ljava/lang/String;I)V</span><br><span class="line">  #35 = NameAndType        #11:#12        // INSTANCE:Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">  #36 = Utf8               java/lang/Enum</span><br><span class="line">  #37 = Utf8               clone</span><br><span class="line">  #38 = Utf8               ()Ljava/lang/Object;</span><br><span class="line">  #39 = Utf8               (Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.gzhennaxia.demo.singleton.Singleton6 INSTANCE;</span><br><span class="line">    descriptor: Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">    flags: (<span class="number">0x4019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_ENUM</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.gzhennaxia.demo.singleton.Singleton6[] values();</span><br><span class="line">    descriptor: ()[Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #1                  // Field $VALUES:[Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">         3: invokevirtual #2                  // Method "[Lcom/gzhennaxia/demo/singleton/Singleton6;".clone:()Ljava/lang/Object;</span><br><span class="line">         6: checkcast     #3                  // class "[Lcom/gzhennaxia/demo/singleton/Singleton6;"</span><br><span class="line">         <span class="number">9</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.gzhennaxia.demo.singleton.<span class="function">Singleton6 <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #4                  // class com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">         <span class="number">2</span>: aload_0</span><br><span class="line">         3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">         6: checkcast     #4                  // class com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">         <span class="number">9</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0008</span>) ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #4                  // class com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: ldc           #7                  // String INSTANCE</span><br><span class="line">         <span class="number">6</span>: iconst_0</span><br><span class="line">         7: invokespecial #8                  // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span><br><span class="line">        10: putstatic     #9                  // Field INSTANCE:Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">        <span class="number">13</span>: iconst_1</span><br><span class="line">        14: anewarray     #4                  // class com/gzhennaxia/demo/singleton/Singleton6</span><br><span class="line">        <span class="number">17</span>: dup</span><br><span class="line">        <span class="number">18</span>: iconst_0</span><br><span class="line">        19: getstatic     #9                  // Field INSTANCE:Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">        <span class="number">22</span>: aastore</span><br><span class="line">        23: putstatic     #1                  // Field $VALUES:[Lcom/gzhennaxia/demo/singleton/Singleton6;</span><br><span class="line">        <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #26                          // Ljava/lang/Enum&lt;Lcom/gzhennaxia/demo/singleton/Singleton6;&gt;;</span><br><span class="line">SourceFile: <span class="string">"Singleton6.java"</span></span><br></pre></td></tr></table></figure>

<p>从反编译结果可以看出枚举的实例化调用的是继承自 <code>java.lang.Enum</code> 的 <code>protected Enum(String var1, int var2)</code> 构造器，那是否可以反射调用该构造器来实例化 Singleton6 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">  Singleton6 instance = Singleton6.INSTANCE;</span><br><span class="line"></span><br><span class="line">  Constructor&lt;Singleton6&gt; declaredConstructor = Singleton6<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Singleton6 instance2 = declaredConstructor.newInstance(<span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">  System.out.println(instance == instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:417)</span><br></pre></td></tr></table></figure>

<p>结果报错，查看 java.lang.reflect.Constructor.newInstance (Constructor.java:417)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">      Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">      checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">////////////  417  //////////// </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">  ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">  <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ca = acquireConstructorAccessor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  T inst = (T) ca.newInstance(initargs);</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到反射创建实例的时候会判断类的修饰符中是否有 enum，如果有就抛出 <code>IllegalArgumentException</code> 异常。</p>
<p>因此，<strong>枚举类型可以防止反射攻击</strong>。</p>
<h5 id="非枚举的防守方法"><a href="#非枚举的防守方法" class="headerlink" title="非枚举的防守方法"></a>非枚举的防守方法</h5><p>在构造器中判断实例是否已经存在，存在就抛出异常，保证构造器只被调用一次！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"实例已存在，单例构造器只能被调用一次！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化攻击"><a href="#序列化攻击" class="headerlink" title="序列化攻击"></a>序列化攻击</h4><p>一般类需要实现 <code>Serializable</code> 接口才能被序列化，但枚举类不用，因为枚举类本质是继承了 <code>java.lang.Enum</code> 的，而 Enum 已经声明实现了 <code>Serializable</code>。</p>
<p>一般的单例模式无法防止序列化攻击，经过序列化和反序列化后会创建出新的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Singleton1 instance = Singleton1.getInstance();</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">    objectOutputStream.writeObject(instance);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">    Singleton1 instance1 = (Singleton1) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    System.out.println(instance == instance1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>但是对于枚举类来说，反序列化后还是原来的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">  Singleton6 instance = Singleton6.INSTANCE;</span><br><span class="line"></span><br><span class="line">  ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">  objectOutputStream.writeObject(instance);</span><br><span class="line">  <span class="keyword">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">  ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">  ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">  Singleton6 instance1 = (Singleton6) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">  System.out.println(instance == instance1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>可以看到反序列化枚举后得到的实例和序列化之前的实例是同一个实例。查看 <code>ByteArrayOutputStream.writeObject()</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">    writeObjectOverride(obj);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">      writeFatalException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writeObject0()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// remaining cases</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  depth--;</span><br><span class="line">  bout.setBlockDataMode(oldMode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是枚举类型，会调用 <code>writeEnum()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">(Enum&lt;?&gt; en,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Enum 类型标记：129</span></span><br><span class="line"><span class="comment">     * new Enum constant.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// final static byte TC_ENUM =         (byte)0x7E;</span></span><br><span class="line">  bout.writeByte(TC_ENUM);</span><br><span class="line">  ObjectStreamClass sdesc = desc.getSuperDesc();</span><br><span class="line">  writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);</span><br><span class="line">  handles.assign(unshared ? <span class="keyword">null</span> : en);</span><br><span class="line">  writeString(en.name(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着再看 Enum 类型的反序列化，<code>ObjectInputStream.readObject()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">    <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">  <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">    handles.markDependency(outerHandle, passHandle);</span><br><span class="line">    ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">      vlist.doCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    passHandle = outerHandle;</span><br><span class="line">    <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">      clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectInputStream.readObject0()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> TC_EXCEPTION:</span><br><span class="line">        IOException ex = readFatalException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> WriteAbortedException(<span class="string">"writing aborted"</span>, ex);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">      <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">        <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">          bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">          bin.peek();             <span class="comment">// force header read</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(</span><br><span class="line">            bin.currentBlockRemaining());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            <span class="string">"unexpected block data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">        <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            <span class="string">"unexpected end of block data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">          String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    depth--;</span><br><span class="line">    bin.setBlockDataMode(oldMode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectInputStream.readEnum()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Enum&lt;?&gt; readEnum(<span class="keyword">boolean</span> unshared) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span><br><span class="line">      result = en;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">        <span class="string">"enum constant "</span> + name + <span class="string">" does not exist in "</span> +</span><br><span class="line">        cl).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">      handles.setObject(enumHandle, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handles.finish(enumHandle);</span><br><span class="line">  passHandle = enumHandle;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Enum.valueOf()</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String name)</span> </span>&#123;</span><br><span class="line">  T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">    <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终是根据 <code>name</code> 在枚举类实力数组里查找，所以返回的实例是已经存在的实例，并不会新建实例。</p>
<p>因此<strong>枚举可以防止反序列化攻击</strong>。</p>
<h5 id="非枚举的防守方法-1"><a href="#非枚举的防守方法-1" class="headerlink" title="非枚举的防守方法"></a>非枚举的防守方法</h5><p>增加 <code>readResolve()</code> 方法返回单例，反序列化时会判断对象是否存在该方法，存在则会调用该方法返回对象。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">饿汉模式</th>
<th align="left">懒汉模式</th>
<th align="left">线程安全的懒汉模式</th>
<th align="left">双重校验锁模式</th>
<th align="left">静态内部类单例模式</th>
<th align="left">枚举单例模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">延迟加载</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">线程安全</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">反射攻击 (能否抵御)</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">能</td>
</tr>
<tr>
<td align="left">反序列化攻击 (能否抵御)</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">能</td>
</tr>
</tbody></table>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>《大话设计模式》第2章 商场促销——策略模式</p>
</blockquote>
<h4 id="现金收费抽象类"><a href="#现金收费抽象类" class="headerlink" title="现金收费抽象类"></a>现金收费抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常收费子类"><a href="#正常收费子类" class="headerlink" title="正常收费子类"></a>正常收费子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashNormal</span> <span class="keyword">implements</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打折收费子类"><a href="#打折收费子类" class="headerlink" title="打折收费子类"></a>打折收费子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRebate</span> <span class="keyword">implements</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> moneyRebate = <span class="number">1</span>d;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CashRebate</span><span class="params">(<span class="keyword">double</span> moneyRebate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.moneyRebate = moneyRebate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> money * moneyRebate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返利收费子类"><a href="#返利收费子类" class="headerlink" title="返利收费子类"></a>返利收费子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashReturn</span> <span class="keyword">implements</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> moneyCondition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> moneyReturn;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CashReturn</span><span class="params">(<span class="keyword">double</span> moneyCondition, <span class="keyword">double</span> moneyReturn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.moneyCondition = moneyCondition;</span><br><span class="line">    <span class="keyword">this</span>.moneyReturn = moneyReturn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (money &gt; moneyCondition) &#123;</span><br><span class="line">      money -= (<span class="keyword">int</span>) (money / moneyCondition) * moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h4><h5 id="现金收费工厂类"><a href="#现金收费工厂类" class="headerlink" title="现金收费工厂类"></a>现金收费工厂类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CashSuper <span class="title">createCashAccept</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    CashSuper cashSuper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"正常收费"</span>:</span><br><span class="line">        cashSuper = <span class="keyword">new</span> CashNormal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"满300减100"</span>:</span><br><span class="line">        cashSuper = <span class="keyword">new</span> CashReturn(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"打8折"</span>:</span><br><span class="line">        cashSuper = <span class="keyword">new</span> CashRebate(<span class="number">0.8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cashSuper;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> MONEY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CashSuper cashSuper = CashFactory.createCashAccept(<span class="string">"正常收费"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Primary money="</span>+MONEY+<span class="string">", Final money="</span>+cashSuper.acceptCash(MONEY));</span><br><span class="line"></span><br><span class="line">    CashSuper cashSuper2 = CashFactory.createCashAccept(<span class="string">"满300减100"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Primary money="</span>+MONEY+<span class="string">", Final money="</span>+cashSuper2.acceptCash(MONEY));</span><br><span class="line"></span><br><span class="line">    CashSuper cashSuper3 = CashFactory.createCashAccept(<span class="string">"打8折"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Primary money="</span>+MONEY+<span class="string">", Final money="</span>+cashSuper3.acceptCash(MONEY));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="策略与简单工厂结合"><a href="#策略与简单工厂结合" class="headerlink" title="策略与简单工厂结合"></a>策略与简单工厂结合</h4><h5 id="CashContext类"><a href="#CashContext类" class="headerlink" title="CashContext类"></a>CashContext类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> CashSuper cashSuper;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    CashSuper cashSuper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"正常收费"</span>:</span><br><span class="line">        cashSuper = <span class="keyword">new</span> CashNormal();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"满300减100"</span>:</span><br><span class="line">        cashSuper = <span class="keyword">new</span> CashReturn(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"打8折"</span>:</span><br><span class="line">        cashSuper = <span class="keyword">new</span> CashRebate(<span class="number">0.8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cashSuper = cashSuper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cashSuper.acceptCash(money);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="如何消除switch语句？"><a href="#如何消除switch语句？" class="headerlink" title="如何消除switch语句？"></a>如何消除switch语句？</h6><p>通过反射</p>
<h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> MONEY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CashContext cashContext = <span class="keyword">new</span> CashContext(<span class="string">"正常收费"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Primary money="</span> + MONEY + <span class="string">", Final money="</span> + cashContext.getResult(MONEY));</span><br><span class="line"></span><br><span class="line">    CashContext cashContext2 = <span class="keyword">new</span> CashContext(<span class="string">"满300减100"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Primary money="</span> + MONEY + <span class="string">", Final money="</span> + cashContext2.getResult(MONEY));</span><br><span class="line"></span><br><span class="line">    CashContext cashContext3 = <span class="keyword">new</span> CashContext(<span class="string">"打8折"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Primary money="</span> + MONEY + <span class="string">", Final money="</span> + cashContext3.getResult(MONEY));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单工厂模式-VS-策略模式与简单工厂结合"><a href="#简单工厂模式-VS-策略模式与简单工厂结合" class="headerlink" title="简单工厂模式 VS 策略模式与简单工厂结合"></a>简单工厂模式 VS 策略模式与简单工厂结合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单工厂模式的用法</span></span><br><span class="line">CashSuper cashSuper = CashFactory.createCashAccept(type);</span><br><span class="line">cashSuper.acceptCash(MONEY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//策略模式与简单工厂结合的用法</span></span><br><span class="line">CashContext cashContext = <span class="keyword">new</span> CashContext(type);</span><br><span class="line">cashContext.getResult(MONEY);</span><br></pre></td></tr></table></figure>

<ol>
<li>简单工厂模式需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。</li>
<li>策略模式与简单工厂结合的用法在客户端实例化的是CashContext的对象，调用的是CashContext的方法getResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。</li>
</ol>
<h4 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><p>低耦合</p>
<p>策略模式是一种定义一系列算法的方法，所有算法完成相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
</li>
<li><p>简化单元测试</p>
<p>每个算法都有自己的类，可以通过自己的接口单独测试。</p>
</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>策略类需要对客户端透明：客户端必须知道所有的策略类，并自行决定哪一个策略类，也就是客户端需要理解这些算法的区别以便选择适当的算法</li>
<li>策略类数量多：策略模式会造成系统产生很多具体策略类，任何细小的变化都会导致系统增加一个新的具体策略类</li>
<li>客户端无法使用多个策略类：客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩下的功能</li>
</ol>
<h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><h5 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h5><h6 id="比较器接口-java-util-Comparator"><a href="#比较器接口-java-util-Comparator" class="headerlink" title="比较器接口 java.util.Comparator"></a>比较器接口 <code>java.util.Comparator</code></h6><p>通过 <code>Collections.sort(List,Comparator)</code> 和 <code>Arrays.sort(Object[],Comparator)</code> 对集合和数组进行排序。</p>
<p><code>Comparator</code> 接口充当了<strong>抽象策略</strong>角色，<code>Collections</code> 和 <code>Arrays</code> 则是<strong>环境</strong>角色。</p>
<h5 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h5><h6 id="实例化策略接口-org-springframework-beans-factory-support-InstantiationStrategy"><a href="#实例化策略接口-org-springframework-beans-factory-support-InstantiationStrategy" class="headerlink" title="实例化策略接口 org.springframework.beans.factory.support.InstantiationStrategy"></a>实例化策略接口 <code>org.springframework.beans.factory.support.InstantiationStrategy</code></h6><p>Spring 在具体实例化Bean的过程中，先通过 <code>ConstructorResolver</code> 找到对应的实例化方法和参数，再通过实例化策略 <code>InstantiationStrategy</code> 进行实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationStrategy</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认构造方法/无参构造方法</span></span><br><span class="line">  <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定构造方法/有参构造方法</span></span><br><span class="line">  <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner, Constructor&lt;?&gt; ctor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Object[] args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定工厂方法</span></span><br><span class="line">  <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner, Object factoryBean,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Method factoryMethod, Object[] args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InstantiationStrategy</code> 扮演<strong>抽象策略</strong>角色，有两种具体策略类，分别为 <code>SimpleInstantiationStrategy</code> 和 <code>CglibSubclassingInstantiationStrategy</code></p>
<p><img data-src="http://image.laijianfeng.org/20181018_171946.png" alt="Spring 实例化策略类图"></p>
<p>在 <code>SimpleInstantiationStrategy</code> 中对这三个方法做了简单实现，如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有 <code>MethodOverrides</code>，如果无 <code>MethodOverrides</code> 也是直接用反射，如果有 <code>MethodOverrides</code> 就需要用 <code>cglib</code> 实例化对象，<code>SimpleInstantiationStrategy</code> 把通过 <code>cglib</code> 实例化的任务交给了它的子类 <code>CglibSubclassingInstantiationStrategy</code>。</p>
<h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><h6 id="应用世界：不同策略上下架应用"><a href="#应用世界：不同策略上下架应用" class="headerlink" title="应用世界：不同策略上下架应用"></a>应用世界：不同策略上下架应用</h6><p>应用世界中上下架应用有不同的策略：过期时间、点击量、用户量等策略。</p>
<p>过期时间策略在应用到达过期时间时自动下架。</p>
<p>点击量在应用的点击次数到达阀值后自动下架。</p>
<p>用户量在应用的新用户数达到阀值后自动下架。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><p>责任链模式包含如下角色：</p>
<ul>
<li>处理器抽象类</li>
<li>具体处理器</li>
<li>处理器链维护器(可选)：维护了各个处理器的前后关系。可以由客户端再发送请求前生成链，或者动态地生成链。</li>
<li>客户端</li>
</ul>
<h4 id="伪例"><a href="#伪例" class="headerlink" title="伪例"></a>伪例</h4><p>请假流程</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/10/31/166c90b174855416" alt=""></p>
<p>请假请求类：LeaveRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> days;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequest</span><span class="params">(<span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.days = days;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器抽象类：LeaveRequestHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequestHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequestHandler</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Boolean <span class="title">handle</span><span class="params">(LeaveRequest leaveRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器具体类：SupervisorHandler、ManagerHandler、GeneralManagerHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupervisorHandler</span> <span class="keyword">extends</span> <span class="title">LeaveRequestHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupervisorHandler</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(threshold);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">handle</span><span class="params">(LeaveRequest leaveRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaveRequest.days &lt;= threshold)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Random().nextBoolean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerHandler</span> <span class="keyword">extends</span> <span class="title">LeaveRequestHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ManagerHandler</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(threshold);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">handle</span><span class="params">(LeaveRequest leaveRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaveRequest.days &lt;= threshold)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Random().nextBoolean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManagerHandler</span> <span class="keyword">extends</span> <span class="title">LeaveRequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GeneralManagerHandler</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(threshold);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">handle</span><span class="params">(LeaveRequest leaveRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaveRequest.days &lt;= threshold)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Random().nextBoolean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：Worker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = <span class="number">3</span>;</span><br><span class="line">    Boolean response = requestLeave(days);</span><br><span class="line">    System.out.println(<span class="string">"申请"</span> + days + <span class="string">"天,"</span> + (response ? <span class="string">"申请成功！"</span> : <span class="string">"申请失败！"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">requestLeave</span><span class="params">(<span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">    LeaveRequest leaveRequest = <span class="keyword">new</span> LeaveRequest(days);</span><br><span class="line">    SupervisorHandler supervisorHandler = <span class="keyword">new</span> SupervisorHandler(<span class="number">3</span>);</span><br><span class="line">    ManagerHandler managerHandler = <span class="keyword">new</span> ManagerHandler(<span class="number">7</span>);</span><br><span class="line">    GeneralManagerHandler generalManagerHandler = <span class="keyword">new</span> GeneralManagerHandler(Integer.MAX_VALUE);</span><br><span class="line">    LeaveRequestHandlerChain chain = <span class="keyword">new</span> LeaveRequestHandlerChain();</span><br><span class="line">    chain.addHandler(supervisorHandler);</span><br><span class="line">    chain.addHandler(managerHandler);</span><br><span class="line">    chain.addHandler(generalManagerHandler);</span><br><span class="line">    <span class="keyword">return</span> chain.process(leaveRequest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a>典型应用</h4><h5 id="Tomcat-过滤器中的责任链模式"><a href="#Tomcat-过滤器中的责任链模式" class="headerlink" title="Tomcat 过滤器中的责任链模式"></a>Tomcat 过滤器中的责任链模式</h5><p><code>Servlet</code> 过滤器是可用于 <code>Servlet</code> 编程的 Java 类，可以实现以下目的：在客户端的请求访问后端资源之前，拦截这些请求；在服务器的响应发送回客户端之前，处理这些响应。</p>
<h5 id="Mybatis-中的-Plugin-机制"><a href="#Mybatis-中的-Plugin-机制" class="headerlink" title="Mybatis 中的 Plugin 机制"></a>Mybatis 中的 Plugin 机制</h5><p>Mybatis 中的 Plugin 机制使用了责任链模式，配置各种官方或者自定义的 Plugin，与 Filter 类似，可以在执行 Sql 语句的时候做一些操作。</p>
<h3 id="包装模式-装饰者模式"><a href="#包装模式-装饰者模式" class="headerlink" title="包装模式/装饰者模式"></a>包装模式/装饰者模式</h3><blockquote>
<p>别称：包装模式、装饰器模式、Wrapper、Decorator</p>
</blockquote>
<p>装饰器模式（Decorator Pattern）允许在<strong>不改变其结构</strong>的情况下向一个现有的对象添加新的功能。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ol>
<li><strong>抽象构件</strong> （Component）</li>
<li><strong>具体构件</strong> （Concrete Component）</li>
<li><strong>抽象装饰类</strong> （Decorator） </li>
<li><strong>具体装饰类</strong> （Concrete Decorators）</li>
</ol>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><blockquote>
<p><a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">装饰器模式| 菜鸟教程</a></p>
</blockquote>
<p>画图形：图形有长方形、圆形；可以画红色的也可以画绿色的。</p>
<h5 id="抽象构件"><a href="#抽象构件" class="headerlink" title="抽象构件"></a>抽象构件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体构件"><a href="#具体构件" class="headerlink" title="具体构件"></a>具体构件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"Shape: rectangle\t"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"Shape: circle\t"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象装饰类"><a href="#抽象装饰类" class="headerlink" title="抽象装饰类"></a>抽象装饰类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Shape shape;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.shape = shape;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体装饰类"><a href="#具体装饰类" class="headerlink" title="具体装饰类"></a>具体装饰类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(shape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shape.draw();</span><br><span class="line">    System.out.println(<span class="string">"Color: red"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GreenShapeDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(shape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shape.draw();</span><br><span class="line">    System.out.println(<span class="string">"Color: green"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Shape shape = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line">  shape.draw();</span><br><span class="line"></span><br><span class="line">  shape = <span class="keyword">new</span> GreenShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line">  shape.draw();</span><br><span class="line"></span><br><span class="line">  shape = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">  shape.draw();</span><br><span class="line"></span><br><span class="line">  shape = <span class="keyword">new</span> GreenShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">  shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shape: rectangle	Color: red</span><br><span class="line">Shape: rectangle	Color: green</span><br><span class="line">Shape: circle	Color: red</span><br><span class="line">Shape: circle	Color: green</span><br></pre></td></tr></table></figure>

<h4 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a>典型应用</h4><blockquote>
<p><a href="https://juejin.im/post/6844903681322647566" target="_blank" rel="noopener">设计模式| 装饰者模式及典型应用 - 掘金</a></p>
</blockquote>
<h5 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h5><p>抽象构件：<code>java.io.InputStream</code></p>
<p>具体构件：</p>
<ul>
<li><p><code>java.io.FileInputStream</code></p>
</li>
<li><p><code>java.io.ByteArrayInputStream</code></p>
</li>
<li><p><code>java.io.PipedInputStream</code></p>
</li>
</ul>
<p>抽象装饰类：<code>java.io.FilterInputStream</code></p>
<p>具体装饰类：</p>
<ul>
<li><p><code>java.io.BufferedInputStream</code></p>
</li>
<li><p><code>java.io.DataInputStream</code></p>
</li>
<li><p><code>java.io.PushbackInputStream</code></p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/9/18/165ecd4e160d8682" alt=""></p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>

<p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h3 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote>
<p><a href="https://blog.csdn.net/shusheng0007/article/details/80864854" target="_blank" rel="noopener">秒懂Java代理与动态代理模式</a></p>
</blockquote>
<p>用代理对象<strong>代替</strong>目标对象来实现某个目的（服务/主题/功能）。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ol>
<li>隐藏目标对象</li>
<li>增强目标对象</li>
</ol>
<h4 id="代理模式结构"><a href="#代理模式结构" class="headerlink" title="代理模式结构"></a>代理模式结构</h4><blockquote>
<p><a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理模式 | <strong>Refactoring.Guru</strong></a></p>
</blockquote>
<ol>
<li><p>服务接口</p>
<p>声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</p>
</li>
<li><p>服务类</p>
<p>提供了一些实用的业务逻辑。</p>
</li>
<li><p>代理类</p>
<p>代理类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</p>
</li>
<li><p>客户端</p>
<p>客户端能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理。</p>
</li>
</ol>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>劳动仲裁案例：代理律师代理讨薪员工索要工资。</p>
<h5 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h5><blockquote>
<p>代理主题：讨薪</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AskAbility</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">askForPay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务类"><a href="#服务类" class="headerlink" title="服务类"></a>服务类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSan</span> <span class="keyword">implements</span> <span class="title">AskAbility</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">askForPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"还钱！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lawyer</span> <span class="keyword">implements</span> <span class="title">AskAbility</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ZhangSan zhangSan;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Lawyer</span><span class="params">(ZhangSan zhangSan)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.zhangSan = zhangSan;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">askForPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    zhangSan.askForPay();</span><br><span class="line">    System.out.println(<span class="string">"如果不还将承担法律责任！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZhangSan zhangSan = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">    AskAbility ask = <span class="keyword">new</span> Lawyer(zhangSan);</span><br><span class="line">    ask.askForPay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>静态代理中代理类在编译期已经存在，一个服务类需要一个代理类与之对应，当服务类增多时，代理类随着增多，导致类数量太多。</p>
<p>动态代理就是为了减少类数量而产生。</p>
<p>动态代理有 JDK(基于接口、反射生成) 和 CGLIB(基于继承、字节码生成) 两种实现方式。</p>
<p>Spring AOP 就是基于动态代理实现的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">关于 Spring AOP (AspectJ) 你该知晓的一切</a></p>
<p><a href="https://how2j.cn/k/spring/spring-annotation-ioc-di/1067.html" target="_blank" rel="noopener">Spring系列教材 （三）- 注解方式 IOC/DI</a></p>
</blockquote>
<h5 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h5><p>两个重要的元素：</p>
<ol>
<li><p>InvocationHandler 接口</p>
<p><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</code></p>
<ul>
<li>proxy：动态代理对象</li>
<li>method：正在执行的方法</li>
<li>args：当前执行方法传入的实参</li>
</ul>
</li>
<li><p>Proxy 类</p>
<p><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AskingHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AskingHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object invoke = method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">"如果不还将承担法律责任！"</span>);</span><br><span class="line">    <span class="keyword">return</span> invoke;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> AskingHandler(employee);</span><br><span class="line">    AskAbility proxy = (AskAbility) Proxy.newProxyInstance(employee.getClass().getClassLoader(), employee.getClass().getInterfaces(), handler);</span><br><span class="line">    proxy.askForPay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h5><p>JDK 只能对实现了接口的类做动态代理，而不能对没有实现接口的类做动态代理，所以出现了 cgLib。</p>
<p>CGLib（Code Generation Library）是一个强大、高性能的 Code 生成类库，它可以在程序运行期间动态扩展类或接口，它的底层是使用 <strong>java字节码操作框架</strong> ASM 实现。</p>
<p>CGLIB 两个重要元素：</p>
<ol>
<li><p>MethodInterceptor 方法拦截器</p>
<p><code>Object intercept(Object var1, Method var2, Object[] var3, MethodProxy var4) throws Throwable;</code></p>
</li>
<li><p>Enhancer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">create</span><span class="params">(Class type, Callback callback)</span> </span>&#123;</span><br><span class="line">  Enhancer e = <span class="keyword">new</span> Enhancer();</span><br><span class="line">  e.setSuperclass(type);</span><br><span class="line">  e.setCallback(callback);</span><br><span class="line">  <span class="keyword">return</span> e.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="服务类-1"><a href="#服务类-1" class="headerlink" title="服务类"></a>服务类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">askForPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"还钱！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="方法拦截器"><a href="#方法拦截器" class="headerlink" title="方法拦截器"></a>方法拦截器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AskingMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">"askForPay"</span>))</span><br><span class="line">      System.out.println(<span class="string">"如果不还将承担法律责任！"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">    Employee proxy = (Employee) Enhancer.create(employee.getClass(), <span class="keyword">new</span> AskingMethodInterceptor());</span><br><span class="line"></span><br><span class="line">    proxy.askForPay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-何时使用JDK-CGLIB"><a href="#Spring-何时使用JDK-CGLIB" class="headerlink" title="Spring 何时使用JDK/CGLIB"></a>Spring 何时使用JDK/CGLIB</h5><ol>
<li><p>目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。</p>
</li>
<li><p>目标对象没有实现了接口，采用 CGLIB 库。</p>
</li>
</ol>
<h5 id="如何强制使用-CGLIB-实现-AOP"><a href="#如何强制使用-CGLIB-实现-AOP" class="headerlink" title="如何强制使用 CGLIB 实现 AOP"></a>如何强制使用 CGLIB 实现 AOP</h5><ol>
<li><p>在 Spring 配置文件中加入: </p>
<p><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></p>
</li>
<li><p>Spring Boot 中是在主配置文件中添加：</p>
<p><code>spring.aop.proxy-target-class=true</code></p>
<p>或者在启动类上添加：</p>
<p><code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code></p>
</li>
</ol>
<p>在 Spring Boot 2.x 已经默认使用 CGLIGB 生成代理了。</p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903982721138696" target="_blank" rel="noopener">惊人！Spring5 AOP 默认使用Cglib ？从现象到源码深度分析</a></p>
</blockquote>
<ol>
<li><p>Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。</p>
</li>
<li><p>SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。</p>
</li>
<li><p>在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项<code>spring.aop.proxy-target-class=false</code>来进行修改，<code>proxyTargetClass</code>配置已无效。</p>
</li>
</ol>
<p>强制使用 cglib 做动态代理有哪些好处？</p>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000010067944" target="_blank" rel="noopener">spring 强制使用cglib做动态代理有哪些好处？</a></p>
</blockquote>
<ol>
<li><p>如果不做特殊配置 spring 的 <code>@Transactional</code> 注解，放在类中非接口内的方法上时，是不起作用的。因为 spring 默认使用JDK的代理，被代理的类只能拦截接口中的方法，不能拦截非接口中的方法。</p>
</li>
<li><p>如果注入时需要直接使用子类，那么启动时会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure>

<p>因为 JDK 动态代理是基于接口的，代理生成的对象只能赋值给接口变量。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/10/29/16e14e77e77ccee0" alt=""></p>
</li>
</ol>
<h5 id="JDK-与-CGLIB-性能对比"><a href="#JDK-与-CGLIB-性能对比" class="headerlink" title="JDK 与 CGLIB 性能对比"></a>JDK 与 CGLIB 性能对比</h5><blockquote>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/82497594" target="_blank" rel="noopener">Spring AOP 中 JDK 和 CGLib 动态代理哪个更快？</a></p>
</blockquote>
<ol>
<li>JDK 在创建代理类的速度上要比 CGLIB 快大概8倍左右</li>
<li>JDK 1.6以前，CGLIB 代理类执行代理方法的速度要比 JDK 的大概高 10 倍。</li>
<li>JDK 1.6/1.7 时，JDK 动态代理的运行速度在调用次数比较少的情况下要比 CGLIB 快，调用次数多的情况下还是 CGLIB 更快一些。</li>
<li>JDK 1.8 时，JDK 动态代理的运行速度已经比 CGLIB 快了。</li>
</ol>
<h5 id="JDK-动态代理与-CGLIB-动态代理的区别"><a href="#JDK-动态代理与-CGLIB-动态代理的区别" class="headerlink" title="JDK 动态代理与 CGLIB 动态代理的区别"></a>JDK 动态代理与 CGLIB 动态代理的区别</h5><ol>
<li>JDK 动态代理基于接口，CGLIB 动态代理基于继承</li>
<li>JDK 动态代理通过反射生成代理，CGLIB 通过操作字节码生成动态代理</li>
<li>JDK 生成动态代理比CGLIB快</li>
<li>JDK 动态代理执行代理方法时，需要通过反射机制进行回调，CGLIB 对方法的调用和直接调用普通类的方式一致，所以<code>CGLib</code>执行代理方法的效率要高于<code>JDK</code>的动态代理</li>
</ol>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote>
<p><a href="http://libo9527.github.io/2020/11/04/Design-Pattern-Iterator/" target="_blank" rel="noopener">Design-Pattern-Iterator | libo9527</a></p>
</blockquote>
<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<h4 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h4><p>将集合的遍历行为抽取为单独的迭代器对象。</p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><ol>
<li>抽象迭代器（Iterator）</li>
<li>具体迭代器（Concrete Iterators）</li>
<li>抽象集合（Collection）</li>
<li>具体集合（Concrete Collections）</li>
</ol>
<h4 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h4><p>学生报数</p>
<h5 id="抽象迭代器"><a href="#抽象迭代器" class="headerlink" title="抽象迭代器"></a>抽象迭代器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentIterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hashNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Student <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getPosition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体迭代器"><a href="#具体迭代器" class="headerlink" title="具体迭代器"></a>具体迭代器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStudentIterator</span> <span class="keyword">implements</span> <span class="title">StudentIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Student[] students;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStudentIterator</span><span class="params">(Student[] students)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.students = students;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hashNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; students.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> students[position++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象集合"><a href="#抽象集合" class="headerlink" title="抽象集合"></a>抽象集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> StudentIterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStudentCollection</span> <span class="keyword">extends</span> <span class="title">StudentCollection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Student[] students;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStudentCollection</span><span class="params">(Student[] students)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.students = students;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">StudentIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteStudentIterator(students);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端使用-1"><a href="#客户端使用-1" class="headerlink" title="客户端使用"></a>客户端使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  StudentCollection studentCollection = <span class="keyword">new</span> ConcreteStudentCollection(<span class="keyword">new</span> Student[]&#123;<span class="keyword">new</span> Student(<span class="string">"张三"</span>), <span class="keyword">new</span> Student(<span class="string">"李四"</span>)&#125;);</span><br><span class="line">  StudentIterator iterator = studentCollection.createIterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hashNext()) &#123;</span><br><span class="line">    Student student = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">"我是"</span> + iterator.getPosition() + <span class="string">"号："</span> + student.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是1号：张三</span><br><span class="line">我是2号：李四</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h4 id="典型应用-3"><a href="#典型应用-3" class="headerlink" title="典型应用"></a>典型应用</h4><h5 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h5><p><img data-src="../post_image/image_2020_11_04T11_06_19_787Z.png" alt=""></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>网络分层有三种：</p>
<ol>
<li>OSI 7层协议</li>
<li>TCP/IP 4层协议</li>
<li>中和的5层协议</li>
</ol>
<p><img data-src="https://camo.githubusercontent.com/a24a29536633ebdf6e9326554d357c2b8acfae62026222573eb6cefd653bc5a3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542412539342545352542312538322545342542442539332545372542332542422545372542422539332545362539452538342e706e67" alt=""></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img data-src="https://img-blog.csdnimg.cn/20190531123343480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM3OTky,size_16,color_FFFFFF,t_70" alt=""></p>
<h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><p><strong>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img data-src="https://img-blog.csdnimg.cn/20190531123409366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM3OTky,size_16,color_FFFFFF,t_70" alt=""></p>
<h5 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h5><p>四次挥手是为了连接双方能够断开彼此之间的数据通道。少于四次无法实现这个目的。</p>
<p>假如客户端率先发起断开连接的请求：</p>
<ol>
<li><p>第一次挥手：客户端发送断开连接的请求给服务器</p>
<p>为了实现安全性，需要等待服务器的确认报文。</p>
</li>
<li><p>第二次挥手：服务器发送确认报文给客户端</p>
<p>由于 TCP 是全双工模式，双通道相互独立，故服务器还可以继续发送数据报文给客户端，此时客户端往服务器端的数据通道关闭，TCP 连接处于半关闭状态。</p>
</li>
<li><p>第三次挥手：服务器发送断开连接的请求给客户端</p>
<p>为了安全性，需要等待客户端的确认报文。</p>
</li>
<li><p>第四次挥手：客户端发送确认报文给服务器</p>
<p>当服务器接收到该报文后即可关闭连接，但客户端在发送完该报文后并不能确保服务器是否已收到，需要等待 2MSL 时间后再关闭。</p>
</li>
</ol>
<h5 id="2MSL等待状态"><a href="#2MSL等待状态" class="headerlink" title="2MSL等待状态"></a>2MSL等待状态</h5><p>报文段最大生存时间MSL（Maximum Segment Lifetime），在第四次挥手后主动端之所以还需要等待 2MSL 时间，是因为它无法保证报文是否被接收到，但如果假设报文丢失了，那么被动端会在 2MSL 时间内再发送一次断开连接的请求，此时主动端就可以判定确认报文丢失了，然后重新发送一次确认报文，如果 2MSL 时间内没有收到被动端再一次的断开连接请求，就认为被动端已经收到确认报文了，就可以关闭连接了。</p>
<h4 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h4><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 最大只支持 512 字节的数据。</p>
<h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><ol>
<li>TCP 面向连接，UDP 无连接</li>
<li>TCP 根据流量控制和拥塞控制，以及重传控制和数据校验保证提供可靠的数据传输服务。而 UDP 不保证数据的可靠性。</li>
<li>TCP 的报文段头部占20各字节，比 UDP 的报文段头部多12个字节。消耗的资源更多。由于建立连接有握手的机制，TCP 的使用效率会比 UDP 要低一些。</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul>
<li>200 OK：正常返回信息</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found：请求资源不存在，输入了错误的URL</li>
<li>500 Internal Server Error：服务器发生不可预期错误</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h4 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h4><ul>
<li><strong>Accept: text/html</strong> 浏览器可以接受服务器回发的类型为 text/html。</li>
<li><strong>Accept: */*</strong>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。</li>
<li><strong>Connection: keep-alive</strong> 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li><strong>Connection: close</strong> 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li>
<li><strong>User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36</strong> 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。</li>
</ul>
<h4 id="常见响应头"><a href="#常见响应头" class="headerlink" title="常见响应头"></a>常见响应头</h4><ul>
<li><strong>Content-Type：text/html;charset=UTF-8</strong> 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。</li>
<li><strong>Connection：keep-alive</strong> 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。</li>
<li><strong>Refresh: 5; url=<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a></strong> 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><p>服务器发送的响应报文包含 <code>Set-Cookie</code> 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<h5 id="浏览器禁用-Cookie"><a href="#浏览器禁用-Cookie" class="headerlink" title="浏览器禁用 Cookie"></a>浏览器禁用 Cookie</h5><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<h4 id="浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h4><p><img data-src="https://camo.githubusercontent.com/c757ddcd23ab760aabb28c35adeadb49fe872f47f0dfb3ed5e4144ca9aa704cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067" alt=""></p>
<h4 id="HTTP-1-0-与-HTTP-1-1、HTTP-2-0"><a href="#HTTP-1-0-与-HTTP-1-1、HTTP-2-0" class="headerlink" title="HTTP 1.0 与 HTTP 1.1、HTTP 2.0"></a>HTTP 1.0 与 HTTP 1.1、HTTP 2.0</h4><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>
<p>HTTP 2.0：</p>
<ol>
<li><p>二进制分帧</p>
<p>HTTP1.x基于文本，HTTP2.0采用二进制格式。</p>
</li>
<li><p>首部压缩</p>
</li>
<li><p>多路复用</p>
</li>
<li><p>服务端推送</p>
<p>在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应。</p>
</li>
</ol>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote>
<p>SSL: <strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer</p>
<p>TLS: <strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity</p>
</blockquote>
<p>HTTPS 是基于 HTTP 的扩展，在 HTTPS 中，原有的 HTTP 协议会得到 TLS（安全传输层协议）或其前身 SSL（安全套接层）的加密。</p>
<p>HTTPS = HTTP + TLS/SSL</p>
<p><img data-src="https://segmentfault.com/img/bVbClUl" alt=""></p>
<p>HTTPS 整个通信过程可以分为两大阶段：证书验证和数据传输，数据传输阶段又可以分为非对称加密和对称加密两个阶段。</p>
<p>具体流程如下：</p>
<ol>
<li><p>浏览器客户端发送 HTTPS 请求。</p>
</li>
<li><p>采用 HTTPS 协议的服务器必须向 CA 机构有偿申请合法的 CA(Certification Authority)证书。CA机构颁发证书时会生成一对公钥和私钥，服务器将私钥自己保存，公钥包含在证书中，可以公开，同时证书本身会附带一个电子签名，这个签名是用来验证证书的完整性和真实性，防止证书被篡改。</p>
</li>
<li><p>服务器将证书传送给浏览器客户端</p>
</li>
<li><p>浏览器客户端解析证书对其进行验证。如果证书不是可信机构颁发的、证书中的域名与实际域名不一致、或者证书已过期，就会向用户显示一个警告，询问是否还要继续通信。</p>
<p>如果证书没有问题，就从证书中取出共钥，然后生成一个随机码，用共钥加密后作为之后对称加密的密钥。</p>
</li>
<li><p>浏览器客户端将对称加密的密钥发送给服务器</p>
</li>
<li><p>服务器收到密钥后会使用自己的私钥解密得到对称加密的密钥。</p>
<p>至此，客户端和服务器就建立好了安全连接，解决了对称加密的密钥泄漏问题。</p>
</li>
<li><p>服务器使用密钥对数据进行对称加密并发送给客户端，客户端使用相同的密钥解密数据。</p>
</li>
<li><p>双方使用对称加密进行数据传输。</p>
</li>
</ol>
<h4 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h4><p><img data-src="https://segmentfault.com/img/bVbClUj" alt=""></p>
<ol>
<li><p>端口</p>
<p>HTTP 默认使用端口 80，而 HTTPS 默认使用端口443。</p>
</li>
<li><p>资源消耗</p>
<p>Https 由于加解密处理会消耗更多的CPU和内存资源，所以 HTTP 页面响应速度比 HTTPS 快。</p>
</li>
<li><p>安全性</p>
<p>HTTP 安全性没有 HTTPS 高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>默认使用的B+树的索引模型</p>
<h5 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h5><p>MyISAM是MySQL 5.5版之前的默认数据库引擎。5.5版本之后，默认的存储引擎为InnoDB。</p>
<p><strong>两者的对比：</strong></p>
<ol>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持，外键等高级数据库功能。 具有事务、回滚和崩溃修复能力的事务安全型表。</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用乐观锁和悲观锁来实现;各数据库中MVCC实现并不统一。</li>
</ol>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong>和<strong>哈希索引</strong>。</p>
<h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><h6 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h6><p>从非主键索引树回到主键索引树的查询的过程叫做回表。</p>
<p>也就是说通过非主键索引的查询需要多扫描一棵索引树，因此需要尽量使用主键索引查询。</p>
<h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p>
<p>例如：存在联合索引（col1，col2），之后根据 col1 查询 col2，此时由于索引结点上包含所需的值，所以不需要回表。</p>
<h5 id="主键索引与非主键索引的区别"><a href="#主键索引与非主键索引的区别" class="headerlink" title="主键索引与非主键索引的区别"></a>主键索引与非主键索引的区别</h5><p>非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>。非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p>
<p>非主键索引列的查询，则先搜索非主键索引树，得到主键ID值，再到主键索引树搜索一次，这个过程也被称为回表。</p>
<h5 id="非主键索引一定会查询多次吗？"><a href="#非主键索引一定会查询多次吗？" class="headerlink" title="非主键索引一定会查询多次吗？"></a>非主键索引一定会查询多次吗？</h5><p>覆盖索引也可以只查询一次，覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。</p>
<h5 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h5><ol>
<li>聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。（比如主键索引）</li>
<li>非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。非聚集索引检索效率比聚集索引低，但对数据更新影响较小。</li>
</ol>
<h5 id="B-树索引和Hash索引比较"><a href="#B-树索引和Hash索引比较" class="headerlink" title="B+树索引和Hash索引比较"></a>B+树索引和Hash索引比较</h5><blockquote>
<p>InnoDB 为什么使用B+树而不是hash索引</p>
</blockquote>
<ol>
<li>哈希索引适合等值查询，不适合范围查询</li>
<li>哈希索引没办法利用索引完成排序</li>
<li>哈希索引不支持多列联合索引的最左匹配规则</li>
<li>如果有大量重复键值的情况下，因为哈希碰撞问题，会导致哈希索引的效率大大降低。</li>
</ol>
<h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p>联合索引（A，B，C），但是查询的时候是反过来查的（C=xxx and B=xxx and A=xxx），这种能走索引吗？</p>
<p>where里面的条件顺序在查询之前会被mysql自动优化，变为A，B，C，然后使用联合索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)    select * from myTest  where a&#x3D;3 and b&#x3D;5 and c&#x3D;4;   ----  abc顺序</span><br><span class="line">abc三个索引都在where条件里面用到了，而且都发挥了作用</span><br><span class="line"></span><br><span class="line">(2)    select * from myTest  where  c&#x3D;4 and b&#x3D;6 and a&#x3D;3;</span><br><span class="line">where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</span><br><span class="line"></span><br><span class="line">(3)    select * from myTest  where a&#x3D;3 and c&#x3D;7;</span><br><span class="line">a用到索引，b没有用，所以c是没有用到索引效果的</span><br><span class="line"></span><br><span class="line">(4)    select * from myTest  where a&#x3D;3 and b&gt;7 and c&#x3D;3;     ---- b范围值，断点，阻塞了c的索引</span><br><span class="line">a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</span><br><span class="line"></span><br><span class="line">(5)    select * from myTest  where b&#x3D;3 and c&#x3D;4;   --- 联合索引必须按照顺序使用，并且需要全部使用</span><br><span class="line">因为a索引没有使用，所以这里 bc都没有用上索引效果</span><br><span class="line"></span><br><span class="line">(6)    select * from myTest  where a&gt;4 and b&#x3D;7 and c&#x3D;9;</span><br><span class="line">a用到了  b没有使用，c没有使用</span><br><span class="line"></span><br><span class="line">(7)    select * from myTest  where a&#x3D;3 order by b;</span><br><span class="line">a用到了索引，b在结果排序中也用到了索引的效果，a下面任意一段的b是排好序的</span><br><span class="line"></span><br><span class="line">(8)    select * from myTest  where a&#x3D;3 order by c;</span><br><span class="line">a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort</span><br><span class="line"></span><br><span class="line">(9)    select * from mytable where b&#x3D;3 order by a;</span><br><span class="line">b没有用到索引，排序中a也没有发挥索引效果</span><br></pre></td></tr></table></figure>

<h5 id="MySql-索引自动优化"><a href="#MySql-索引自动优化" class="headerlink" title="MySql 索引自动优化"></a>MySql 索引自动优化</h5><ol>
<li><p>当预估返回的数据量超过一定比例(当预估的查询量达到总量的30% )的时候，mysql 就会进行全表扫描。</p>
</li>
<li><p>mysql 会根据索引大概估算选择最快的索引。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- sql1: </span><br><span class="line">select * from table where col_a &#x3D; 123 and col_b in (&#39;foo&#39;, &#39;bar&#39;) order by id desc;</span><br><span class="line"></span><br><span class="line">-- sql2:                                             select * from table where col_a &#x3D; 456 and col_b in (&#39;foo&#39;, &#39;bar&#39;) order by id desc;</span><br></pre></td></tr></table></figure>

<p>结果 sql1 选择利用了 col_a 的索引，速度很快，sql2利用了主键ID的索引，扫描了全表(40w行)。<br>仔细分析，发现数据库中，col_a=456 的记录数有近1万条，而 col_a=123 的记录数只有几条。<br>当 col_a=456 时，Mysql 认为主键索引会比普通index更快，所以mysql最后选择了数据量更大的id索引。<br>那么，如何解决这个问题呢？<br>很简单，只要在order语句里写多个键即可，比如：<code>order by col_a, id desc</code></p>
</li>
</ol>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<h5 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h5><ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）：</strong> 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h5 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h5><ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除，比如多次读取一条记录发现记录增多或减少了。</p>
<h5 id="事务隔离级别有哪些-MySQL的默认隔离级别是"><a href="#事务隔离级别有哪些-MySQL的默认隔离级别是" class="headerlink" title="事务隔离级别有哪些?MySQL的默认隔离级别是?"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h5><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁（间隙锁）算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<h5 id="Next-Key-Lock（间隙锁）"><a href="#Next-Key-Lock（间隙锁）" class="headerlink" title="Next-Key Lock（间隙锁）"></a>Next-Key Lock（间隙锁）</h5><p>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<p><code>Select * from  emp where empid &gt; 100 for update;</code></p>
<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p>
<h4 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h4><p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁</strong></p>
<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
<p>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</p>
<p>如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。</p>
<h5 id="行锁-VS-表锁"><a href="#行锁-VS-表锁" class="headerlink" title="行锁 VS 表锁"></a>行锁 VS 表锁</h5><ul>
<li>表锁： 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度低</li>
<li>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li>
</ul>
<h5 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h5><p>InnoDB实现了以下两种类型的行锁。</p>
<ul>
<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>
</li>
<li><p>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>
</li>
<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
</li>
<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
</li>
</ul>
<p>InnoDB行锁模式兼容性列表</p>
<table>
<thead>
<tr>
<th>请求锁模式<br />是否兼容当前锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><ol>
<li>left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。</li>
<li>right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。</li>
<li>inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。</li>
<li>full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。<strong>MySQL不支持</strong></li>
</ol>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="查询数据库的运行情况"><a href="#查询数据库的运行情况" class="headerlink" title="查询数据库的运行情况"></a>查询数据库的运行情况</h5><h6 id="显示数据库运行状态"><a href="#显示数据库运行状态" class="headerlink" title="显示数据库运行状态"></a>显示数据库运行状态</h6><p><code>SHOW STATUS</code></p>
<h6 id="显示数据库运行总时间"><a href="#显示数据库运行总时间" class="headerlink" title="显示数据库运行总时间"></a>显示数据库运行总时间</h6><p><code>SHOW STATUS LIKE &#39;uptime&#39;</code></p>
<h6 id="显示连接的次数"><a href="#显示连接的次数" class="headerlink" title="显示连接的次数"></a>显示连接的次数</h6><p><code>SHOW STATUS LIKE &#39;connections&#39;</code></p>
<h6 id="显示执行CRUD的次数"><a href="#显示执行CRUD的次数" class="headerlink" title="显示执行CRUD的次数"></a>显示执行CRUD的次数</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'com_select'</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'com_insert'</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'com_update'</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'com_delete'</span></span><br></pre></td></tr></table></figure>

<h5 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h5><h6 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h6><p>Linux下修改my.cnf，Windows下修改my.ini。修改后需要重启mysql才会生效。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启慢查询</span></span><br><span class="line"><span class="meta">slow-query-log</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#慢查询的文件路径</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">"D:/Program Files/MySQL/Log/mysql-slow.log"</span></span><br><span class="line"><span class="comment">#慢查询时间。默认为10秒</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#记录没有使用索引的查询</span></span><br><span class="line"><span class="meta">log-queries-not-using-indexes</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<h6 id="定位慢查询SQL"><a href="#定位慢查询SQL" class="headerlink" title="定位慢查询SQL"></a>定位慢查询SQL</h6><p>如果慢查询日志中记录内容较多，则可以使用Mysql自带的慢查询日志分析工具mysqldumpslow来对慢查询日志进行分类汇总。该工具位于/mysql/bin目录下。mysqldumpslow会自动将文本完全一致但变量不同的SQL语句视为同一个语句进行统计，变量值用N来代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 &#x2F;data&#x2F;dbdata&#x2F;frem-slow.log</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img2018.cnblogs.com/blog/424830/201907/424830-20190707081744320-989448386.png" alt="img"></p>
<h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain [要分析的sql]</span><br></pre></td></tr></table></figure>

<p>分析结果中有如下几列：</p>
<ol>
<li>id：查询序号</li>
<li>select_type</li>
<li>table</li>
<li>type</li>
<li>possible_keys</li>
<li>key</li>
<li>key_len</li>
<li>ref</li>
<li>rows</li>
<li>Extra</li>
</ol>
<h6 id="id"><a href="#id" class="headerlink" title="id"></a>id</h6><p>表示 select 查询序列号。<strong>id值越大，越优先执行。\</strong>如果id相同，执行顺序由上至下*<strong>*    **<img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200502220732511-625086303.png" alt="img"></strong></p>
<h6 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h6><p>表示查询类型。主要用于区分普通查询、子查询、联合查询等几种查询情况。</p>
<p>取值：</p>
<ol>
<li>simple</li>
<li>primary</li>
<li>subquery</li>
<li>derived</li>
<li>union</li>
<li>union result</li>
</ol>
<p>①simple：表示简单查询，只有一个select操作，即不使用连接和union。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只有一个select操作，所以都是简单查询</span><br><span class="line"></span><br><span class="line">select id from emp;</span><br><span class="line"></span><br><span class="line">select id from emp join dept on emp.dept_id&#x3D;dept.id;</span><br></pre></td></tr></table></figure>

<p>②primary：表示主查询。子查询语句中的最外层select，或union操作的第一个select。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#子查询形式：第一个select操作为primary</span><br><span class="line">select * from app_school where id &#x3D; (select id from app_school where id&#x3D;100);</span><br><span class="line"></span><br><span class="line">#union形式：第一个select操作为primary</span><br><span class="line">select * from app_school where id&#x3D;100</span><br><span class="line">union</span><br><span class="line">select * from app_school where id&#x3D;101;</span><br></pre></td></tr></table></figure>

<p>③subquery：表示子查询。子查询语句中的内层select。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第二个select操作为subquery</span><br><span class="line">select * from app_school where id &#x3D; (select id from app_school where id&#x3D;100);</span><br></pre></td></tr></table></figure>

<p>④derived：表示FROM后跟着的select查询，会被标记为derived(导出表/衍生表)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第二个select操作为derived</span><br><span class="line">select * from (select id from app_school) t;</span><br></pre></td></tr></table></figure>

<p>⑤union：表示UNION操作后面的select查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第二个select操作为union</span><br><span class="line">select * from app_school where id&#x3D;100</span><br><span class="line">union</span><br><span class="line">select * from app_school where id&#x3D;101;</span><br></pre></td></tr></table></figure>

<p>⑥union result：表示获取UNION最后结果的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一个select操作为primary</span><br><span class="line">#第二个select操作为union</span><br><span class="line">#获取最终结果的操作为union result</span><br><span class="line">select * from app_school where id&#x3D;100</span><br><span class="line">union</span><br><span class="line">select * from app_school where id&#x3D;101;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img2018.cnblogs.com/blog/424830/201907/424830-20190712003515128-554921784.png" alt="img"></p>
<h6 id="table"><a href="#table" class="headerlink" title="table"></a>table</h6><p>表示查询用到的表。</p>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><p>表示找到匹配行用到的访问类型。</p>
<p>最为常见的类型有:</p>
<ol>
<li>NULL</li>
<li>system</li>
<li>const</li>
<li>eq_ref</li>
<li>ref</li>
<li>range</li>
<li>index</li>
<li>All</li>
</ol>
<p>按照性能从高到低顺序如下：NULL–&gt;system–&gt;const–&gt;eq-ref–&gt;ref–&gt;range–&gt;index–&gt;All 。一般来说，要让查询至少达到range级别，最好能达到ref级别。</p>
<p><strong>①</strong>NULL：不用访问表或索引，就可直接得出结果。<br><img data-src="https://img2018.cnblogs.com/blog/424830/201907/424830-20190706164443539-700840263.png" alt="img"></p>
<p><strong>②system</strong>：该表是最多仅有一行的系统表(这是const类型的一个特例)。系统表中的数据通常已经加载到了内存中，所以不需要磁盘IO。<br>例子1：查询系统表<br><img data-src="https://img2018.cnblogs.com/blog/424830/201907/424830-20190706164242606-1185621519.png" alt="img"><br>例子2：内层嵌套(const)返回了一个临时表，外层嵌套从临时表中查询，其扫描类型也是system，也不需要磁盘IO。</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200502231552124-1649320315.png" alt="img"></p>
<p><strong>③const</strong>：最多只有一个匹配行，所以该行中的其它列的值可以当作常量来处理。例如，根据主键primary key或唯一索引unique index进行查询。<strong>简单地说const就是直接按主键或唯一键取值。</strong>例如在②中介绍system时的举例中user表的访问类型就是const，其通过主键来取值。</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200502231426915-1946155193.png" alt="img"></p>
<p><strong>④eq_ref</strong>：使用唯一索引，对于每个索引键值，表中只有一条记录匹配。简单说，就是多表连接中使用primary key或unique index作为关联条件。</p>
<p><strong>注意const和eq_ref的区别：简单地说是<code>const</code>是直接按主键或唯一键读取，<code>eq_ref</code>用于联表查询的情况，按联表的主键或唯一键联合查询。</strong></p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503001453929-1612327840.png" alt="img">)<img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503003027609-823944660.png" alt="img"></p>
<p><strong>⑤ref</strong>：使用非唯一索引，或唯一索引的前缀扫描，返回匹配某个单独值的所有行(可能匹配多个行)。</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503000159947-653574490.png" alt="img">)<img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503000923679-747371819.png" alt="img"></p>
<p>ref还经常出现在join操作中</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503001210640-1962805550.png" alt="img"></p>
<p><strong>⑥</strong>ref_or_null：与ref类似，区别在于条件中包含对NULL的查询。</p>
<p><strong>⑦</strong>index_merge：索引合并优化。</p>
<p><strong>⑧</strong>unique_subquery：in的后面是一个查询主键字段的子查询。</p>
<p><strong>⑨</strong>index_subquery：与unique subquery类似，区别在于in的后面是查询非唯一索引字段的子查询。</p>
<p><strong>⑩range</strong>：只检索指定范围的行，使用一个索引来选择行。常见于&lt;，&lt;=，&gt;，&gt;=，between或者IN操作符。<br>key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503003455696-1174761682.png" alt="img"></p>
<p><strong>11.index</strong>：索引全扫描。遍历整个索引来查询匹配的行。</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503003823129-1724228939.png" alt="img"></p>
<p><strong>12.ALL</strong>：全表扫描，性能最差。</p>
<p><img data-src="https://img2020.cnblogs.com/blog/424830/202005/424830-20200503003936777-1259627189.png" alt="img"></p>
<h6 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h6><p>possible_keys表示查询时可能使用到的索引，而key表示实际使用的索引</p>
<h6 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h6><p>表示使用到的索引字段的长度</p>
<h6 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h6><p>表示该表的索引字段关联了哪张表的哪个字段</p>
<h6 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h6><p>表示扫描行的数量</p>
<h6 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h6><p>表示执行情况的说明和描述。包含不适合在其它列中显示但对执行计划非常重要的额外信息。记录几个重要的：</p>
<ul>
<li><p>Using index ：使用覆盖索引的时候就会出现</p>
</li>
<li><p>Using where：在查找使用索引的情况下，需要回表去查询所需的数据。表示Mysql将对storage engine提取的结果进行过滤，过滤条件字段无索引；</p>
</li>
<li><p>Using index condition：查找使用了索引，但是需要回表查询数据。会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</p>
</li>
<li><p>Using index &amp; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
</li>
<li><p>Using filesort：使用了文件排序。当查询语句包含ORDER BY时，如果无法使用索引来完成排序，则需要进行额外的排序操作。</p>
</li>
<li><p>Using temporary：使用临时表来保存中间结果</p>
</li>
</ul>
<h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><p>oracle 默认的索引是 <strong>B+树</strong>索引</p>
<h5 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h5><h6 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h6><p><img data-src="http://hongyitong.github.io/img/B%E6%A0%91%E7%B4%A2%E5%BC%95.jpg" alt=""></p>
<h6 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h6><blockquote>
<p><a href="https://blog.csdn.net/qq_24236769/article/details/75801687" target="_blank" rel="noopener">位图索引:原理（BitMap index）——浅显易懂</a></p>
</blockquote>
<p><img data-src="http://hongyitong.github.io/img/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95.jpg" alt=""></p>
<p>位图索引适合只有几个<strong>固定值</strong>的列，如性别、婚姻状况、行政区等。</p>
<p>位图可以通过 AND/OR 操作，快速得到查询结果。</p>
<p>此外，位图索引适合<strong>静态</strong>数据，而不适合索引频繁更新的列。</p>
<p>因为位图索引列的修改会将所有该值的行进行加锁。</p>
<h4 id="锁-2"><a href="#锁-2" class="headerlink" title="锁"></a>锁</h4><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5><p>联合索引的任何前缀索引都会使用到索引查询，(col1, col2, col3) 这个联合索引的所有前缀就是(col1), (col1, col2), (col1, col2, col3) 包含这些列的查询都会启用索引查询，除此之外的查询即时包含了联合索引中的多列也不会启用索引查询。即 (col2), (col3), (col2, col3) 都不会启动(col1, col2, col3) 这个联合索引查询。</p>
<h5 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h5><p><strong>原因：</strong></p>
<ul>
<li>消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li>无法使用覆盖索引</li>
<li>可减少表结构变更带来的影响</li>
</ul>
<h5 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h5><h5 id="禁止对索引列使用函数"><a href="#禁止对索引列使用函数" class="headerlink" title="禁止对索引列使用函数"></a>禁止对索引列使用函数</h5><p>对索引列使用函数会导致索引失效。</p>
<h5 id="将不等于改成-or"><a href="#将不等于改成-or" class="headerlink" title="将不等于改成 or"></a>将不等于改成 or</h5><p>将<code>&lt;&gt;a</code> <code>!=a</code> 改成<code>&lt;a or &gt;a</code>，因为不等于用不到索引。</p>
<h5 id="禁止使用左模糊和全模糊条件查询"><a href="#禁止使用左模糊和全模糊条件查询" class="headerlink" title="禁止使用左模糊和全模糊条件查询"></a>禁止使用左模糊和全模糊条件查询</h5><p>左模糊 <code>%key</code> 和全模糊 <code>%key%</code> 无法使用索引，只有右模糊 <code>key%</code> 才能使用到索引。</p>
<h5 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h5><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因：</strong></p>
<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>
<h5 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h5><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>
<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>
<h5 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h5><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h5 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h5><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>
<h5 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h5><ul>
<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL 不会再对结果集进行去重操作</li>
</ul>
<h4 id="执行计划-1"><a href="#执行计划-1" class="headerlink" title="执行计划"></a>执行计划</h4><p>Mysql 使用 Explain + select…</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><strong>分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。</strong> 常见的分库分表工具有：<code>sharding-jdbc</code>（当当）、<code>TSharding</code>（蘑菇街）、<code>MyCAT</code>（基于 Cobar）、<code>Cobar</code>（阿里巴巴）…。</p>
<p><strong>推荐使用 <code>sharding-jdbc</code></strong> 。 因为，<code>sharding-jdbc</code> 是一款轻量级 <code>Java</code> 框架，以 <code>jar</code> 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。</p>
<ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h4 id="分库分表之后-id-主键如何处理？"><a href="#分库分表之后-id-主键如何处理？" class="headerlink" title="分库分表之后,id 主键如何处理？"></a>分库分表之后,id 主键如何处理？</h4><ul>
<li><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li><strong>利用 redis 生成 id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>
<li><strong>Twitter的snowflake算法</strong></li>
<li><strong>美团的<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf</a>分布式ID生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。</li>
</ul>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>面向集合(<code>Collection</code>)和文档(<code>document</code>)的存储，以JSON格式的文档保存数据。</p>
<h4 id="与关系型数据库术语类比"><a href="#与关系型数据库术语类比" class="headerlink" title="与关系型数据库术语类比"></a>与关系型数据库术语类比</h4><table>
<thead>
<tr>
<th align="left">mongodb</th>
<th>关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Database</td>
<td>Database</td>
</tr>
<tr>
<td align="left">Collection</td>
<td>Table</td>
</tr>
<tr>
<td align="left">Document</td>
<td>Record/Row</td>
</tr>
<tr>
<td align="left">Filed</td>
<td>Column</td>
</tr>
<tr>
<td align="left">Embedded Documents</td>
<td>Table join</td>
</tr>
</tbody></table>
<h4 id="MongoDB的优势有哪些"><a href="#MongoDB的优势有哪些" class="headerlink" title="MongoDB的优势有哪些"></a>MongoDB的优势有哪些</h4><ul>
<li>面向文档的存储：以 BSON 格式的文档保存数据。</li>
<li>任何属性都可以建立索引。</li>
<li>复制以及高可扩展性。</li>
<li>自动分片。</li>
<li>丰富的查询功能。</li>
<li>快速的即时更新。</li>
<li>来自 MongoDB 的专业支持。</li>
</ul>
<h4 id="BSON-VS-JSON"><a href="#BSON-VS-JSON" class="headerlink" title="BSON VS JSON"></a>BSON VS JSON</h4><ol>
<li><p>BSON 有更快的遍历速度</p>
<p>json需要扫字符串，而bson可以直接定位</p>
</li>
<li><p>json是像字符串一样存储的，bson是按结构存储的</p>
</li>
</ol>
<h4 id="如何执行事务-加锁"><a href="#如何执行事务-加锁" class="headerlink" title="如何执行事务/加锁?"></a>如何执行事务/加锁?</h4><p><code>mongodb</code>没有使用传统的锁或者复杂的带回滚的事务,因为它设计的宗旨是轻量,快速以及可预计的高性能</p>
<h4 id="在哪些场景使用MongoDB"><a href="#在哪些场景使用MongoDB" class="headerlink" title="在哪些场景使用MongoDB?"></a>在哪些场景使用<code>MongoDB</code>?</h4><p><strong>规则：</strong> 如果业务中存在大量复杂的事务逻辑操作，则不要用<code>MongoDB</code>数据库；在处理非结构化 / 半结构化的大数据使用<code>MongoDB</code>，操作的数据类型为动态时也使用<code>MongoDB</code>，比如：</p>
<ul>
<li>内容管理系统，切面数据、日志记录</li>
<li>移动端<code>Apps</code>：<code>O2O</code>送快递骑手、快递商家的信息（包含位置信息）</li>
<li>数据管理，监控数据</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>查看端口对应的进程ID</p>
<p><code>lsof -i:80</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iMacDev110:~ libo$ lsof -i:80</span><br><span class="line">COMMAND     PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">Google      596 libo   66u  IPv4 0x71a3fffb3c30abf9      0t0  TCP 192.168.0.158:58179-&gt;sfo07s17-in-f3.1e100.net:http (ESTABLISHED)</span><br></pre></td></tr></table></figure>



<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>查看所有Java进程</p>
<p><code>ps -ef | grep java</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iMacDev110:~ libo$ ps -ef | grep java</span><br><span class="line">  504   584   385   0  91120  ??         6:58.10 /Applications/IntelliJ IDEA.app/Contents/jdk/Contents/Home/jre/bin/java</span><br></pre></td></tr></table></figure>



<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p><strong>top命令</strong>可以实时动态地查看系统的整体运行情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Processes: 438 total, 2 running, 436 sleeping, 2376 threads            11:18:31</span><br><span class="line">Load Avg: 1.90, 1.72, 1.81  CPU usage: 1.44% user, 3.0% sys, 95.55% idle</span><br><span class="line">SharedLibs: 240M resident, 66M data, 109M linkedit.</span><br><span class="line">MemRegions: 173647 total, 5152M resident, 101M private, 1590M shared.</span><br><span class="line">PhysMem: 15G used (2721M wired), 1106M unused.</span><br><span class="line">VM: 2484G vsize, 1372M framework vsize, 665337(0) swapins, 1212872(0) swapouts.</span><br><span class="line">Networks: packets: 15111834/11G <span class="keyword">in</span>, 13503646/5025M out.</span><br><span class="line">Disks: 5491545/66G <span class="built_in">read</span>, 6948210/98G written.</span><br><span class="line"></span><br><span class="line">PID    COMMAND      %CPU TIME     <span class="comment">#TH   #WQ  #PORTS MEM    PURG   CMPRS  PGRP</span></span><br><span class="line">99644  MTLCompilerS 0.0  00:00.05 2     2    24     6572K  0B     6556K  99644</span><br><span class="line">99642  com.apple.We 0.0  00:02.86 4     1    95     4404K  0B     3160K  99642</span><br><span class="line">99641  com.apple.We 0.0  00:01.17 4     1    117    49M    0B     10M    99641</span><br><span class="line">99640  IINA         0.0  01:14.36 11    2    426    107M   0B     55M    99640</span><br><span class="line">99591  PIPAgent     0.0  00:01.52 2     1    68     2664K  0B     1456K  99591</span><br><span class="line">99558  com.apple.pr 0.0  00:01.86 3     1    317    28M    0B     18M    99558</span><br><span class="line">99551  System Prefe 0.0  00:01.84 3     1    288    28M    0B     14M    99551</span><br><span class="line">99520  MTLCompilerS 0.0  00:00.03 2     2    24     4932K  0B     4920K  99520</span><br><span class="line">99519  IMRemoteURLC 0.0  00:00.19 3     1    71     2864K  0B     1804K  99519</span><br></pre></td></tr></table></figure>

<p>查看某个进程的内存占用情况</p>
<p><code>top -p pid</code></p>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p><strong>stat命令</strong>用于显示文件的状态信息。stat命令的输出信息比<a href="http://man.linuxde.net/ls" target="_blank" rel="noopener">ls</a>命令的输出信息要更详细。</p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>日志文件中根据关键词搜索，并加上颜色</p>
<p><code>grep &quot;orderId&quot; info.log --color=auto</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[tomcat8@3f037c3314ba sst-mobile]$ grep <span class="string">"orderId"</span> info.20201117.txt </span><br><span class="line">2020-11-17 00:00:00,854 -- com.sst.service.impl.AutoOrderCombinedServiceImpl            [135] -- Auto order combination <span class="keyword">for</span> user Id:[2],whId:[10],orderId:[217292]</span><br></pre></td></tr></table></figure>





<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p><strong>netstat命令</strong>用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><h5 id="Autowaire-和-Resource-有什么区别？"><a href="#Autowaire-和-Resource-有什么区别？" class="headerlink" title="@Autowaire 和 @Resource 有什么区别？"></a>@Autowaire 和 @Resource 有什么区别？</h5><ol>
<li>@Autowired 注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false</li>
<li>@Resource 默认按名称装配，放在 setter 方法上则按属性名装配。可以通过配置其 type 属性来按类型装配。</li>
<li>@Autowired 结合@Qualifier 可以实现按名称装配。</li>
<li>@Resources 是 JDK 的注解，@Autowired 是 Spring的注解。</li>
</ol>
<table>
<thead>
<tr>
<th>注解对比</th>
<th><code>@Resource</code></th>
<th><code>@Autowire</code></th>
</tr>
</thead>
<tbody><tr>
<td>注解来源</td>
<td>JDK</td>
<td>Spring</td>
</tr>
<tr>
<td>装配方式</td>
<td>优先按名称</td>
<td>优先按类型</td>
</tr>
<tr>
<td>属性</td>
<td>name、type</td>
<td>required</td>
</tr>
</tbody></table>
<h5 id="Autowaire-放在成员变量上和放在set方法上的区别是什么？"><a href="#Autowaire-放在成员变量上和放在set方法上的区别是什么？" class="headerlink" title="@Autowaire 放在成员变量上和放在set方法上的区别是什么？"></a>@Autowaire 放在成员变量上和放在set方法上的区别是什么？</h5><p>放在 setter 上可以对注入的 Bean 做其他的操作，除此之外并无其他区别。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaoDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><h5 id="Spring-AOP和AspectJ是什么关系？"><a href="#Spring-AOP和AspectJ是什么关系？" class="headerlink" title="Spring AOP和AspectJ是什么关系？"></a>Spring AOP和AspectJ是什么关系？</h5><p>其实AOP并不是Spring的专属，AOP最开始是一种编程模型，后来大佬们为了探讨AOP的标准化，统一AOP规范，成立了一个AOP联盟。除了Spring外，AOP的框架有很多，比如AspectJ, AspectWerkz, JBoss-AOP。</p>
<p>最开始，Spring AOP和AspectJ是完全独立的，Spring有自己的实现和使用语法。但是Spring的AOP使用起来太麻烦了，深受大家吐槽。于是Spring支持了广受大家好评的AspectJ语法，通过在配置类上添加<code>@EnableAspectJAutoProxy</code>这个注解来开启对AspectJ的语法。</p>
<p>但Spring<strong>仅仅是支持了AspectJ的部分语法（有些语法是不支持的），但底层实现还是自己的一套东西</strong>。而且两个框架的目标不同，AspectJ是一套完整的AOP解决方案，更为健壮，但使用起来比较复杂，还需要使用特殊的语法和编译器。而Spring的目的是想要把AOP和IoC框架结合起来，让Spring管理的Bean能够很方便地使用AOP的功能。</p>
<p>所以Spring AOP和AspectJ没啥关系，只是Spring借鉴了Aspect的声明语法。</p>
<h4 id="循环依赖-三级缓存"><a href="#循环依赖-三级缓存" class="headerlink" title="循环依赖/三级缓存"></a>循环依赖/三级缓存</h4><p>三级缓存：</p>
<ol>
<li>singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）</li>
<li>earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）</li>
<li>singletonObjects：完成初始化的单例对象的cache（一级缓存）</li>
</ol>
<p>A，B相互依赖的两个类的创建过程：</p>
<ol>
<li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li>
<li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li>
<li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li>
<li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li>
<li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li>
<li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li>
<li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li>
<li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li>
<li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li>
<li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B</strong></li>
</ol>
<h5 id="为什么需要三级缓存，二级缓存不行吗？"><a href="#为什么需要三级缓存，二级缓存不行吗？" class="headerlink" title="为什么需要三级缓存，二级缓存不行吗？"></a>为什么需要三级缓存，二级缓存不行吗？</h5><p>如果没有AOP，其实Spring使用二级缓存就可以解决循环依赖的问题。若使用二级缓存，在AOP情形下，注入到其他Bean的，不是最终的代理对象，而是原始目标对象。</p>
<p>因为Spring对Bean有一个生命周期的定义，而代理对象是在Bean初始化完成后，执行后置处理器的时候生成的。所以不能在二级缓存的时候就直接生成代理对象，放进缓存。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><h4 id="Spring-Boot的主要优点"><a href="#Spring-Boot的主要优点" class="headerlink" title="Spring Boot的主要优点"></a>Spring Boot的主要优点</h4><ol>
<li>开发基于 Spring 的应用程序很容易。</li>
<li>Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。</li>
<li>Spring Boot不需要编写大量样板代码、XML配置和注释。</li>
<li>Spring引导应用程序可以很容易地与Spring生态系统集成，如Spring JDBC、Spring ORM、Spring Data、Spring Security等。</li>
<li>Spring Boot遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。</li>
<li>Spring Boot 应用程序提供嵌入式HTTP服务器，如Tomcat和Jetty，可以轻松地开发和测试web应用程序。（这点很赞！普通运行Java程序的方式就能运行基于Spring Boot web 项目，省事很多）</li>
<li>Spring Boot提供命令行接口(CLI)工具，用于开发和测试Spring Boot应用程序，如Java或Groovy。</li>
<li>Spring Boot提供了多种插件，可以使用内置工具(如Maven和Gradle)开发和测试Spring Boot应用程序。</li>
</ol>
<h4 id="Spring-Boot-最大的优势是什么？"><a href="#Spring-Boot-最大的优势是什么？" class="headerlink" title="Spring Boot 最大的优势是什么？"></a>Spring Boot 最大的优势是什么？</h4><p>Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p>
<h4 id="Spring-Boot-中-“约定优于配置“的具体产品体现在哪里？"><a href="#Spring-Boot-中-“约定优于配置“的具体产品体现在哪里？" class="headerlink" title="Spring Boot 中 “约定优于配置“的具体产品体现在哪里？"></a>Spring Boot 中 “约定优于配置“的具体产品体现在哪里？</h4><p>Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，</p>
<p>Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。</p>
<h4 id="Spring-Boot-Starter-的工作原理是什么？"><a href="#Spring-Boot-Starter-的工作原理是什么？" class="headerlink" title="Spring Boot Starter 的工作原理是什么？"></a>Spring Boot Starter 的工作原理是什么？</h4><ol>
<li>Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件</li>
<li>根据 spring.factories 配置加载 AutoConfigure 类</li>
<li>根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</li>
</ol>
<p>Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。</p>
<h4 id="Starter"><a href="#Starter" class="headerlink" title="Starter"></a>Starter</h4><h5 id="什么是-Spring-Boot-Starters"><a href="#什么是-Spring-Boot-Starters" class="headerlink" title="什么是 Spring Boot Starters?"></a>什么是 Spring Boot Starters?</h5><p>Spring Boot Starters 是一系列依赖关系的集合，因为它的存在，项目的依赖之间的关系对我们来说变的更加简单了。举个例子：在没有Spring Boot Starters之前，我们开发REST服务或Web应用程序时; 我们需要使用像Spring MVC，Tomcat和Jackson这样的库，这些依赖我们需要手动一个一个添加。但是，有了 Spring Boot Starters 我们只需要一个只需添加一个<strong>spring-boot-starter-web</strong>一个依赖就可以了，这个依赖包含的字依赖中包含了我们开发REST 服务需要的所有依赖。</p>
<p>Spring Boot 的 Starter 有两个作用：</p>
<ol>
<li><p>将某个功能/领域所需的依赖集中到一起，可以认为是一个组合依赖。</p>
<p>例如 <code>spring-boot-starter-web</code> 就组合了<code>spring-web</code>、<code>spring-webmvc</code>、<code>spring-boot-starter-tomcat</code> 等依赖。</p>
</li>
<li><p>提供自动配置类给 Spring 完成自动配置</p>
</li>
</ol>
<h5 id="自定义-Starter"><a href="#自定义-Starter" class="headerlink" title="自定义 Starter"></a>自定义 Starter</h5><blockquote>
<p><a href="https://objcoding.com/2018/02/02/Costom-SpringBoot-Starter/" target="_blank" rel="noopener">实战|如何自定义SpringBoot Starter？</a></p>
</blockquote>
<ol>
<li><p>引入 SpringBoot 自动化配置依赖：</p>
<p><code>spring-boot-autoconfigure</code></p>
</li>
<li><p>创建一个 HelloworldService，并定义 sayHello() 方法打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloworldService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String words;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, "</span> + words;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建属性类，指定配置前缀，读取项目配置文件中的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"helloworld"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloworldProperties</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WORDS = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String words = DEFAULT_WORDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自动化配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于一个普通的 java 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 当 HelloworldService 在类路径的条件下</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;HelloworldService<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// 将 <span class="title">application</span>.<span class="title">properties</span> 的相关的属性字段与该类一一对应，并生成 <span class="title">Bean</span></span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">HelloworldProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloworldAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注入属性类</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> HelloworldProperties hellowordProperties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="comment">// 当容器没有这个 Bean 的时候才创建这个 Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(HelloworldService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">HelloworldService</span> <span class="title">helloworldService</span>() </span>&#123;</span><br><span class="line">    HelloworldService helloworldService = <span class="keyword">new</span> HelloworldService();</span><br><span class="line">    helloworldService.setWords(hellowordProperties.getWords());</span><br><span class="line">    <span class="keyword">return</span> helloworldService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 META-INF 目录下创建 spring.factories，指定自动配置类。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">com.objcoding.starters.helloworld.HelloworldAutoConfiguration</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<p>引用自定义的 Starter</p>
<p>在主配置文件中配置响应的配置属性。</p>
<p>在需要的地方通过 <code>@Autowired</code> 注入 HelloworldService，然后调用它的 <code>sayHello()</code> 方法。</p>
</li>
</ol>
<h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>Spring Boot 项目启动时会扫描所有所有依赖 jar 包下的 <code>spring.factories</code> 文件，将其中的自动配置类注册到 Spring IoC 容器中。</p>
<p>Spring Boot 项目的启动注解@SpringBootApplication 由下面三个注解组成：</p>
<ul>
<li>@Configuration</li>
<li>@ComponentScan</li>
<li>@EnableAutoConfiguration</li>
</ul>
<p>其中 <code>@EnableAutoConfiguration</code> 是实现自动配置的入口，该注解又通过 <code>@Import</code> 注解导入了<code>AutoConfigurationImportSelector</code>，在该类中 <code>getCandidateConfigurations</code> 方法会通过 <code>SpringFactoriesLoader.loadFactoryNames()</code> 加载所有 <code>spring.factories</code> 文件中指定的自动配置类。</p>
<p>这些自动配置类中会使用 <code>@EnableConfigurationProperties</code> 注解指定相应的配置属性类，配置属性类中通过 <code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code> 读取主配置文件中相应前缀的配置选项。通过 Conditional 相关注解指定加载相关的服务类(例如 RedisTemplate，RestTemplate)，并将配置类中的配置设置到服务类中，最终通过 <code>@Bean</code> 实例化服务类并注入到容器中。</p>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器的配置比较简单，直接实现<code>Filter</code> 接口即可，也可以通过<code>@WebFilter</code>注解实现对特定<code>URL</code>拦截，看到<code>Filter</code> 接口中定义了三个方法。</p>
<ul>
<li><code>init()</code> ：该方法在容器启动初始化过滤器时被调用，它在 <code>Filter</code> 的整个生命周期只会被调用一次。<strong>注意</strong>：这个方法必须执行成功，否则过滤器会不起作用。</li>
<li><code>doFilter()</code> ：容器中的每一次请求都会调用该方法， <code>FilterChain</code> 用来调用下一个过滤器 <code>Filter</code>。</li>
<li><code>destroy()</code>： 当容器销毁 过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 <code>Filter</code> 的整个生命周期也只会被调用一次</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="title">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Filter 前置"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Filter 处理中"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> destroy() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Filter 后置"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>过滤器用<code>@Order</code>注解控制执行顺序，通过<code>@Order</code>控制过滤器的级别，值越小级别越高越先执行。</p>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>拦截器它是链式调用，一个应用中可以同时存在多个拦截器<code>Interceptor</code>， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行。</p>
<p>首先编写一个简单的拦截器处理类，请求的拦截是通过<code>HandlerInterceptor</code> 来实现，看到<code>HandlerInterceptor</code> 接口中也定义了三个方法。</p>
<ul>
<li><code>preHandle()</code> ：这个方法将在请求处理之前进行调用。<strong>注意</strong>：如果该方法的返回值为<code>false</code> ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行。</li>
<li><code>postHandle()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 <strong>有意思的是</strong>：<code>postHandle()</code> 方法被调用的顺序跟 <code>preHandle()</code> 是相反的，先声明的拦截器  <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法反而会后执行。</li>
<li><code>afterCompletion()</code>：只有在 <code>preHandle()</code> 方法返回值为<code>true</code> 时才会执行。在整个请求结束之后，  DispatcherServlet 渲染了对应的视图之后执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="title">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, <span class="built_in">Object</span> handler) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Interceptor 前置"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> postHandle(HttpServletRequest request, HttpServletResponse response, <span class="built_in">Object</span> handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Interceptor 处理中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> afterCompletion(HttpServletRequest request, HttpServletResponse response, <span class="built_in">Object</span> handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Interceptor 后置"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将自定义好的拦截器处理类进行注册，并通过<code>addPathPatterns</code>、<code>excludePathPatterns</code>等属性设置需要拦截或需要排除的 <code>URL</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="title">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor1()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>拦截器默认的执行顺序，就是它的注册顺序，可以通过<code>order</code>属性手动设置控制，值越小越先执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">  registry.addInterceptor(<span class="keyword">new</span> MyInterceptor2()).addPathPatterns(<span class="string">"/**"</span>).order(<span class="number">2</span>);</span><br><span class="line">  registry.addInterceptor(<span class="keyword">new</span> MyInterceptor1()).addPathPatterns(<span class="string">"/**"</span>).order(<span class="number">1</span>);</span><br><span class="line">  registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>).order(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="过滤器与拦截器的区别"><a href="#过滤器与拦截器的区别" class="headerlink" title="过滤器与拦截器的区别"></a>过滤器与拦截器的区别</h5><ul>
<li>Filter是基于函数回调的，而Interceptor则是基于Java反射的。</li>
<li>Filter依赖于Servlet容器，因此只能在web环境使用，而Interceptor不依赖于Servlet容器。不仅能应用在<code>web</code>程序中，也可以用于<code>Application</code>、<code>Swing</code>等程序中。</li>
<li>Filter对几乎所有的请求起作用，而Interceptor只能对action请求起作用。</li>
<li>Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能。</li>
<li>在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</li>
</ul>
<h5 id="过滤器与拦截器的顺序"><a href="#过滤器与拦截器的顺序" class="headerlink" title="过滤器与拦截器的顺序"></a>过滤器与拦截器的顺序</h5><p>过滤前-拦截前-action执行-拦截后-过滤后</p>
<p>过滤器<code>Filter</code>是在请求进入容器后，但在进入<code>servlet</code>之前进行预处理，请求结束是在<code>servlet</code>处理完以后。</p>
<p>拦截器 <code>Interceptor</code> 是在请求进入<code>servlet</code>后，在进入<code>Controller</code>之前进行预处理的，<code>Controller</code> 中渲染了对应的视图之后请求结束。</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h4><blockquote>
<p><a href="https://juejin.cn/post/6844904047158411277" target="_blank" rel="noopener">搞定SpringBoot多数据源(1)：多套源策略</a></p>
<p><a href="https://juejin.cn/post/6844904050262016007" target="_blank" rel="noopener">搞定SpringBoot多数据源(2)：动态数据源</a></p>
<p><a href="https://juejin.cn/post/6844904052380139528" target="_blank" rel="noopener">搞定SpringBoot多数据源(3)：参数化变更源</a></p>
</blockquote>
<p>在开发过程中，避免不了需要同时操作多个数据库的情况，通常的应用场景如下 ：</p>
<ul>
<li><p>数据库高性能场景：</p>
<p>主从，包括一主一从，一主多从等，在主库进行增删改操作，在从库进行读操作。</p>
</li>
<li><p>数据库高可用场景：</p>
<p>主备，包括一往一备，多主多备等，在数据库无法访问时可以切换。</p>
</li>
<li><p>同构或异构数据的业务处理：</p>
<p>需要处理的数据存储在不同的数据库中，包括同构（如都是 MySQL ），异构（如一个 MySQL ，另外是 PG 或者 Oracle ）。</p>
</li>
</ul>
<p>多数据源一般有三个策略：</p>
<blockquote>
<p>重点看动态数据源就可以了</p>
</blockquote>
<ol>
<li><p>多套数据源：</p>
<p>即针对每个数据库建立一套数据处理逻辑，每套数据库都包括数据源配置、会话工厂（ sessionFactory ）、连接、SQL 操作、实体。各套数据库相互独立。</p>
</li>
<li><p><strong>动态数据源</strong>：</p>
<p>确定数量的多个数据源共用一个会话工厂，根据条件动态选取数据源进行连接、SQL 操作。</p>
</li>
<li><p>参数化变更数据源：</p>
<p>根据参数添加数据源，并进行数据源切换，数据源数量不确定。通常用于对多个数据库的管理工作。</p>
</li>
</ol>
<h5 id="多套数据源"><a href="#多套数据源" class="headerlink" title="多套数据源"></a>多套数据源</h5><h6 id="配置数据库连接信息"><a href="#配置数据库连接信息" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h6><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master</span></span><br><span class="line"><span class="meta">spring.datasource.master.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.master.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/mytest?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">spring.datasource.master.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.master.password</span>=<span class="string">111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># slave</span></span><br><span class="line"><span class="meta">spring.datasource.slave.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.slave.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/my_test1?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">spring.datasource.slave.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.slave.password</span>=<span class="string">111111</span></span><br></pre></td></tr></table></figure>

<h6 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:config/jdbc.properties"</span>)</span><br><span class="line">publicclass DatasourceConfig &#123;</span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"master"</span>)</span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.master"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"slave"</span>)</span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.slave"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="配置-session-工厂"><a href="#配置-session-工厂" class="headerlink" title="配置 session 工厂"></a>配置 session 工厂</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"me.mason.demo.basicmultidatasource.mapper.master"</span>, sqlSessionFactoryRef = <span class="string">"masterSqlSessionFactory"</span>)</span><br><span class="line">publicclass MasterMybatisConfig &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，此处需要使用MybatisSqlSessionFactoryBean，不是SqlSessionFactoryBean，</span></span><br><span class="line"><span class="comment">     * 否则，使用mybatis-plus的内置函数时就会报invalid bound statement (not found)异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"masterSqlSessionFactory"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">masterSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"master"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 设置数据源</span></span><br><span class="line">    MybatisSqlSessionFactoryBean mybatisSqlSessionFactoryBean = <span class="keyword">new</span> MybatisSqlSessionFactoryBean();</span><br><span class="line">    mybatisSqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//mapper的xml文件位置</span></span><br><span class="line">    PathMatchingResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">    String locationPattern = <span class="string">"classpath*:/mapper/master/*.xml"</span>;</span><br><span class="line">    mybatisSqlSessionFactoryBean.setMapperLocations(resolver.getResources(locationPattern));</span><br><span class="line">    <span class="comment">//对应数据库的entity位置</span></span><br><span class="line">    String typeAliasesPackage = <span class="string">"me.mason.demo.basicmultidatasource.entity.master"</span>;</span><br><span class="line">    mybatisSqlSessionFactoryBean.setTypeAliasesPackage(typeAliasesPackage);</span><br><span class="line">    <span class="keyword">return</span> mybatisSqlSessionFactoryBean.getObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="多套实体类、DAO、Mapper"><a href="#多套实体类、DAO、Mapper" class="headerlink" title="多套实体类、DAO、Mapper"></a>多套实体类、DAO、Mapper</h6><p>对应创建多套实体类，DAO接口类，Mapper.xml 文件。</p>
<h6 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h6><p>客户端要操作哪个数据库，就选取对应的 Dao 接口进行操作就可以了。</p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul>
<li><p>简单、直接：</p>
<p>一个库对应一套处理方式，很好理解。</p>
</li>
<li><p>符合开闭原则（ OCP ）：</p>
<p>设计模式告诉我们，对扩展开放，对修改关闭，添加多一个数据库，原来的那一套不需要改动，只添加即可。</p>
</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li><p>资源浪费：</p>
<p>针对每一个数据源写一套操作，连接数据库的资源也是独立的，分别占用同样多的资源。<code>SqlSessionFactory</code> 是一个工厂，建议是使用单例，完全可以重用，不需要建立多个，只需要更改数据源即可，跟多线程，使用线程池减少资源消耗是同一道理。</p>
</li>
<li><p>代码冗余：</p>
<p>在前面的多数据源配置中可以看出，其实 master 和 slave 的很多操作是一样的，只是改个名称而已，因此会造成代码冗余。</p>
</li>
<li><p>缺乏灵活：</p>
<p>所有需要使用的地方都需要引入对应的 mapper，对于很多操作，只是选择的数据源不一样，代码逻辑是一致的。另外，对于一主多从的情况，若需要对多个从库进行负载均衡，相对比较麻烦。</p>
</li>
</ul>
<p>正因为有上述的缺点，所以还有改进的空间。于是就有了动态数据源。</p>
<h5 id="动态数据源"><a href="#动态数据源" class="headerlink" title="动态数据源"></a>动态数据源</h5><h6 id="配置数据库连接信息-1"><a href="#配置数据库连接信息-1" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h6><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master</span></span><br><span class="line"><span class="meta">spring.datasource.master.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.master.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/mytest?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">spring.datasource.master.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.master.password</span>=<span class="string">111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># slave</span></span><br><span class="line"><span class="meta">spring.datasource.slave.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.slave.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/my_test1?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">spring.datasource.slave.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.slave.password</span>=<span class="string">111111</span></span><br></pre></td></tr></table></figure>

<h6 id="配置数据源-1"><a href="#配置数据源-1" class="headerlink" title="配置数据源"></a>配置数据源</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:config/jdbc.properties"</span>)</span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"me.mason.demo.dynamicdatasource.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span>(DataSourceConstants.DS_KEY_MASTER)</span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.master"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(DataSourceConstants.DS_KEY_SLAVE)</span><br><span class="line">  <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.slave"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="配置动态数据源"><a href="#配置动态数据源" class="headerlink" title="配置动态数据源"></a>配置动态数据源</h6><ol>
<li><p><strong>添加动态数据源类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处暂时返回固定 master 数据源, 后面按动态策略修改</span></span><br><span class="line">    <span class="keyword">return</span> DataSourceConstants.DS_KEY_MASTER;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置动态数据源为主数据源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Map&lt;Object, Object&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">  dataSourceMap.put(DataSourceConstants.DS_KEY_MASTER, masterDataSource());</span><br><span class="line">  dataSourceMap.put(DataSourceConstants.DS_KEY_SLAVE, slaveDataSource());</span><br><span class="line">  <span class="comment">//设置动态数据源</span></span><br><span class="line">  DynamicDataSource dynamicDataSource = <span class="keyword">new</span> DynamicDataSource();</span><br><span class="line">  dynamicDataSource.setTargetDataSources(dataSourceMap);</span><br><span class="line">  dynamicDataSource.setDefaultTargetDataSource(masterDataSource());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，需要在 <code>DynamicDataSourceConfig</code> 中，排除 <code>DataSourceAutoConfiguration</code> 的自动配置，否则会出现<code>The dependencies of some of the beans in the application context form a cycle</code>的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude = &#123; DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="动态数据源切换器"><a href="#动态数据源切换器" class="headerlink" title="动态数据源切换器"></a>动态数据源切换器</h6><p>前面固定写了一个数据源路由策略，总是返回 master，显然不是我们想要的。我们想要的是在需要的地方，想切换就切换。因此，需要有一个动态获取数据源 key 的地方（我们称为上下文），对于 web 应用，访问以线程为单位，使用 ThreadLocal 就比较合适，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态数据源名称上下文</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; DATASOURCE_CONTEXT_KEY_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置/切换数据源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContextKey</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    DATASOURCE_CONTEXT_KEY_HOLDER.set(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取数据源名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContextKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String key = DATASOURCE_CONTEXT_KEY_HOLDER.get();</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span>?DataSourceConstants.DS_KEY_MASTER:key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除当前数据源名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeContextKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DATASOURCE_CONTEXT_KEY_HOLDER.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置动态数据源 <code>DynamicDataSource</code> 路由策略</strong></p>
<p>修改前面 <code>DynamicDataSource</code> 的 <code>determineCurrentLookupKey</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DynamicDataSourceContextHolder.getContextKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="直接使用切换器切换数据源"><a href="#直接使用切换器切换数据源" class="headerlink" title="直接使用切换器切换数据源"></a>直接使用切换器切换数据源</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/listall"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">listAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> initSize = <span class="number">2</span>;</span><br><span class="line">  Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(initSize);</span><br><span class="line">  <span class="comment">//默认master查询</span></span><br><span class="line">  QueryWrapper&lt;TestUser&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">  List&lt;TestUser&gt; resultData = testUserMapper.selectAll(queryWrapper.isNotNull(<span class="string">"name"</span>));</span><br><span class="line">  result.put(DataSourceConstants.DS_KEY_MASTER, resultData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//切换数据源，在slave查询</span></span><br><span class="line">  DynamicDataSourceContextHolder.setContextKey(DataSourceConstants.DS_KEY_SLAVE);</span><br><span class="line">  List&lt;TestUser&gt; resultDataSlave = testUserMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">  result.put(DataSourceConstants.DS_KEY_SLAVE, resultDataSlave);</span><br><span class="line">  <span class="comment">//恢复数据源</span></span><br><span class="line">  DynamicDataSourceContextHolder.removeContextKey();</span><br><span class="line">  <span class="comment">//返回数据</span></span><br><span class="line">  <span class="keyword">return</span> ResponseResult.success(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用自定义注解切换数据源"><a href="#使用自定义注解切换数据源" class="headerlink" title="使用自定义注解切换数据源"></a>使用自定义注解切换数据源</h6><p><strong>自定义注解 <code>DS</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DS &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据源名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> DataSourceConstants.DS_KEY_MASTER</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义切面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"@annotation(me.mason.demo.dynamicdatasource.annotation.DS)"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataSourcePointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"dataSourcePointCut()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String dsKey = getDSAnnotation(joinPoint).value();</span><br><span class="line">    DynamicDataSourceContextHolder.setContextKey(dsKey);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      DynamicDataSourceContextHolder.removeContextKey();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类或方法获取数据源注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> DS <span class="title">getDSAnnotation</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = joinPoint.getTarget().getClass();</span><br><span class="line">    DS dsAnnotation = targetClass.getAnnotation(DS<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 先判断类的注解，再判断方法注解</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.nonNull(dsAnnotation))&#123;</span><br><span class="line">      <span class="keyword">return</span> dsAnnotation;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      MethodSignature methodSignature = (MethodSignature)joinPoint.getSignature();</span><br><span class="line">      <span class="keyword">return</span> methodSignature.getMethod().getAnnotation(DS<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在方法/类上使用自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询master库User</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DS</span>(DataSourceConstants.DS_KEY_MASTER)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TestUser&gt; <span class="title">getMasterUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">  QueryWrapper&lt;TestUser&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">  <span class="keyword">return</span> testUserMapper.selectAll(queryWrapper.isNotNull(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询slave库User</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DS</span>(DataSourceConstants.DS_KEY_SLAVE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TestUser&gt; <span class="title">getSlaveUser</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> testUserMapper.selectList(<span class="keyword">null</span>); &#125;</span><br></pre></td></tr></table></figure>

<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><p>对于动态数据源，还有哪些地方需要考虑或者说值得改进的地方呢？</p>
<ul>
<li>事务如何处理？其实在开发中应该尽量避免跨库事务，但如果避免不了，则需要使用分布式事务。</li>
<li>对于当前的动态数据源，相对来说还是固定的数据源（如一主一从，一主多从等），即在编码时已经确定的数据库数量，只是在具体使用哪一个时进行动态处理。如果数据源本身并不确定，或者说需要根据用户输入来连接数据库，这时，如何处理呢？这种情况出现得比较多的是在对多个数据库进行管理时的处理。这种情况，我将在下一篇文章中进行讲解，我把它叫做”参数化变更数据源”。</li>
</ul>
<h4 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h4><p><code>#{value}</code> 会将value添加上双引号，而 <code>${}</code> 则是原封不动的插入 sql，会导致 sql 注入问题。</p>
<h4 id="Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h4><p><code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h4 id="MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<h4 id="为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h4><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><h4 id="什么是-Spring-Cloud"><a href="#什么是-Spring-Cloud" class="headerlink" title="什么是 Spring Cloud"></a>什么是 Spring Cloud</h4><blockquote>
<p>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems.</p>
<p>Spring Cloud 为开发人员提供了在分布式系统中快速构建一些常见模式的工具。</p>
</blockquote>
<p>Spring Cloud 就是微服务系统架构的一站式解决方案，在构建微服务的过程中需要做注册中心 、配置中心 、服务网关 、数据监控等等，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<h4 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h4><ul>
<li><code>Eureka</code> 服务发现框架</li>
<li><code>Ribbon</code> 进程内负载均衡器</li>
<li><code>Open Feign</code> 服务调用映射</li>
<li><code>Hystrix</code> 服务降级熔断器</li>
<li><code>Zuul</code> 微服务网关</li>
<li><code>Config</code> 微服务统一配置中心</li>
<li><code>Bus</code> 消息总线</li>
</ul>
<h4 id="服务注册管理中心-Eureka"><a href="#服务注册管理中心-Eureka" class="headerlink" title="服务注册管理中心 Eureka"></a>服务注册管理中心 Eureka</h4><p>Eureka 就是一个服务发现框架。主要提供服务注册和服务发现两大功能。</p>
<p>其实就是服务提供者和服务消费者之间的“桥梁/中介”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务就可以在服务中介中寻找注册在服务中介的服务提供者。</p>
<h5 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h5><p>当 <code>Eureka</code> 客户端向 <code>Eureka Server</code> 注册时，它提供自身的<strong>元数据</strong>，比如IP地址、端口，运行状况指示符URL，主页等。</p>
<h5 id="心跳连接"><a href="#心跳连接" class="headerlink" title="心跳连接"></a>心跳连接</h5><p>Eureka 客户端默认情况下会每隔30秒发送一次心跳连接。用来告知 Eureka Server 该 Eureka 客户仍然存活，没有出现问题。 </p>
<p>正常情况下，如果 Eureka Server 在90秒没有收到 Eureka 客户的续约，它会将实例从其注册表中删除。</p>
<h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5><p>Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。</p>
<h5 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h5><p>Eureka 客户端在程序关闭时向Eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。</p>
<p>该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p>
<h5 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h5><p>如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时：</p>
<ol>
<li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li>
</ol>
<h5 id="与-zookeeper-的区别"><a href="#与-zookeeper-的区别" class="headerlink" title="与 zookeeper 的区别"></a>与 zookeeper 的区别</h5><p>CAP 理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。</p>
<blockquote>
<p> CAP:</p>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance（分区容错性）</li>
</ul>
<p>BASE：</p>
<ul>
<li>Basically Available（基本可用）</li>
<li>Soft state（软状态）</li>
<li>Eventually consistent（最终一致性）</li>
</ul>
</blockquote>
<h6 id="Zookeeper保证CP"><a href="#Zookeeper保证CP" class="headerlink" title="Zookeeper保证CP"></a>Zookeeper保证CP</h6><p>zk 会出现这样的情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。</p>
<p>选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。</p>
<h6 id="Eureka保证AP"><a href="#Eureka保证AP" class="headerlink" title="Eureka保证AP"></a>Eureka保证AP</h6><p>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。</p>
<p>而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<p>除此之外，Eureka还有一种自我保护机制。</p>
<p>因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p>
<h4 id="负载均衡器-Ribbon"><a href="#负载均衡器-Ribbon" class="headerlink" title="负载均衡器 Ribbon"></a>负载均衡器 Ribbon</h4><blockquote>
<p><strong><code>RestTemplate</code>是<code>Spring</code>提供的一个访问Http服务的客户端类</strong>，微服务之间的调用是使用的 <code>RestTemplate</code> 。</p>
</blockquote>
<p><code>Ribbon</code> 是一个客户端内的负载均衡器，<strong>运行在消费者端</strong>。</p>
<h6 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h6><ul>
<li><strong><code>RoundRobinRule</code></strong>：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 <code>null</code>。</li>
<li><strong><code>RandomRule</code></strong>: 随机策略，从所有可用的 <code>provider</code> 中随机选择一个。</li>
<li><strong><code>RetryRule</code></strong>: 重试策略。先按照 <code>RoundRobinRule</code> 策略获取 <code>provider</code>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li>
</ul>
<h6 id="Nginx-和-Ribbon-的对比"><a href="#Nginx-和-Ribbon-的对比" class="headerlink" title="Nginx 和 Ribbon 的对比"></a>Nginx 和 Ribbon 的对比</h6><p>提到 <strong>负载均衡</strong> 就不得不提到大名鼎鼎的 <code>Nignx</code> 了，而和 <code>Ribbon</code> 不同的是，Nginx 是一种<strong>集中式</strong>的负载均衡器。</p>
<p>何为集中式呢？简单理解就是 <strong>将所有请求都集中起来，然后再进行负载均衡</strong>。</p>
<p>在 <code>Nginx</code> 中请求是先进入负载均衡器，而在 <code>Ribbon</code> 中是先在客户端进行负载均衡才进行请求的。</p>
<h4 id="服务调用-OpenFeign"><a href="#服务调用-OpenFeign" class="headerlink" title="服务调用 OpenFeign"></a>服务调用 OpenFeign</h4><blockquote>
<p><code>OpenFeign</code> 运行在消费者端，使用 <code>Ribbon</code> 进行负载均衡，所以 <code>OpenFeign</code> 直接内置了 <code>Ribbon</code>。</p>
</blockquote>
<p>Spring Cloud OpenFeign 是基于Ribbon和Hystrix的<strong>声明式</strong>服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>
<h4 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h4><p><code>Hystrix</code> 就是一个能进行 <strong>熔断</strong> 和 <strong>降级</strong> 的库，通过使用它能提高整个系统的弹性。</p>
<h5 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h5><p><strong>熔断</strong> 是指的 <code>Hystrix</code> 中的 <strong>断路器模式</strong> ，你可以使用简单的 <code>@HystrixCommand</code> 注解来标注某个服务调用接口，这样 <code>Hystrix</code> 就会使用 <strong>断路器</strong> 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(</span><br><span class="line">  commandProperties = &#123;<span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value = <span class="string">"1200"</span>)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Xxx&gt; <span class="title">getXxxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h5><p><strong>降级是为了更好的用户体验，当一个服务调用异常时，通过执行另一种代码逻辑来给用户友好的回复</strong>。这也就对应着 <code>Hystrix</code> 的 <strong>后备处理</strong> 模式。你可以通过设置 <code>fallbackMethod</code> 来给一个方法设置备用的代码逻辑。</p>
<p>比如有一个热点新闻，大量用户同时访问可能会导致系统崩溃，那么我们就进行 <strong>服务降级</strong> ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定了后备方法调用</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getHystrixNews"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/get/news"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> News <span class="title">getNews</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用新闻系统的获取新闻api 代码逻辑省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> News <span class="title">getHystrixNews</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">  <span class="comment">// 做服务降级</span></span><br><span class="line">  <span class="comment">// 返回当前人数太多，请稍后查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务网关-Zuul"><a href="#服务网关-Zuul" class="headerlink" title="服务网关 Zuul"></a>服务网关 Zuul</h4><p>网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行<strong>鉴权</strong>、<strong>限流</strong>、 <strong>路由</strong>、<strong>监控</strong>等功能。</p>
<p><code>Zuul</code> 中最关键的就是 <strong>路由和过滤器</strong></p>
<p><code>Zuul</code> 需要向 <code>Eureka</code> 进行注册，然后在启动类上加入 <code>@EnableZuulProxy</code> 注解。</p>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><h6 id="统一前缀"><a href="#统一前缀" class="headerlink" title="统一前缀"></a>统一前缀</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/zuul</span></span><br></pre></td></tr></table></figure>

<h6 id="服务别名"><a href="#服务别名" class="headerlink" title="服务别名"></a>服务别名</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">consumer1:</span> <span class="string">/FrancisQ1/**</span></span><br><span class="line">    <span class="attr">consumer2:</span> <span class="string">/FrancisQ2/**</span></span><br></pre></td></tr></table></figure>

<h6 id="服务名屏蔽"><a href="#服务名屏蔽" class="headerlink" title="服务名屏蔽"></a>服务名屏蔽</h6><p>在配置完路由策略之后使用微服务名称还是可以访问的，这个时候需要将服务名屏蔽。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignore-services:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<h6 id="路径屏蔽"><a href="#路径屏蔽" class="headerlink" title="路径屏蔽"></a>路径屏蔽</h6><p><code>Zuul</code> 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignore-patterns:</span> <span class="string">**/auto/**</span></span><br></pre></td></tr></table></figure>

<h6 id="敏感请求头屏蔽"><a href="#敏感请求头屏蔽" class="headerlink" title="敏感请求头屏蔽"></a>敏感请求头屏蔽</h6><p>默认情况下，像 <code>Cookie</code>、<code>Set-Cookie</code> 等敏感请求头信息会被 <code>zuul</code> 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。</p>
<h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>如果说路由功能是 <code>Zuul</code> 的基操的话，那么<strong>过滤器</strong>就是 <code>Zuul</code>的利器了。可以进行各种过滤，这样我们就能实现 <strong>限流</strong>，<strong>灰度发布</strong>，<strong>权限控制</strong> 等等。</p>
<p>要实现自己的 <code>Filter</code> 只需要继承 <code>ZuulFilter</code> 然后将这个过滤器类以 <code>@Component</code> 注解加入 Spring 容器中就行了。</p>
<h6 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h6><p>首先会有个令牌桶，如果里面没有满那么就会以一定 <strong>固定的速率</strong> 会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么就拒绝，如果获取到那么就放行。</p>
<h4 id="配置中心-Config"><a href="#配置中心-Config" class="headerlink" title="配置中心 Config"></a>配置中心 Config</h4><h5 id="什么是-Spring-Cloud-Config"><a href="#什么是-Spring-Cloud-Config" class="headerlink" title="什么是 Spring Cloud Config"></a>什么是 Spring Cloud Config</h5><blockquote>
<p><code>Spring Cloud Config</code> 为分布式系统中的外部化配置提供服务器和客户端支持。使用 <code>Config</code> 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p>
</blockquote>
<p><code>Spring Cloud Config</code> 就是能将各个 服务/应用/系统/模块 的配置文件存放到 <strong>统一的地方(e.g. Git)然后进行管理</strong>。</p>
<p>应用只有启动的时候才会进行配置文件的加载，那么我们的 <code>Spring Cloud Config</code> 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。</p>
<p>如果应用运行时去更改远程配置仓库(Git)中的对应配置文件，那么依赖于这个配置文件的已启动的应用会不会进行其相应配置的更改呢？答案是不会的。</p>
<p>可以使用 <code>Webhooks</code> ，这是 <code>github</code> 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。</p>
<p>但是生产环境不会使用。一般会使用 <code>Bus</code> 消息总线 + <code>Spring Cloud Config</code> 进行配置的动态刷新。</p>
<h4 id="消息总线-Bus"><a href="#消息总线-Bus" class="headerlink" title="消息总线 Bus"></a>消息总线 Bus</h4><blockquote>
<p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。</p>
</blockquote>
<p><code>Spring Cloud Bus</code> 的作用就是<strong>管理和广播分布式系统中的消息</strong>，也就是消息引擎系统中的广播模式。</p>
<h3 id="Spring-Cloud-与-Spring-Cloud-Alibaba-的区别"><a href="#Spring-Cloud-与-Spring-Cloud-Alibaba-的区别" class="headerlink" title="Spring Cloud 与 Spring Cloud Alibaba 的区别"></a>Spring Cloud 与 Spring Cloud Alibaba 的区别</h3><p>我们平常说的 Spring Cloud 其实是指 Spring Cloud 其中的一种实现方式，即 Spring Cloud Netflix，而 Spring Cloud Alibaba 则是另一套实现方式。</p>
<p><img data-src="https://segmentfault.com/img/remote/1460000021497456" alt=""></p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="负载均衡的6种策略"><a href="#负载均衡的6种策略" class="headerlink" title="负载均衡的6种策略"></a>负载均衡的6种策略</h4><ol>
<li><p>轮询（默认）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">	server 192.168.0.14;</span><br><span class="line">	server 192.168.0.15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定权重<br> 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">	server 192.168.0.14 weight&#x3D;8;</span><br><span class="line">	server 192.168.0.15 weight&#x3D;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>权重越高，访问概率越大。</p>
</li>
<li><p>ip_hash</p>
<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session共享问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	server 192.168.0.14:88;</span><br><span class="line">	server 192.168.0.15:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最少连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream item &#123; # item名字可以自定义</span><br><span class="line">	least_conn;</span><br><span class="line">	server 192.168.101.60:81;</span><br><span class="line">	server 192.168.101.77:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">	server server1;</span><br><span class="line">	server server2;</span><br><span class="line">	fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>url_hash（第三方）<br> 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">	server squid1:3128;</span><br><span class="line">	server squid2:3128;</span><br><span class="line">	hash $request_uri;</span><br><span class="line">	hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最后需要在server.location中指定上面定义的upstream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen: 80</span><br><span class="line">	location: &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;backserver</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡参数"><a href="#负载均衡参数" class="headerlink" title="负载均衡参数"></a>负载均衡参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面的参数可同时配置，使用空格分开即可</span><br><span class="line">&#39;配置方式 server ip:端口 参数&#39;</span><br><span class="line"></span><br><span class="line">- &#39;weight 权重&#39;</span><br><span class="line"># weight &#x3D; 数值 (值越高被选中的概率也就越高)</span><br><span class="line"></span><br><span class="line">- &#39;max_fails 失败多少次踢出队列&#39;</span><br><span class="line"># max_fails &#x3D; 数值</span><br><span class="line"></span><br><span class="line">- &#39;fail_timeout 踢出队列后重新探测时间&#39;</span><br><span class="line"># fail_timeout &#x3D; 60s (s &#x3D; 秒)</span><br><span class="line"></span><br><span class="line">- &#39;max_conns 最大连接数&#39;</span><br><span class="line"># max_conns &#x3D; 800 为防止单机性能过载可以根据实际情况设置</span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/redis-all.md" target="_blank" rel="noopener">Redis | JavaGuide</a></p>
</blockquote>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><blockquote>
<p><a href="https://juejin.im/post/6844903644798664712" target="_blank" rel="noopener">通俗易懂的Redis数据结构基础教程</a></p>
</blockquote>
<p>Redis有5个基本数据结构，string、list、hash、set和zset。</p>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>Redis的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。</p>
<p>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。</p>
<p>字符串最大长度为512M。</p>
<h6 id="初始化字符串"><a href="#初始化字符串" class="headerlink" title="初始化字符串"></a>初始化字符串</h6><p>需要提供「变量名称」和「变量的内容」</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set ireader beijing.zhangyue.keji.gufen.youxian.gongsi</span><br><span class="line">OK</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="获取字符串的内容"><a href="#获取字符串的内容" class="headerlink" title="获取字符串的内容"></a>获取字符串的内容</h6><p>提供「变量名称」</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; get ireader</span><br><span class="line">&quot;beijing.zhangyue.keji.gufen.youxian.gongsi&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h6><p>提供「变量名称」</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; strlen ireader</span><br><span class="line">(integer) 42</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="获取子串"><a href="#获取子串" class="headerlink" title="获取子串"></a>获取子串</h6><p>提供「变量名称」以及开始和结束位置[start, end]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; getrange ireader 28 34</span><br><span class="line">&quot;youxian&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="覆盖子串"><a href="#覆盖子串" class="headerlink" title="覆盖子串"></a>覆盖子串</h6><p>提供「变量名称」以及开始位置和目标子串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; setrange ireader 28 wooxian</span><br><span class="line">(<span class="built_in">integer</span>) 42  <span class="comment"># 返回长度</span></span><br><span class="line">&gt; get ireader</span><br><span class="line"><span class="string">"beijing.zhangyue.keji.gufen.wooxian.gongsi"</span></span><br></pre></td></tr></table></figure>

<h6 id="追加子串"><a href="#追加子串" class="headerlink" title="追加子串"></a>追加子串</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; append ireader .hao</span><br><span class="line">(<span class="built_in">integer</span>) 46 <span class="comment"># 返回长度</span></span><br><span class="line">&gt; get ireader</span><br><span class="line"><span class="string">"beijing.zhangyue.keji.gufen.wooxian.gongsi.hao"</span></span><br></pre></td></tr></table></figure>

<p>字符串没有提供子串插入方法和子串删除方法。</p>
<h6 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h6><p>如果字符串的内容是一个整数，那么还可以将字符串当成计数器来使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> ireader 42</span><br><span class="line">OK</span><br><span class="line">&gt; get ireader</span><br><span class="line"><span class="string">"42"</span></span><br><span class="line">&gt; incrby ireader 100</span><br><span class="line">(<span class="built_in">integer</span>) 142</span><br><span class="line">&gt; get ireader</span><br><span class="line"><span class="string">"142"</span></span><br><span class="line">&gt; decrby ireader 100</span><br><span class="line">(<span class="built_in">integer</span>) 42</span><br><span class="line">&gt; get ireader</span><br><span class="line"><span class="string">"42"</span></span><br><span class="line">&gt; incr ireader  <span class="comment"># 等价于incrby ireader 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 43</span><br><span class="line">&gt; decr ireader  <span class="comment"># 等价于decrby ireader 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 42</span><br></pre></td></tr></table></figure>

<p>计数器是有范围的，它不能超过Long.Max，不能低于Long.MIN</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> ireader 9223372036854775807</span><br><span class="line">OK</span><br><span class="line">&gt; incr ireader</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br><span class="line">&gt; <span class="built_in">set</span> ireader -9223372036854775808</span><br><span class="line">OK</span><br><span class="line">&gt; decr ireader</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br></pre></td></tr></table></figure>

<h6 id="过期和删除"><a href="#过期和删除" class="headerlink" title="过期和删除"></a>过期和删除</h6><p>字符串可以使用del指令进行主动删除，可以使用expire指令设置过期时间，到点会自动删除，这属于被动删除。可以使用ttl指令获取字符串的寿命。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; expire ireader 60</span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment"># 1表示设置成功，0表示变量ireader不存在</span></span><br><span class="line">&gt; ttl ireader</span><br><span class="line">(<span class="built_in">integer</span>) 50  <span class="comment"># 还有50秒的寿命，返回-2表示变量不存在，-1表示没有设置过期时间</span></span><br><span class="line">&gt; del ireader</span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment"># 删除成功返回1</span></span><br><span class="line">&gt; get ireader</span><br><span class="line">(nil)  <span class="comment"># 变量ireader没有了</span></span><br></pre></td></tr></table></figure>

<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p><img data-src="https://user-gold-cdn.xitu.io/2018/7/22/164c25d671d13466" alt=""></p>
<p>Redis将列表数据结构命名为list而不是array，是因为列表的存储结构用的是链表而不是数组，而且链表还是双向链表。因为它是链表，所以随机定位性能较弱，首尾插入删除性能较优。</p>
<h6 id="负下标"><a href="#负下标" class="headerlink" title="负下标"></a>负下标</h6><p>链表元素的位置使用自然数<code>0,1,2,....n-1</code>表示，还可以使用负数<code>-1,-2,...-n</code>来表示，<code>-1</code>表示「倒数第一」，<code>-2</code>表示「倒数第二」，那么<code>-n</code>就表示第一个元素，对应的下标为<code>0</code>。</p>
<h6 id="队列／堆栈"><a href="#队列／堆栈" class="headerlink" title="队列／堆栈"></a>队列／堆栈</h6><p>链表可以从表头和表尾追加和移除元素，结合使用 rpush/rpop/lpush/lpop 四条指令，可以将链表作为队列或堆栈使用，左向右向进行都可以。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 右进左出</span></span><br><span class="line">&gt; rpush ireader go</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; rpush ireader java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lpop ireader</span><br><span class="line"><span class="string">"go"</span></span><br><span class="line">&gt; lpop ireader</span><br><span class="line"><span class="string">"java"</span></span><br><span class="line">&gt; lpop ireader</span><br><span class="line"><span class="string">"python"</span></span><br><span class="line"><span class="comment"># 左进右出</span></span><br><span class="line">&gt; lpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; rpop ireader</span><br><span class="line"><span class="string">"go"</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 右进右出</span></span><br><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; rpop ireader </span><br><span class="line"><span class="string">"python"</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 左进左出</span></span><br><span class="line">&gt; lpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lpop ireader</span><br><span class="line"><span class="string">"python"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在日常应用中，列表常用来作为异步队列来使用。</p>
<h6 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h6><p>使用llen指令获取链表长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; llen ireader</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h6 id="随机读"><a href="#随机读" class="headerlink" title="随机读"></a>随机读</h6><p>可以使用 lindex 指令访问指定位置的元素。</p>
<p>使用 lrange 指令来获取链表子元素列表，提供start和end下标参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lindex ireader 1</span><br><span class="line"><span class="string">"java"</span></span><br><span class="line">&gt; lrange ireader 0 2</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">&gt; lrange ireader 0 -1  <span class="comment"># -1表示倒数第一</span></span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br></pre></td></tr></table></figure>

<h6 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h6><p>使用lset指令修改指定位置的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lset ireader 1 javascript</span><br><span class="line">OK</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"javascript"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br></pre></td></tr></table></figure>

<h6 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h6><p>使用linsert指令在列表的中间位置插入元素，linsert指令里增加了方向参数before/after来显示指示前置和后置插入。</p>
<p>不过linsert指令并不是通过指定位置来插入，而是通过指定具体的值。这是因为在分布式环境下，列表的元素总是频繁变动的，意味着上一时刻计算的元素下标在下一时刻可能就不是你所期望的下标了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; linsert ireader before java ruby</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"ruby"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">4) <span class="string">"python"</span></span><br></pre></td></tr></table></figure>

<h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h6><p>列表的删除操作也不是通过指定下标来确定元素的，你需要指定删除的最大个数以及元素的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lrem ireader 1 java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"python"</span></span><br></pre></td></tr></table></figure>

<h6 id="定长列表"><a href="#定长列表" class="headerlink" title="定长列表"></a>定长列表</h6><p>在实际应用场景中，我们有时候会遇到「定长列表」的需求。比如要以走马灯的形式实时显示中奖用户名列表，因为中奖用户实在太多，能显示的数量一般不超过100条，那么这里就会使用到定长列表。维持定长列表的指令是ltrim，需要提供两个参数start和end，表示需要保留列表的下标范围，范围之外的所有元素都将被移除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpush ireader go java python javascript ruby erlang rust cpp</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">&gt; ltrim ireader -3 -1</span><br><span class="line">OK</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) <span class="string">"erlang"</span></span><br><span class="line">2) <span class="string">"rust"</span></span><br><span class="line">3) <span class="string">"cpp"</span></span><br></pre></td></tr></table></figure>

<p>如果指定参数的end对应的真实下标小于start，其效果等价于del指令，因为这样的参数表示需要需要保留列表元素的下标范围为空。</p>
<h6 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h6><p><img data-src="https://user-gold-cdn.xitu.io/2018/7/27/164d91746fbe0442" alt="img"></p>
<p>如果再深入一点，你会发现Redis底层存储的还不是一个简单的linkedlist，而是称之为快速链表quicklist的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。所以Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的冗余空间。</p>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><p><img data-src="https://user-gold-cdn.xitu.io/2018/7/23/164c4eaf9edf608d" alt="img"></p>
<p>哈希等价于Java语言的HashMap，在实现结构上它使用二维结构，第一维是数组，第二维是链表，hash的内容key和value存放在链表中，数组里存放的是链表的头指针。通过key查找元素时，先计算key的hashcode，然后用hashcode对数组的长度进行取模定位到链表的表头，再对链表进行遍历获取到相应的value值，链表的作用就是用来将产生了「hash碰撞」的元素串起来。Java语言开发者会感到非常熟悉，因为这样的结构和HashMap是没有区别的。哈希的第一维数组的长度也是2^n。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/7/23/164c4dcd14c00534" alt="img"></p>
<h6 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h6><p>可以使用hset一次增加一个键值对，也可以使用hmset一次增加多个键值对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hset ireader go fast</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hmset ireader java fast python slow</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h6 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h6><p>可以通过hget定位具体key对应的value，可以通过hmget获取多个key对应的value，可以使用hgetall获取所有的键值对，可以使用hkeys和hvals分别获取所有的key列表和value列表。这些操作和Java语言的Map接口是类似的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hget ireader go</span><br><span class="line"><span class="string">"fast"</span></span><br><span class="line">&gt; hmget ireader go python</span><br><span class="line">1) <span class="string">"fast"</span></span><br><span class="line">2) <span class="string">"slow"</span></span><br><span class="line">&gt; hgetall ireader</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"fast"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">4) <span class="string">"fast"</span></span><br><span class="line">5) <span class="string">"python"</span></span><br><span class="line">6) <span class="string">"slow"</span></span><br><span class="line">&gt; hkeys ireader</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">&gt; hvals ireader</span><br><span class="line">1) <span class="string">"fast"</span></span><br><span class="line">2) <span class="string">"fast"</span></span><br><span class="line">3) <span class="string">"slow"</span></span><br></pre></td></tr></table></figure>

<h6 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h6><p>可以使用hdel删除指定key，hdel支持同时删除多个key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hdel ireader go</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hdel ireader java python</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h6 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h6><p>通常我们使用hget获得key对应的value是否为空就直到对应的元素是否存在了，不过如果value的字符串长度特别大，通过这种方式来判断元素存在与否就略显浪费，这时可以使用hexists指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hexists ireader go</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h6 id="计数器-1"><a href="#计数器-1" class="headerlink" title="计数器"></a>计数器</h6><p>hash结构还可以当成计数器来使用，对于内部的每一个key都可以作为独立的计数器。如果value值不是整数，调用hincrby指令会出错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; hincrby ireader go 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hincrby ireader python 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; hincrby ireader java 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; hgetall ireader</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"java"</span></span><br><span class="line">6) <span class="string">"4"</span></span><br><span class="line">&gt; hset ireader rust good</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hincrby ireader rust 1</span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br></pre></td></tr></table></figure>

<h6 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h6><p>当hash内部的元素比较拥挤时(hash碰撞比较频繁)，就需要进行扩容。扩容需要申请新的两倍大小的数组，然后将所有的键值对重新分配到新的数组下标对应的链表中(rehash)。</p>
<p>如果hash结构很大，比如有上百万个键值对，那么一次完整rehash的过程就会耗时很长。这对于单线程的Redis里来说有点压力山大。所以Redis采用了渐进式rehash的方案。它会同时保留两个新旧hash结构，在后续的定时任务以及hash结构的读写指令中将旧结构的元素逐渐迁移到新的结构中。这样就可以避免因扩容导致的线程卡顿现象。</p>
<h6 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h6><p>Redis的hash结构不但有扩容还有缩容，从这一点出发，它要比Java的HashMap要厉害一些，Java的HashMap只有扩容。缩容的原理和扩容是一致的，只不过新的数组大小要比旧数组小一倍。</p>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>Java 中 HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。</p>
<p>Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h6 id="增加元素-1"><a href="#增加元素-1" class="headerlink" title="增加元素"></a>增加元素</h6><p>可以一次增加多个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sadd ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h6 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h6><p>使用smembers列出所有元素，</p>
<p>使用scard获取集合长度，</p>
<p>使用srandmember随机获取count个元素，如果不提供count参数，默认为1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sadd ireader go java python</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; smembers ireader</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"python"</span></span><br><span class="line">3) <span class="string">"go"</span></span><br><span class="line">&gt; scard ireader</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; srandmember ireader</span><br><span class="line"><span class="string">"java"</span></span><br></pre></td></tr></table></figure>

<h6 id="删除元素-2"><a href="#删除元素-2" class="headerlink" title="删除元素"></a>删除元素</h6><p>使用srem删除一到多个元素，使用spop随机删除一个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sadd ireader go java python rust erlang</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">&gt; srem ireader go java</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; spop ireader</span><br><span class="line"><span class="string">"erlang"</span></span><br></pre></td></tr></table></figure>

<h6 id="判断元素是否存在-1"><a href="#判断元素是否存在-1" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h6><p>使用sismember指令，只能接收单个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sadd ireader go java python rust erlang</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">&gt; sismember ireader rust</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; sismember ireader javascript</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h5 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h5><p><img data-src="https://user-gold-cdn.xitu.io/2018/7/23/164c4ec77aac6132" alt="img"></p>
<p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重<code>score</code>，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层实现使用了两个数据结构，第一个是hash，第二个是跳跃列表，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。跳跃列表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h6 id="增加元素-2"><a href="#增加元素-2" class="headerlink" title="增加元素"></a>增加元素</h6><p>通过zadd指令可以增加一到多个value/score对，score放在前面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zadd ireader 4.0 python</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; zadd ireader 4.0 java 1.0 go</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h6 id="长度-1"><a href="#长度-1" class="headerlink" title="长度"></a>长度</h6><p>通过指令zcard可以得到zset的元素个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zcard ireader</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h6 id="删除元素-3"><a href="#删除元素-3" class="headerlink" title="删除元素"></a>删除元素</h6><p>通过指令zrem可以删除zset中的元素，可以一次删除多个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zrem ireader go python</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h6 id="计数器-2"><a href="#计数器-2" class="headerlink" title="计数器"></a>计数器</h6><p>同hash结构一样，zset也可以作为计数器使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zadd ireader 4.0 python 4.0 java 1.0 go</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; zincrby ireader 1.0 python</span><br><span class="line"><span class="string">"5"</span></span><br></pre></td></tr></table></figure>

<h6 id="获取排名和分数"><a href="#获取排名和分数" class="headerlink" title="获取排名和分数"></a>获取排名和分数</h6><p>通过zscore指令获取指定元素的权重，通过zrank指令获取指定元素的正向排名，通过zrevrank指令获取指定元素的反向排名[倒数第一名]。正向是由小到大，负向是由大到小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zscore ireader python</span><br><span class="line"><span class="string">"5"</span></span><br><span class="line">&gt; zrank ireader go  <span class="comment"># 分数低的排名考前，rank值小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; zrank ireader java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; zrank ireader python</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zrevrank ireader python</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h6 id="根据排名范围获取元素列表"><a href="#根据排名范围获取元素列表" class="headerlink" title="根据排名范围获取元素列表"></a>根据排名范围获取元素列表</h6><p>通过zrange指令指定排名范围参数获取对应的元素列表，携带withscores参数可以一并获取元素的权重。</p>
<p>通过zrevrange指令按负向排名获取元素列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zrange ireader 0 -1  <span class="comment"># 获取所有元素</span></span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">&gt; zrange ireader 0 -1 withscores</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"python"</span></span><br><span class="line">6) <span class="string">"5"</span></span><br><span class="line">&gt; zrevrange ireader 0 -1 withscores</span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"5"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"go"</span></span><br><span class="line">6) <span class="string">"1"</span></span><br></pre></td></tr></table></figure>

<h6 id="根据score范围获取列表"><a href="#根据score范围获取列表" class="headerlink" title="根据score范围获取列表"></a>根据score范围获取列表</h6><p>通过zrangebyscore指令指定score范围获取对应的元素列表。通过zrevrangebyscore指令获取倒排元素列表。</p>
<p>参数<code>-inf</code>表示负无穷，<code>+inf</code>表示正无穷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zrangebyscore ireader 0 5</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">&gt; zrangebyscore ireader -inf +inf withscores</span><br><span class="line">1) <span class="string">"go"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"python"</span></span><br><span class="line">6) <span class="string">"5"</span></span><br><span class="line">&gt; zrevrangebyscore ireader +inf -inf withscores  <span class="comment"># 注意正负反过来了</span></span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"5"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"go"</span></span><br><span class="line">6) <span class="string">"1"</span></span><br></pre></td></tr></table></figure>

<h6 id="根据范围移除元素列表"><a href="#根据范围移除元素列表" class="headerlink" title="根据范围移除元素列表"></a>根据范围移除元素列表</h6><p>可以通过排名范围，也可以通过score范围来一次性移除多个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; zremrangebyrank ireader 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 2  <span class="comment"># 删掉了2个元素</span></span><br><span class="line">&gt; zadd ireader 4.0 java 1.0 go</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zremrangebyscore ireader -inf 4</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zrange ireader 0 -1</span><br><span class="line">1) <span class="string">"python"</span></span><br></pre></td></tr></table></figure>

<h6 id="跳跃列表"><a href="#跳跃列表" class="headerlink" title="跳跃列表"></a>跳跃列表</h6><p>zset内部的排序功能是通过「跳跃列表」数据结构来实现的。</p>
<p>因为zset要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/7/23/164c5a90442cd51a" alt="img"></p>
<p>我们需要这个链表按照score值进行排序。这意味着当有新元素需要插入时，需要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p>
<p>跳跃列表就是类似于（公司-部门-组长）这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/7/23/164c5bb13c6da230" alt="img"></p>
<p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于L0、L1和L2层，可以快速在不同层次之间进行「跳跃」。</p>
<p>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问那新插入的元素如何才有机会「身兼数职」呢？</p>
<p>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层，首先L0层肯定是100%了，L1层只有50%的概率，L2层只有25%的概率，L3层只有12.5%的概率，一直随机到最顶层L31层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>虽然说 Redis 是单线程模型，但是， 实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些<strong>大键值对的删除操作</strong>的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
<p>Redis6.0 引入多线程主要是为了提高<strong>网络 IO</strong> 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<h5 id="为什么-Redis-选择单线程模型"><a href="#为什么-Redis-选择单线程模型" class="headerlink" title="为什么 Redis 选择单线程模型"></a>为什么 Redis 选择单线程模型</h5><blockquote>
<p><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener">为什么 Redis 选择单线程模型</a></p>
</blockquote>
<p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 <strong>CPU 不是 Redis 服务器的瓶颈</strong>，所以<strong>使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本</strong>，系统的性能瓶颈也主要在网络 I/O 操作上；</p>
<p>而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>
<h5 id="单线程的Redis为什么这么快"><a href="#单线程的Redis为什么这么快" class="headerlink" title="单线程的Redis为什么这么快"></a>单线程的Redis为什么这么快</h5><ol>
<li><p>完全基于内存</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换。</p>
</li>
<li><p>高效的数据结构</p>
</li>
<li><p>使用I/O多路复用模型，非阻塞IO</p>
<p>I/O多路复用，多路只多个连接，复用指的是复用同一个线程，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求。</p>
</li>
</ol>
<h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><h5 id="Redis是如何判断数据是否过期？"><a href="#Redis是如何判断数据是否过期？" class="headerlink" title="Redis是如何判断数据是否过期？"></a>Redis是如何判断数据是否过期？</h5><p>Redis 通过一个叫做<strong>过期字典</strong>（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<h5 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h5><p>过期策略通常有以下三种：</p>
<ul>
<li><p>定时过期</p>
<p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
</li>
<li><p>惰性过期</p>
<p>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
</li>
<li><p>定期过期</p>
<p>每隔一定的时间，会扫描expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<p>Redis 每隔 100ms 就随机选择一些设置了过期时间的Key，检查它们是否过期，如果过期的话就删除它们。</p>
<p>每秒 10 次：</p>
<ol>
<li>随机测试 20 个带有过期时间的key</li>
<li>删除已过期的key</li>
<li>如果超过 25% 的key已过期，从步骤 1 重新开始</li>
</ol>
<h4 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h4><p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><p><strong>no-eviction</strong>（默认）</p>
<p>禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</p>
</li>
<li><p><strong>volatile-lru（least recently used）</strong></p>
<p>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</p>
<p>Redis使用的是近似LRU算法。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</p>
</li>
<li><p><strong>volatile-ttl</strong></p>
<p>从已设置过期时间的数据集中挑选将要过期的数据淘汰</p>
</li>
<li><p><strong>volatile-random</strong></p>
<p>从已设置过期时间的数据集中任意选择数据淘汰</p>
</li>
<li><p><strong>allkeys-lru（least recently used）</strong></p>
<p>在键空间中，移除最近最少使用的 key（这个是<span style="color: red">最常用</span>的）</p>
</li>
<li><p><strong>allkeys-random</strong></p>
<p>从数据集中任意选择数据淘汰</p>
</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><p><strong>volatile-lfu（least frequently used）</strong></p>
<p>从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</p>
</li>
<li><p><strong>allkeys-lfu（least frequently used）</strong></p>
<p>在键空间中，移除最不经常使用的 key</p>
</li>
</ol>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>Redis 有两种持久化：RDB（快照）和 AOF（追加文件）</p>
<p>注：4.0之后增加了混合方式，结合了 RDB 和 AOF 的优点。</p>
<p>区别：</p>
<ul>
<li>RDB 是将内存中数据某一时刻的快照写入二进制文件中。</li>
<li>AOF 是将每条导致数据变动的指令追加到 aof 文件中。</li>
</ul>
<p>优缺点：</p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>文件大小</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>重启时间</td>
<td>短</td>
<td>长</td>
</tr>
<tr>
<td>数据丢失</td>
<td>多</td>
<td>少</td>
</tr>
</tbody></table>
<h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><p>Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p>
<p>使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。</p>
<p>Redis 是<strong>不支持 roll back</strong> 的，因而不满足原子性的（而且不满足持久性）。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h5><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ol>
<li><p>参数校验</p>
<p>一些不合法的参数请求直接抛出异常信息返回给客户端。</p>
</li>
<li><p>缓存无效 key</p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个固定值(e.g. null)到 Redis 中去并设置过期时间</p>
</li>
<li><p>布隆过滤器</p>
<p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会继续走下面的流程。</p>
<p>计算元素值的哈希值。根据哈希值，在位数组中把对应下标的值置为 1。</p>
</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h5><p>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
<h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li><p>合理设置缓存过期时间(e.g. 随机)</p>
</li>
<li><p>分布式缓存</p>
<p>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</p>
</li>
<li><p>缓存预热</p>
<p>避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</p>
</li>
</ol>
<h4 id="Redis和数据库双写一致性问题"><a href="#Redis和数据库双写一致性问题" class="headerlink" title="Redis和数据库双写一致性问题"></a>Redis和数据库双写一致性问题</h4><p>采用 <strong>Cache Aside Pattern</strong>：</p>
<ol>
<li>读的时候先读缓存，如果缓存不存在的话就读数据库，取出数据库后更新缓存。</li>
<li>写的时候，先更新数据库，再删除缓存。</li>
</ol>
<h5 id="为什么是删除缓存，而不是更新缓存？"><a href="#为什么是删除缓存，而不是更新缓存？" class="headerlink" title="为什么是删除缓存，而不是更新缓存？"></a>为什么是删除缓存，而不是更新缓存？</h5><ol>
<li>有两个更新请求A、B，A先与B更新的数据库，但由于网络震荡，B先与A更新了缓存，此时缓存的数据就是脏数据。</li>
<li>为了考虑性能。更新了的数据并不一定会立即有新的访问，放在缓存里占内存，还不如直接删除，有新的访问时再放进去就好了，是一种懒加载的思想。</li>
</ol>
<h5 id="如果删除失败了，导致数据不一致怎么办？"><a href="#如果删除失败了，导致数据不一致怎么办？" class="headerlink" title="如果删除失败了，导致数据不一致怎么办？"></a>如果删除失败了，导致数据不一致怎么办？</h5><p>采用延时双删策略，先删除缓存，再更新数据库，更新成功了就延时异步删除缓存。</p>
<h4 id="用-Redis-实现点赞功能"><a href="#用-Redis-实现点赞功能" class="headerlink" title="用 Redis 实现点赞功能"></a>用 Redis 实现点赞功能</h4><h4 id="Redis-做消息队列"><a href="#Redis-做消息队列" class="headerlink" title="Redis 做消息队列"></a>Redis 做消息队列</h4><ul>
<li>基于List的 LPUSH+BRPOP 的实现</li>
<li>PUB/SUB，订阅/发布模式</li>
<li>基于Sorted-Set的实现</li>
<li>基于Stream类型的实现</li>
</ul>
<h4 id="Redis-做分布式锁"><a href="#Redis-做分布式锁" class="headerlink" title="Redis 做分布式锁"></a>Redis 做分布式锁</h4><h5 id="利用-Redis-的-SETNX-和-EXPIRE-命令"><a href="#利用-Redis-的-SETNX-和-EXPIRE-命令" class="headerlink" title="利用 Redis 的 SETNX 和 EXPIRE 命令"></a>利用 Redis 的 SETNX 和 EXPIRE 命令</h5><ul>
<li><p>加锁命令：<code>SETNX key value</code></p>
<p>当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。</p>
</li>
<li><p>解锁命令：<code>DEL key</code></p>
<p>通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。</p>
</li>
<li><p>锁超时：<code>EXPIRE key timeout</code></p>
<p>设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。</p>
</li>
</ul>
<h6 id="SETNX-和-EXPIRE-非原子性"><a href="#SETNX-和-EXPIRE-非原子性" class="headerlink" title="SETNX 和 EXPIRE 非原子性"></a>SETNX 和 EXPIRE 非原子性</h6><p>如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。</p>
<ol>
<li><p>可以通过使用 lua 脚本保证原子性。</p>
</li>
<li><p>Redis在 2.6.12 版本开始，为 SET 命令增加一系列选项：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET key value[EX seconds][PX milliseconds][NX|XX]</span><br></pre></td></tr></table></figure>

<ul>
<li>EX seconds: 设定过期时间，单位为秒</li>
<li>PX milliseconds: 设定过期时间，单位为毫秒</li>
<li>NX: 仅当key不存在时设置值</li>
<li>XX: 仅当key存在时设置值</li>
</ul>
<p>set命令的nx选项，就等同于setnx命令</p>
<h6 id="锁误解除"><a href="#锁误解除" class="headerlink" title="锁误解除"></a>锁误解除</h6><p>如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。</p>
<p>通过在 value 中设置当前线程的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。</p>
<h6 id="超时解锁导致并发"><a href="#超时解锁导致并发" class="headerlink" title="超时解锁导致并发"></a>超时解锁导致并发</h6><p>如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。</p>
<p>A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：</p>
<ul>
<li>将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。</li>
<li>为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。</li>
</ul>
<h6 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h6><p>可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。</p>
<p>在本地记录重入次数，如 Java 中使用 ThreadLocal 进行重入次数统计。</p>
<p>本地记录重入次数虽然高效，但如果考虑到过期时间和本地、Redis 一致性的问题，就会增加代码的复杂性。另一种方式是 Redis hash 数据结构来实现分布式锁，既存锁的标识也对重入次数进行计数。</p>
<h6 id="无法等待锁释放"><a href="#无法等待锁释放" class="headerlink" title="无法等待锁释放"></a>无法等待锁释放</h6><p>上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。</p>
<ul>
<li>可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。</li>
<li>另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。</li>
</ul>
<h6 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h6><p>为了保证 Redis 的可用性，一般采用主从方式部署。主从数据同步有异步和同步两种方式，Redis 将指令记录在本地内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一致的状态，一边向主节点反馈同步情况。</p>
<p>在包含主从模式的集群部署方式中，当主节点挂掉时，从节点会取而代之，但客户端无明显感知。当客户端 A 成功加锁，指令还未同步，此时主节点挂掉，从节点提升为主节点，新的主节点没有锁的数据，当客户端 B 加锁时就会成功。</p>
<h6 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h6><p>集群脑裂指因为网络问题，导致 Redis master 节点跟 slave 节点和 sentinel 集群处于不同的网络分区，因为 sentinel 集群无法感知到 master 的存在，所以将 slave 节点提升为 master 节点，此时存在两个不同的 master 节点。Redis Cluster 集群部署方式同理。</p>
<p>当不同的客户端连接不同的 master 节点时，两个客户端可以同时拥有同一把锁。</p>
<h5 id="Redisson-实现简单分布式锁"><a href="#Redisson-实现简单分布式锁" class="headerlink" title="Redisson 实现简单分布式锁"></a>Redisson 实现简单分布式锁</h5><p>对于Java用户而言，我们经常使用Jedis，Jedis是Redis的Java客户端，除了Jedis之外，Redisson也是Java的客户端，Jedis是阻塞式I/O，而Redisson底层使用Netty可以实现非阻塞I/O，该客户端是封装了锁的，继承了J.U.C的Lock接口，所以我们可以像使用ReentrantLock一样使用Redisson。</p>
<h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>使用 CacheBuilder 就可以构建一个缓存对象，CacheBuilder使用build链式构建。</p>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)</strong>，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了。</p>
<h4 id="Exchange-Types-交换器类型"><a href="#Exchange-Types-交换器类型" class="headerlink" title="Exchange Types(交换器类型)"></a>Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种。</p>
<h5 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h5><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>
<h5 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>
<h5 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h5><p>topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多个单词(可以是零个)。</li>
</ul>
<h5 id="headers-不推荐"><a href="#headers-不推荐" class="headerlink" title="headers(不推荐)"></a>headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h4><ol>
<li>消费者端通过 confirm 机制，保证消息投递不丢失</li>
<li>rabbitMq端通过持久化保证消息不丢失</li>
<li>消费者端通过手动ack机制保障消息正常消费</li>
</ol>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><em>Elasticsearch</em> 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合。例如 GitHub 使用 Elasticsearch 对1300亿行代码进行查询。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>日志实时分析</p>
<p>日志分析是 ES 应用最广泛的领域，支持全栈的日志分析</p>
</li>
<li><p>搜索服务</p>
<p>文档的全文检索、电商平台商品的搜索。</p>
</li>
<li><p>数据分析</p>
</li>
</ul>
<h3 id="为什么-Elasticsearch-那么快？"><a href="#为什么-Elasticsearch-那么快？" class="headerlink" title="为什么 Elasticsearch 那么快？"></a>为什么 Elasticsearch 那么快？</h3><p>Elasticsearch 基于 Apache Lucene，Lucene 实现快速搜索的核心就是倒排索引。</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>将文档中的单词作为索引，将文档ID作为记录的索引结构称为倒排索引。</p>
<h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><ul>
<li><p>Term：文档拆分后的单词与文档ID的映射。</p>
</li>
<li><p>Term Dictionary：所有单词组成的二叉排序树，根据 Term Dictionary 可以快速定位到 Term。</p>
</li>
<li><p>Term Index：单词前缀的二叉排序树，根据 Term Index 可以快速定位到 Term Dictionary。</p>
</li>
</ul>
<p>Term Index 以FST（finite state transducers）的形式保存在内存中，FST特点是非常节省内存。</p>
<p>Term dictionary在磁盘上是以分快的方式保存的，一个block内部利用公共前缀压缩，比如都是Ab开头的单词就可以把Ab省去。这样term dictionary可以更节约磁盘空间。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p>在 docker 中执行 bash 命令</p>
<p><code>docker exec -it set-mobile_qa /bin/bash</code></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>要理解前后端分离，首先要理解什么是前端，什么是后端。</p>
<p>在系统架构中，前端是负责系统的界面样式、视觉呈现以及和用户交互的部分，后端是负责数据处理的部分。负责这两部分开发的人就是前后端工程师。</p>
<p>前后端未分离的项目中，HTML页面和数据处理包含在同一个项目里，部署在单个服务器中。客户端(浏览器)发送请求到服务器，服务器查询数据库，再对数据进行相应处理，最后再生成相应的HTML文件，将生成的HTML文件返回给客户端。</p>
<p>这个阶段前端工程师负责编写网页模版，之后交给后端工程师，后端工程师则将数据嵌入到网页模版中。</p>
<p>前后端半分离的项目是HTML网页</p>
<p>将网页模版和数据填充逻辑分离成前端项目，后端项目只负责数据处理。前后端项目分别独立开发和部署，通过HTTP协议传递数据。此时客户端访问前端项目获取HTML、CSS、JS等文件，再通过js向后端发送ajax请求获取数据，</p>
<p>一个项目包括视图展示和数据处理两大部分，视图展示就是前端，数据处理就是后端。</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><h3 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h3><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h4><p>服务雪崩就是一个服务的不可用导致了整个调用链上的服务集体雪崩。</p>
<h4 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>所谓 <strong>熔断</strong> 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 <strong>断路器</strong> 直接将此请求链路断开。</p>
<h4 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h4><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><h5 id="RPC-解决了什么问题？"><a href="#RPC-解决了什么问题？" class="headerlink" title="RPC 解决了什么问题？"></a>RPC 解决了什么问题？</h5><p><strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<h5 id="既有-HTTP-为啥用-RPC-进行服务调用"><a href="#既有-HTTP-为啥用-RPC-进行服务调用" class="headerlink" title="既有 HTTP ,为啥用 RPC 进行服务调用?"></a>既有 HTTP ,为啥用 RPC 进行服务调用?</h5><p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>但是，HTTP 是一种协议，RPC框架可以使用 HTTP 协议作为传输协议或者直接使用TCP 作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h5 id="REST和RPC"><a href="#REST和RPC" class="headerlink" title="REST和RPC"></a>REST和RPC</h5><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="分布式、集群、微服务、SOA-之间的区别"><a href="#分布式、集群、微服务、SOA-之间的区别" class="headerlink" title="分布式、集群、微服务、SOA 之间的区别"></a>分布式、集群、微服务、SOA 之间的区别</h4><ul>
<li>分布式<ul>
<li>不同模块部署在不同服务器上，</li>
</ul>
</li>
<li>集群<ul>
<li>多台服务器部署相模块构成集群，通过负载均衡对外提供服务。</li>
</ul>
</li>
<li>SOA<ul>
<li>面向服务的架构（Service Oriented Architecture），把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。</li>
</ul>
</li>
<li>微服务<ul>
<li>微服务是SOA架构演进的结果。<strong>是一种比较现代化的细粒度的SOA实现方式。</strong></li>
</ul>
</li>
</ul>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><h4 id="两段式（2PC）"><a href="#两段式（2PC）" class="headerlink" title="两段式（2PC）"></a>两段式（2PC）</h4><h4 id="三段式（3PC）"><a href="#三段式（3PC）" class="headerlink" title="三段式（3PC）"></a>三段式（3PC）</h4><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h4><h2 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h2><h3 id="工作中遇到的最难的问题是什么？"><a href="#工作中遇到的最难的问题是什么？" class="headerlink" title="工作中遇到的最难的问题是什么？"></a>工作中遇到的最难的问题是什么？</h3><p>新开启的项目为了进度，需要在老项目的基础上移植一些代码，重组拼装。这个时候在时间与质量之间需要做出权衡。重构 or 搬运。是一个很难选择的问题。先前项目都是外包人员开发的。项目质量差，依赖多，继承深。让你无从下手，感觉很绝望。很大一部分的代码公司还申请了专利。这个时候，不是说你秀 runtime 技巧或者流畅、性能优化就能完美完成的。你要站在软件工程的角度思考问题。代码不可用的问题需要在我这里打住。业务功能分离专注。适当挑战新的技术点，比如使用 http2，coap 等等一些新的通信协议带来的未知挑战。使用 swift 或者 oc 是个很难选择的问题。现在葱一开始，坚持写测试用例。面向对象编码。哦，还要提高编码速度，因为与此同时，老板又在催进度，我还是得维持我是一个靠谱的人，坚持我输出的代码，必属精品的追求有莫有？</p>
<h3 id="工作中遇到的最有成就感的是什么？"><a href="#工作中遇到的最有成就感的是什么？" class="headerlink" title="工作中遇到的最有成就感的是什么？"></a>工作中遇到的最有成就感的是什么？</h3><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h3><h3 id="公司规模"><a href="#公司规模" class="headerlink" title="公司规模"></a>公司规模</h3><h2 id="什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h2><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p>
<p>第一步：安装 Java</p>
<p>第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</p>
<p>第三部：部署应用程序 war 包</p>
<p>如果我们想简化这些步骤，应该如何做呢？</p>
<p>让我们来思考如何使服务器成为应用程序的一部分？</p>
<p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p>
<p>是不是很爽？</p>
<p>这个想法是嵌入式服务器的起源。</p>
<p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p>
<p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。</p>
<p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p>
<h2 id="3、微服务同时调用多个接口，怎么支持事务的啊？"><a href="#3、微服务同时调用多个接口，怎么支持事务的啊？" class="headerlink" title="3、微服务同时调用多个接口，怎么支持事务的啊？"></a>3、微服务同时调用多个接口，怎么支持事务的啊？</h2><p>支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决，但是我一般不建议这样使用，因为使用分布式事务会增加请求的响应时间，影响系统的TPS。一般在实际工作中，会利用消息的补偿机制来处理分布式的事务。</p>
<h2 id="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"><a href="#4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。" class="headerlink" title="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"></a>4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。</h2><p>cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。</p>
<p>token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。</p>
<p>我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。</p>
<h2 id="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"><a href="#5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？" class="headerlink" title="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"></a>5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？</h2><p>在传统的SOA治理中，使用rpc的居多；Spring Cloud默认使用restful进行服务之间的通讯。rpc通讯效率会比restful要高一些，但是对于大多数公司来讲，这点效率影响甚微。我建议使用restful这种方式，易于在不同语言实现的服务之间通讯。</p>
<h2 id="6、怎么设计无状态服务？"><a href="#6、怎么设计无状态服务？" class="headerlink" title="6、怎么设计无状态服务？"></a>6、怎么设计无状态服务？</h2><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p>
<p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p>
<p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p>
<h2 id="7、Spring-Cache-三种常用的缓存注解和意义？"><a href="#7、Spring-Cache-三种常用的缓存注解和意义？" class="headerlink" title="7、Spring Cache 三种常用的缓存注解和意义？"></a>7、Spring Cache 三种常用的缓存注解和意义？</h2><p>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</p>
<p>@CachePut，使用 @CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p>
<p>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</p>
<h2 id="8、Spring-Boot-如何设置支持跨域请求？"><a href="#8、Spring-Boot-如何设置支持跨域请求？" class="headerlink" title="8、Spring Boot 如何设置支持跨域请求？"></a>8、Spring Boot 如何设置支持跨域请求？</h2><p>现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。</p>
<p>一般前端的解决方案有：</p>
<ul>
<li>① 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。</li>
<li>② 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。</li>
</ul>
<p>后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。</p>
<p>前端使用了 CORS 协议，就需要后端设置支持非同源的请求，Spring Boot 设置支持非同源的请求有两种方式。</p>
<p>第一，配置 CorsFilter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line">          config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">          config.setAllowCredentials(true);</span><br><span class="line">          config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">          config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">          config.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要配置上述的一段代码。第二种方式稍微简单一些。</p>
<p>第二，在启动类上添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Application extends WebMvcConfigurerAdapter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;  </span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  </span><br><span class="line">                .allowCredentials(true)  </span><br><span class="line">                .allowedHeaders(&quot;*&quot;)  </span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  </span><br><span class="line">                .allowedMethods(&quot;*&quot;);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？"><a href="#9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？" class="headerlink" title="9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？"></a>9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？</h2><p>JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，Hibernate 是 JPA 的一个实现集。</p>
<p>JPA 是根据实体类的注解来创建对应的表和字段，如果需要动态创建表或者字段，需要动态构建对应的实体类，再重新调用Jpa刷新整个Entity。动态SQL，mybatis支持的最好，jpa也可以支持，但是没有Mybatis那么灵活。</p>
<h2 id="10、Spring-、Spring-Boot-和-Spring-Cloud-的关系"><a href="#10、Spring-、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="10、Spring 、Spring Boot 和 Spring Cloud 的关系?"></a>10、Spring 、Spring Boot 和 Spring Cloud 的关系?</h2><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p>
<p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。</p>
<p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p>
<p>Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p>
<p>用一组不太合理的包含关系来表达它们之间的关系。</p>
<p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="高并发场景"><a href="#高并发场景" class="headerlink" title="高并发场景"></a>高并发场景</h3>]]></content>
  </entry>
  <entry>
    <title>Preparing for job interviews</title>
    <url>/2019/03/06/Preparing-for-job-interviews/</url>
    <content><![CDATA[<img data-src="https://www.insperity.com/wp-content/uploads/stay_interview_questions_640x302.jpg" width="100%"/>

<a id="more"></a>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="equals-方法和-hashcode-方法"><a href="#equals-方法和-hashcode-方法" class="headerlink" title="equals 方法和 hashcode 方法"></a>equals 方法和 hashcode 方法</h4><p>Object 中的 hashcode 是根据对象的内存地址生成的，equals 使用 ‘==’ 直接比较对象的地址。</p>
<p>改写 equals 时总是要改写 hashcode，使得 equals 结果为 true 时，hashcode 结果也为 true，hashcode 结果为 false，equals 结果也为 false（即 hashcode 是 equals 的必要不充分条件）。因为在集合类（HashMap，HashSet 等）中的比较操作为了提高效率，一般都是先比较 hashcode 值，再比较 equals。可以利用 IDEA 快速生成 equals 和 hashcode 方法。</p>
<h3 id="对象克隆（复制）"><a href="#对象克隆（复制）" class="headerlink" title="对象克隆（复制）"></a>对象克隆（复制）</h3><blockquote>
<p><a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></p>
</blockquote>
<p>假如说你想复制一个简单变量。很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> apples = <span class="number">5</span>;  </span><br><span class="line"><span class="keyword">int</span> pears = apples;</span><br></pre></td></tr></table></figure>

<p>不仅仅是int类型，其它七种原始数据类型(boolean,char,byte,short,float,double.long)同样适用于该类情况。但是如果你复制的是一个对象，情况就有些复杂了。</p>
<p>假设说我是一个beginner，我会这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();  </span><br><span class="line">        stu1.setNumber(<span class="number">12345</span>);  </span><br><span class="line">        Student stu2 = stu1;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());  </span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>学生1:12345  </p>
<p>学生2:12345  </p>
</blockquote>
<p>我们试着改变stu2实例的number字段，再打印结果看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stu2.setNumber(<span class="number">54321</span>);  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());  </span><br><span class="line">System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<p>学生1:54321  </p>
<p>学生2:54321  </p>
</blockquote>
<p>这就怪了，为什么改变学生2的学号，学生1的学号也发生了变化呢？原因出在(stu2 = stu1) 这一句。该语句的作用是将stu1的引用赋值给stu2，这样，stu1和stu2指向内存堆中同一个对象。如图：</p>
<p><img data-src="https://images2015.cnblogs.com/blog/690102/201607/690102-20160727114833309-1421006998.png" alt="img"></p>
<p>那么，怎样才能达到复制一个对象呢？是否记得万类之王Object。它有11个方法，有两个protected的方法，其中一个为clone方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Creates and returns a copy of this object. The precise meaning of "copy" may depend on the class of the object.</span></span><br><span class="line"><span class="comment">The general intent is that, for any object x, the expression:</span></span><br><span class="line"><span class="comment">1) x.clone() != x will be true</span></span><br><span class="line"><span class="comment">2) x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">3) x.clone().equals(x) will be true, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>仔细一看，它还是一个native方法，大家都知道native方法是非Java语言实现的代码，供Java程序调用的，因为Java程序是运行在JVM虚拟机上面的，要想访问到比较底层的与操作系统相关的就没办法了，只能由靠近操作系统的语言来实现。</p>
<p>因为每个类直接或间接的父类都是Object，因此它们都含有clone()方法，但是因为该方法是protected，所以都不能在类外进行访问。要想对一个对象进行复制，就需要对clone方法覆盖。</p>
<h4 id="为什么要克隆？"><a href="#为什么要克隆？" class="headerlink" title="为什么要克隆？"></a>为什么要克隆？</h4><p>大家先思考一个问题，为什么需要克隆对象？直接new一个对象不行吗？</p>
<p>答案是：克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠clone方法了。那么我把这个对象的临时属性一个一个的赋值给我新new的对象不也行嘛？可以是可以，但是一来麻烦不说，二来，大家通过上面的源码都发现了clone是一个native方法，就是快啊，在底层实现的。</p>
<p>提个醒，我们常见的Object a=new Object();Object b;b=a;这种形式的代码复制的是引用，即对象在内存中的地址，a和b对象仍然指向了同一个对象。而通过clone方法赋值的对象跟原来的对象时同时独立存在的。</p>
<h4 id="如何实现克隆"><a href="#如何实现克隆" class="headerlink" title="如何实现克隆"></a>如何实现克隆</h4><p>先介绍一下两种不同的克隆方法，<strong>浅克隆(ShallowClone)</strong>和<strong>深克隆(DeepClone)</strong>。</p>
<p>在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</p>
<h4 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h4><p>浅克隆的一般步骤是：</p>
<ol>
<li><strong>被复制的类需要实现Clonenable接口</strong>（不实现的话在调用clone方法会抛出CloneNotSupportedException异常)， 该接口为标记接口(不含任何方法)。</li>
<li><strong>覆盖clone()方法，访问修饰符设为public</strong>。<strong>方法中调用super.clone()方法得到需要的复制对象</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Student stu = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            stu = (Student)<span class="keyword">super</span>.clone();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stu;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();  </span><br><span class="line">        stu1.setNumber(<span class="number">12345</span>);  </span><br><span class="line">        Student stu2 = (Student)stu1.clone();  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());  </span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());  </span><br><span class="line">          </span><br><span class="line">        stu2.setNumber(<span class="number">54321</span>);  </span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());  </span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<p>学生1:12345  </p>
<p>学生2:12345  </p>
<p>学生1:12345  </p>
<p>学生2:54321</p>
</blockquote>
<p>如果你还不相信这两个对象不是同一个对象，那么你可以看看这一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stu1 == stu2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h4><p>在学生类里再加一个Address类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String add;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Address addr;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Student stu = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            stu = (Student)<span class="keyword">super</span>.clone();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stu;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        Address addr = <span class="keyword">new</span> Address();  </span><br><span class="line">        addr.setAdd(<span class="string">"杭州市"</span>);  </span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();  </span><br><span class="line">        stu1.setNumber(<span class="number">123</span>);  </span><br><span class="line">        stu1.setAddr(addr);  </span><br><span class="line">          </span><br><span class="line">        Student stu2 = (Student)stu1.clone();  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber() + <span class="string">",地址:"</span> + stu1.getAddr().getAdd());  </span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber() + <span class="string">",地址:"</span> + stu2.getAddr().getAdd());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<p>学生1:123,地址:杭州市  </p>
<p>学生2:123,地址:杭州市  </p>
</blockquote>
<p>在main方法中试着改变addr实例的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addr.setAdd(<span class="string">"西湖区"</span>);  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber() + <span class="string">",地址:"</span> + stu1.getAddr().getAdd());  </span><br><span class="line">System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber() + <span class="string">",地址:"</span> + stu2.getAddr().getAdd());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：<br>学生1:123,地址:杭州市<br>学生2:123,地址:杭州市<br>学生1:123,地址:西湖区<br>学生2:123,地址:西湖区</p>
</blockquote>
<p>这就奇怪了，怎么两个学生的地址都改变了？原因是浅复制只是复制了addr变量的引用，并没有真正的开辟另一块空间，将值复制后再将引用返回给新对象。所以，为了达到真正的复制对象，而不是纯粹引用复制。我们需要将Address类可复制化，并且修改clone方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String add;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Address addr = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            addr = (Address)<span class="keyword">super</span>.clone();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> addr;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Address addr;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Student stu = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            stu = (Student)<span class="keyword">super</span>.clone();   <span class="comment">//浅复制  </span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        stu.addr = (Address)addr.clone();   <span class="comment">//深度复制  </span></span><br><span class="line">        <span class="keyword">return</span> stu;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        Address addr = <span class="keyword">new</span> Address();  </span><br><span class="line">        addr.setAdd(<span class="string">"杭州市"</span>);  </span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();  </span><br><span class="line">        stu1.setNumber(<span class="number">123</span>);  </span><br><span class="line">        stu1.setAddr(addr);  </span><br><span class="line">          </span><br><span class="line">        Student stu2 = (Student)stu1.clone();  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber() + <span class="string">",地址:"</span> + stu1.getAddr().getAdd());  </span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber() + <span class="string">",地址:"</span> + stu2.getAddr().getAdd());  </span><br><span class="line">          </span><br><span class="line">        addr.setAdd(<span class="string">"西湖区"</span>);  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber() + <span class="string">",地址:"</span> + stu1.getAddr().getAdd());  </span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber() + <span class="string">",地址:"</span> + stu2.getAddr().getAdd());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：<br>学生1:123,地址:杭州市<br>学生2:123,地址:杭州市<br>学生1:123,地址:西湖区<br>学生2:123,地址:杭州市</p>
</blockquote>
<p>这样结果就符合我们的想法了。</p>
<p>最后我们可以看看API里其中一个实现了clone方法的类：java.util.Date，该类其实也属于深度复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Return a copy of this object. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Date d = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        d = (Date)<span class="keyword">super</span>.clone();  </span><br><span class="line">        <span class="keyword">if</span> (cdate != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            d.cdate = (BaseCalendar.Date) cdate.clone();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;&#125; <span class="comment">// Won't happen  </span></span><br><span class="line">    <span class="keyword">return</span> d;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str1==str2); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//可以看出str1和str2是指向同一个对象的。</span></span><br><span class="line"></span><br><span class="line">String str1 =<span class="keyword">new</span> String (<span class="string">"abc"</span>);</span><br><span class="line">String str2 =<span class="keyword">new</span> String (<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//用new的方式是生成不同的对象。每一次生成一个新的对象。</span></span><br></pre></td></tr></table></figure>

<h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h4><h4 id="replace、replaceAll-方法"><a href="#replace、replaceAll-方法" class="headerlink" title="replace、replaceAll 方法"></a>replace、replaceAll 方法</h4><h4 id="String-StringBuffer与StringBuilder的区别"><a href="#String-StringBuffer与StringBuilder的区别" class="headerlink" title="String,StringBuffer与StringBuilder的区别"></a>String,StringBuffer与StringBuilder的区别</h4><p><strong>String</strong> 字符串常量StringBuffer</p>
<p><strong>字符串变量</strong>（线程安全）</p>
<p><strong>StringBuilder 字符串变量（非线程安全）</strong></p>
<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String S1 = “This is only a” + “ simple” + “ test”;</span><br><span class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuffer(“This is only a”).append(“ simple”).append(“ test”);</span><br></pre></td></tr></table></figure>

<p>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 <code>String S1 = “This is only a” + “ simple” + “test”;</code> 其实就是：<code>String S1 = “This is only a simple test”;</code> 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String S2 = “This is only a”;</span><br><span class="line">String S3 = “ simple”;</span><br><span class="line">String S4 = “ test”;</span><br><span class="line">String S1 = S2 +S3 + S4;</span><br></pre></td></tr></table></figure>

<p>这时候 JVM 会规规矩矩的按照原来的方式去做。在大部分情况下 StringBuffer &gt; String</p>
<p><strong>StringBuffer</strong><br>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>
<p>在大部分情况下 StringBuilder &gt; StringBuffer</p>
<p><strong>java.lang.StringBuilde</strong></p>
<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li>获取Class对象引用的方式有3种，Object类的getClass方法，Class类的静态方法forName以及字面常量的方式”.class”</li>
<li>实例类的getClass方法和Class类的静态方法forName都会触发类的初始化阶段，而字面常量获取Class对象的方式则不会触发初始化。</li>
<li>向Class引用添加泛型约束仅仅是为了提供编译期类型的检查从而避免将错误延续到运行时期。</li>
<li>在Java中，所有类型转换都是在运行时进行正确性检查的</li>
<li>一个类在 JVM 中只会有一个 Class 实例</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>基于哈希表这种数据结构实现的。哈希冲突（哈希碰撞）的解决方案有多种：开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，HashMap采用了链地址法，也就是<strong>数组+链表</strong>的方式。</p>
<p>JDK 1.8对HashMap进行了比较大的优化，底层实现由之前的“数组+链表”改为<strong>“数组+链表+红黑树”</strong>，当链表节点较少时仍然是以链表存在，当链表节点较多时（大于8）会转为红黑树。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote>
<p><a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></p>
<p><a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">Java集合：HashMap详解（JDK 1.8）</a></p>
</blockquote>
<ul>
<li><p>HashMap的主干是一个Entry（1.8是Node，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode）数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
</li>
<li><p>HashMap有4个构造器，<strong>在常规构造器中，没有为数组table分配内存空间（入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong>。</p>
</li>
<li><p>JDK 1.8 中 key 的 hash 值取的是<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，就是把高16bit和低16bit异或了一下。因为当数组长度较小的时候，hash值参与运算只是低位的值，发生碰撞的可能性比较大。一般情况下，key的分布符合“局部性原理”，低比特位相同的概率大于高低位异或后仍然相同的概率，从而降低了碰撞的概率。<a href="http://www.importnew.com/27043.html" target="_blank" rel="noopener">【1】</a></p>
</li>
<li><p>计算具体数组位置，使用 key 的 hash 值对数组长度进行取模就可以了。<code>hash &amp; (length-1);</code>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。如果key为null的话，hash值为0。</p>
<p><strong>当 b = 2^n 时，a % b = a &amp; (b - 1)</strong> 例如 a = 18, b = 16 时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  0  0  1  0</span><br><span class="line">  &amp;   0  1  1  1  1</span><br><span class="line">  __________________</span><br><span class="line">      0  0  0  1  0    &#x3D; 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分到新数组中 newTable[0] 和 newTable[16] 这两个位置。</p>
<p>通过<code>Integer.highestOneBit((number - 1) &lt;&lt; 1)</code>可以确保capacity为大于或等于 number 的最接近number 的二次幂。Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值。</p>
<p>Java7 是先扩容后插入新值的，Java8 先插值再扩容。</p>
</li>
<li><p>HashMap的容量一定保持2的次幂的原因</p>
<ol>
<li><p>减少扩容后数据位置的重新hash</p>
<p>在移动元素的时候，不需要重新定位，只需要看原来的hash值新增的那个bit是1还是0就好了，是0的话位置没变，是1的话位置变成“原位置+oldCap”。<a href="http://www.importnew.com/27043.html" target="_blank" rel="noopener">【2】</a></p>
</li>
<li><p>使用位运算代替取模运算，即保证了散列的均匀，同时也提升了效率</p>
</li>
</ol>
</li>
<li><p>相对于 put 过程，get 过程是非常简单的。</p>
<ol>
<li>根据 key 计算 hash 值。</li>
<li>找到相应的数组下标：hash &amp; (length – 1)。</li>
<li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li>
</ol>
</li>
<li><p>判断元素相等的设计比较经典，利用了bool表达式的短路特性：先比较hash值；如果hash值相等，就通过==比较；如果==不等，再通过equals方法比较。hash是提前计算好的；如果没有重载运算符（通常也不建议这样做），==一般直接比较引用值；equals方法最有可能耗费性能，如String的equals方法需要O(n)的时间，n是字符串长度。一定要记住这里的判断顺序，很能考察对碰撞处理源码的理解。</p>
</li>
<li><p>put 流程：</p>
<p><img data-src="https://img-blog.csdn.net/20180108094243335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29nYTYxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
</ul>
<ol>
<li><p>HashMap 的 key 为什么一般用字符串比较多，能用其他对象，或者自定义的对象吗？为什么？</p>
<p> 在使用 String 类型的对象做 key 时我们可以只根据传入的字符串内容就能获得对应存在 map 中的 value 值。</p>
<p> 如果你想把自定义的对象作为 key，只需要重写 hashCode() 方法与 equals() 方法即可。</p>
</li>
<li><p>HashMap和Hashtable的区别</p>
<blockquote>
<p><a href="https://blog.csdn.net/yu849893679/article/details/81530298" target="_blank" rel="noopener">HashMap和HashTable的理解与区别</a></p>
</blockquote>
<ol>
<li><p>父类不同</p>
<p>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary（已被废弃，详情看源代码）。不过它们都同时实现了map、Cloneable、Serializable这三个接口。<br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。elments() 方法继承自Hashtable的父类Dictionnary，用于返回此Hashtable中value的枚举。contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。HashMap去掉了contains方法，改成containsValue和containsKey了。</p>
</li>
<li><p>null值问题</p>
<p>Hashtable既不支持Null key也不支持Null value。Hashtable的put()方法的注释中有说明 。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p>
</li>
<li><p>线程安全性</p>
<p>Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步</p>
<p>HashMap不是线程安全的，可以通过 <code>Map map = Collections.synchronizedMap(new HashMap())</code>来达到同步的效果。</p>
<p>虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p>
</li>
<li><p>遍历方式不同</p>
<p>Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p>
<p>HashMap的Iterator是fail-fast迭代器。当有其它线程改变了HashMap的结构（增加，删除），将会抛出ConcurrentModificationException。不过，通过Iterator的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。</p>
<p>JDK8之前的版本中，Hashtable是没有fast-fail机制的。在JDK8及以后的版本中 ，Hashtable也是使用fast-fail的。（此处可以去看一下1.5和1.8JDK源码的对比）</p>
</li>
<li><p>初始容量不同</p>
<p>Hashtable的初始长度是11，之后每次扩充容量变为之前的2n+1（n为上一次的长度），而HashMap的初始长度为16，之后每次扩充变为原来的两倍。</p>
<p>创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。</p>
</li>
<li><p>计算哈希值的方法不同</p>
<p>Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。 然而除法运算是非常耗费时间的。效率很低</p>
<p>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p>
</li>
</ol>
</li>
<li><p>ConcurrentHashMap和Hashtable的区别</p>
<p> ConcurrentHashMap和CopyOnWriteArrayList保留了线程安全的同时，也提供了更高的并发性。</p>
<p> 当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。而ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p>
<p> 简单理解，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p> <img data-src="https://javadoop.com/blogimages/map/3.png" alt=""></p>
<p> <img data-src="https://javadoop.com/blogimages/map/4.png" alt=""></p>
</li>
</ol>
<ul>
<li>Hashtable 在 Java 诞生之初时就有了，HashMap 是 JDk1.2 之后有的，而在 JDK1.5 才有ConcurrentHashMap</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的</li>
</ul>
<h4 id="HashSet和HashMap的区别"><a href="#HashSet和HashMap的区别" class="headerlink" title="HashSet和HashMap的区别"></a>HashSet和HashMap的区别</h4><table>
<thead>
<tr>
<th><em>HashMap</em></th>
<th><em>HashSet</em></th>
</tr>
</thead>
<tbody><tr>
<td>HashMap实现了Map接口</td>
<td>HashSet实现了Set接口</td>
</tr>
<tr>
<td>HashMap储存键值对</td>
<td>HashSet仅仅存储对象</td>
</tr>
<tr>
<td>使用put()方法将元素放入map中</td>
<td>使用add()方法将元素放入set中</td>
</tr>
<tr>
<td>HashMap中使用键对象来计算hashcode值</td>
<td>HashSet使用成员对象来计算hashcode值</td>
</tr>
<tr>
<td>HashMap比较快，因为是使用唯一的键来获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody></table>
<h3 id="int-和-Integer-的区别"><a href="#int-和-Integer-的区别" class="headerlink" title="int 和 Integer 的区别"></a>int 和 Integer 的区别</h3><blockquote>
<p><a href="https://www.cnblogs.com/guodongdidi/p/6953217.html" target="_blank" rel="noopener">java面试题之int和Integer的区别</a></p>
</blockquote>
<ul>
<li><p>Integer是int的包装类，int则是java的一种基本数据类型 </p>
</li>
<li><p>Integer变量必须实例化后才能使用，而int变量不需要 </p>
</li>
<li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </p>
</li>
<li><p>Integer 的默认值是 null，int 的默认值是 0</p>
</li>
<li><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i &#x3D; 100;</span><br><span class="line">Integer j &#x3D; 100;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;true</span><br><span class="line">Integer i &#x3D; 128;</span><br><span class="line">Integer j &#x3D; 128;</span><br><span class="line">System.out.print(i &#x3D;&#x3D; j); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>对于第4条的原因：<br><strong>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；这就是自动装箱</strong>，而java API中对Integer类型的valueOf的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</strong>，简要的说就是在Integer类中有一个静态内部类IntegerCache，在IntegerCache类中有一个Integer数组，用以缓存当数值范围为-128~127时的Integer对象。</p>
</li>
<li><p>简单来讲：自动装箱就是<code>Integer.valueOf(int i);</code>自动拆箱就是<code>i.intValue();</code></p>
</li>
<li><p>在java中包装类，比较多的用途是用在于各种数据类型的转化中。</p>
</li>
</ul>
<h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>两个byte类型相加，结果是int，也就是需要使用int接收。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><blockquote>
<p><a href="http://www.ityouknow.com/jvm/2017/09/28/jvm-overview.html" target="_blank" rel="noopener">Jvm 知识点总览</a></p>
</blockquote>
<h3 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h3><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<p>JVM 体系总体分四大块：</p>
<ul>
<li>类的加载机制</li>
<li>jvm内存结构</li>
<li>GC算法 垃圾回收</li>
<li>GC分析 命令调优</li>
</ul>
<p><img data-src="http://www.ityouknow.com/assets/images/2017/jvm/JVM.jpg" alt=""></p>
<h3 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h3><blockquote>
<p><a href="https://blog.csdn.net/ns_code/article/details/17881581#commentBox" target="_blank" rel="noopener">【深入Java虚拟机】之四：类加载机制</a></p>
</blockquote>
<p>java程序的执行流程图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/2/12/1618814efa703be5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>jvm的大致物理结构图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/2/12/161881529f1be508?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h4 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p>加载.class文件的方式：</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>一个java类的完整的生命周期会经历<strong>加载、连接、初始化、使用、和卸载</strong>五个阶段，当然也有在加载或者连接之后没有被初始化就直接被使用的情况。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/2843224-eef72dbf8b663012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633/format/webp" alt=""></p>
<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<p>Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定。</p>
<p>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</p>
<p>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</p>
<p><img data-src="https://img-blog.csdn.net/20170430160610299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
</li>
</ol>
<p>注意：二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。</p>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><p>类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p>
<p>虚拟机提供了3种类加载器：引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）</p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p> 1）在执行非置信代码之前，自动验证数字签名。</p>
<p> 2）动态地创建符合用户特定需要的定制化构建类。</p>
<p> 3）从特定的场所取得java class，例如数据库中和网络中。</p>
<p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。</p>
<p>这几种类加载器的层次关系如下图所示：</p>
<p><img data-src="https://img-blog.csdn.net/20140105211242593" alt=""></p>
<p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这就保证了Object类在程序中的各种类加载器中都是同一个类。</p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p>
<p>不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<ul>
<li>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li>
<li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li>
<li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li>
<li>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li>
</ul>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
</li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：<code>public static int value = 3；</code>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p>
<p><img data-src="https://img-blog.csdn.net/20140105195119234" alt=""></p>
</li>
</ol>
<p>   这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
<ol start="3">
<li><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>假设上面的类变量value被定义为： <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。</p>
</li>
</ol>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</p>
<p>解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p>
<p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。</p>
<ol>
<li><p>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p>
</li>
<li><p>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</p>
<p><img data-src="https://img-blog.csdn.net/20140105220608531" alt=""></p>
<p>从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了super类静态语句块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了父类静态语句块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了子类静态语句块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(Child.m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<blockquote>
<p>执行了super类静态语句块<br>执行了父类静态语句块</p>
<p>33</p>
</blockquote>
<p>如果注释掉Father类中对m定义的那一行，则输出结果如下：</p>
<blockquote>
<p>执行了super类静态语句块</p>
<p>11</p>
</blockquote>
<p>分析：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。<br>注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：</p>
<blockquote>
<p>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m<br>都匹配</p>
<pre><code>System.out.println(Child.m);
                        ^</code></pre></blockquote>
</li>
<li><p>类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p>
</li>
<li><p>接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。</p>
</li>
</ol>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<br><code>&lt;clinit&gt;()</code>方法的执行规则:</p>
<ol>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</li>
<li><code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此，在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是java.lang.Object。</li>
<li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<code>&lt;clinit&gt;()</code>方法。但是接口与类不同的是：执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>
</ol>
<p>下面给出一个简单的例子，以便更清晰地说明如上规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		a = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(Child.b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，会打印出2，也就是说b的值被赋为了2。</p>
<p>分析：首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用<code>&lt;clinit&gt;()</code> 方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的<code>&lt;clinit&gt;()</code>方法，根据规则2，在此之前，要先执行完其父类Father的<code>&lt;clinit&gt;()</code>方法，又根据规则1，在执行<code>&lt;clinit&gt;()</code>方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的<code>&lt;clinit&gt;()</code>方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的<code>&lt;clinit&gt;()</code>方法，这样便会将b的赋值为2.<br>如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的<code>&lt;clinit&gt;()</code>方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于<code>&lt;clinit&gt;()</code>方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。</p>
<h3 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h3><h4 id="JDK1-7的JVM内存结构"><a href="#JDK1-7的JVM内存结构" class="headerlink" title="JDK1.7的JVM内存结构"></a>JDK1.7的JVM内存结构</h4><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3170721/z4rhosbc0j.png?imageView2/2/w/1620" alt="img"></p>
<h4 id="JDK1-8以后的JVM内存结构"><a href="#JDK1-8以后的JVM内存结构" class="headerlink" title="JDK1.8以后的JVM内存结构"></a>JDK1.8以后的JVM内存结构</h4><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3170721/l1cjqueun1.png?imageView2/2/w/1620" alt="img"></p>
<p>以前的方法区(或永久代)，用来存放class，Method等元数据信息，但在JDK1.8已经没有了，取而代之的是MetaSpace(元空间)，元空间不在虚拟机里面，而是直接使用本地内存。</p>
<p>为什么要用元空间代替永久代？</p>
<ol>
<li>类以及方法的信息比较难确定其大小，因此对于永久代的指定比较困难，太小容易导致永久代溢出，太大容易导致老年代溢出。</li>
<li>永久代会给GC带来不需要的复杂度，并且回收效率偏低。</li>
<li>Oracle可能会将HotSpot和Jrockit合二为一。</li>
</ol>
<p>在《<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">Java虚拟机规范（Java SE 8）</a>》中描述了JVM运行时内存区域结构如下：</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2018/06/QQ20180624-150918.png" target="_blank" rel="noopener"><img data-src="http://www.hollischuang.com/wp-content/uploads/2018/06/QQ20180624-150918.png" alt="QQ20180624-150918"></a></p>
<p>注意：</p>
<ol>
<li><p>以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p>
</li>
<li><p>规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p>
</li>
<li><p>不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p>
</li>
<li><p>运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p>
</li>
<li><p>除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p>
</li>
<li><p>堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p>
</li>
</ol>
<p>总结：JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。</p>
<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p>字节码行号指示器，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM (OutOfMemoryError) 情况的区域。</p>
<p>特点</p>
<ul>
<li><p>线程私有，因为多线程并发回来后要恢复到当前线程之前执行的位置，所以每个线程都会独立拥有一个 PC</p>
</li>
<li><p>占用空间极小</p>
</li>
<li><p>执行 Java 方法：具体的内容就是指向下一个指令的偏移</p>
</li>
<li><p>执行 Native 方法：计数值为空（undefined）</p>
</li>
<li><p>不会有 OutOfMemoryError</p>
</li>
</ul>
<h4 id="Java-虚拟机栈（Java-Stack）"><a href="#Java-虚拟机栈（Java-Stack）" class="headerlink" title="Java 虚拟机栈（Java Stack）"></a>Java 虚拟机栈（Java Stack）</h4><p>虚拟机栈也就是我们平常所称的栈内存，描述的是Java方法执行的内存模型。每个方法在执行的同时都会创建一个<strong>栈帧</strong>用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常。</p>
<p>设置虚拟机栈的大小：<code>-Xss</code></p>
<p>例如：-Xss128K</p>
<p>特点：</p>
<ul>
<li>虚拟机栈是线程私有的，它的生命周期与线程相同。</li>
<li>以栈帧为单位，进行入栈和出栈</li>
</ul>
<p>栈帧结构</p>
<p>栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息</p>
<ol>
<li><p>局部变量表（Current Variable Table）</p>
<p>局部变量表存放了编译器可知的各种基本数据类型(<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量表是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p>
</li>
<li><p>操作数栈（Operand Stack）</p>
<p>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p>
</li>
<li><p>动态链接（Dynamic Linking）</p>
<p>指向运行时常量池中栈帧所属方法的引用。用来支持方法调用中的动态连接。</p>
<p>常量池的方法的符号引用，一部分在类加载的时候转化为直接引用，被称为静态解析。而动态连接指的是在每一次运行期间转化为直接引用。</p>
</li>
<li><p>返回地址（Return Address）</p>
<p>正常返回时，PC计数器的值作为返回地址保存。异常返回时，通过异常处理表获得返回地址，栈帧一般不会保存这部分信息。</p>
</li>
</ol>
<h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。线程私有。需要注意的是，由于虚拟机规范对于本地方法栈的具体实现没有做强制要求，所以Sun HotSpot直接把本地方法栈和虚拟机栈合二为一。</p>
<h4 id="Java-堆（Heap）"><a href="#Java-堆（Heap）" class="headerlink" title="Java 堆（Heap）"></a>Java 堆（Heap）</h4><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例及数组，几乎所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机，比如 HotSpot 都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>
<p>如果在堆中没有内存来完成实例分配，并且堆也无法再扩展时，将会抛出<strong>OutOfMemoryError异常</strong>。</p>
<p>特点：</p>
<ul>
<li>线程共享</li>
<li>内存最大的一块</li>
<li>目的：存放<strong>对象实例</strong> 和 数组，但随着 JIT 的发展和逃逸分析技术成熟，栈上分配、标量替换，对象实例开始不一定分配在堆上</li>
</ul>
<p>因为堆是 GC 回收的主要区域，根据 GC 的实现机制，会对堆进行分代：</p>
<p>新生代进行 minor GC，老生代进行 major GC（深度GC）。大部分GC发生在新生代中。</p>
<ul>
<li>新生代（Young Generation）<br> Eden  新生的对象<br> Survivor Space  每次GC后还存活的对象，可再细分为 From Survivor 和 To Survivor</li>
<li>老年代（Old Generation）<br> Tenured，存放生命周期长的对象</li>
</ul>
<p>堆内存分配由 -Xmn 来指定。例如：-Xms20m -Xmx20m</p>
<ul>
<li>-Xms，初始使用，默认物理内存 1/64</li>
<li>-Xmx，最大内存，默认物理内存 1/4</li>
</ul>
<p>虚拟机会根据堆的空闲情况动态调整推大小，空余大于 70%，会减少到 -Xms，空余小于 40%，会增大到 -Xmx</p>
<p>所以服务器如果配置 -Xms = -Xmx，则可以避免堆自动扩展</p>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区与堆一样，是各个线程共享的内存区域。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。用于存储已经被虚拟机加载的类信息（如类名、修饰符、字段和方法等）、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>在Hotspot虚拟机中，这块区域对应<strong>持久代（Permanent Generation）</strong>，一般来说，方法区上执行GC的情况很少，是方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。在方法区上进行GC，条件相当苛刻而且困难。对于其他虚拟机(J9)等，是没有永久代这个概念的。</p>
<p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的 intern() 方法，String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</p>
<p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出<strong>OutOfMemoryError</strong>异常。</p>
<p>特点：</p>
<ul>
<li>线程共享</li>
<li>又称为 Non-Heap，用来和堆进行区分</li>
<li>HotSpot 虚拟机把 GC 分代收集扩展至方法区，所以在 HotSpot 可以称它为永久代（Permanent Generation）</li>
</ul>
<p>存储被虚拟机加载的内容有：</p>
<ul>
<li>类信息</li>
<li>常量</li>
<li>静态变量</li>
<li>即时编译器编译后的代码</li>
</ul>
<p>方法区包含<strong>运行时常量池</strong>，Class 文件的各种字面量和符号引用，在类加载后会存入到运行时常量池中。直接引用也会存储在运行时常量池。除了类加载阶段，运行时也可以动态加入，比如 String 的 intern() 方法</p>
<p>方法区的大小的分配</p>
<ul>
<li>-XX:MaxPermSize 最大值，默认最大值为64MB</li>
<li>-XX:PermSize 最小值，默认最小值为16MB</li>
</ul>
<p>例如：-XX:MaxPermSize=10M -XX:PermSize=10M</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是虚拟机运行时数据区的一部分。jdk1.4中新加入的NIO，引入了一种基于通道和缓冲区的I/O方式，它可以使用native函数直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>
<p>通过 <code>-XX:MaxDirectMemorySize</code> 设置最大值，默认与java堆最大值一样。</p>
<p>例如：<code>-XX:MaxDirectMemorySize=10M -Xmx20M</code></p>
<h3 id="对象分配规则"><a href="#对象分配规则" class="headerlink" title="对象分配规则"></a>对象分配规则</h3><ul>
<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年代。</li>
<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年代的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<p>在垃圾收集过程中，可能会将对象移动到不同区域：</p>
<ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。</li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。</li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 </li>
</ul>
<h3 id="垃圾回收器-GC（Garbage-Collection）"><a href="#垃圾回收器-GC（Garbage-Collection）" class="headerlink" title="垃圾回收器 GC（Garbage Collection）"></a>垃圾回收器 GC（Garbage Collection）</h3><p><strong>GC的两个职能</strong>：1.<strong>检测垃圾</strong>、2.<strong>回收垃圾</strong>。</p>
<h4 id="检测垃圾"><a href="#检测垃圾" class="headerlink" title="检测垃圾"></a>检测垃圾</h4><ol>
<li><p>引用计数算法（Reference Counting）</p>
<p>原理：给每个对象添加一引用计数器，每当有一个地方引用它，计数器+1 ，引用失效时就-1 。</p>
<p>分析：引用计数算法很简单高效。但是，现在主流的虚拟机没有选用引用计数算法来管理内存，原因是它很难解决对象之间循环引用的问题。</p>
</li>
<li><p>可达性分析算法（Rearchability Analysis）</p>
<p>原理：以根集（GC Roots）对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。</p>
<p>Java中可以被作为GC Roots中的对象有：</p>
<ol>
<li>虚拟机栈中的引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中的常量池中引用的对象。</li>
<li>本地方法栈（JNI: Java Native Interface）即一般说的Native的引用对象。</li>
</ol>
<p>可达状态：在一个对象创建后，有一个以上的引用变量引用它，那它就处于可达状态。<br>可恢复状态：对象不再有任何的引用变量引用它，它将先进入可恢复状态，系统会调用finalize()方法进行资源整理，发现有一个以上引用变量引用该对象，则这个对象又再次变为可达状态，否则会变成不可达状态。</p>
<p>不可达状态：当对象的所有引用都被切断，且系统调用 finalize() 方法进行资源整理后该对象依旧没变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源。</p>
</li>
</ol>
<p><strong>对象的四种引用状态</strong></p>
<ol>
<li><p>强引用 ：创建一个对象并把这个对象直接赋给一个变量，不管系统资源多么紧张，强引用的对象都不会被回收，即使他以后不会再用到。</p>
</li>
<li><p>软引用 ：通过SoftReference修饰的类，内存非常紧张的时候会被回收，其他时候不会被回收，在使用之前要判断是否为null从而判断他是否已经被回收了。</p>
</li>
<li><p>弱引用 ：通过WeakReference修饰的类，不管内存是否足够，系统垃圾回收时必定会回收。</p>
</li>
<li><p>虚引用 ：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference修饰和引用队列ReferenceQueue类联合使用实现。</p>
</li>
</ol>
<h4 id="回收垃圾"><a href="#回收垃圾" class="headerlink" title="回收垃圾"></a>回收垃圾</h4><ol>
<li><p>串行回收和并行回收：串行回收是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作；并行回收就是把整个回收工作拆分成多个部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但更复杂，内存会增加。</p>
</li>
<li><p>程序停止和并发执行 ：顾名思义是在执行垃圾回收的同时会导致应用程序的暂停。并发执行垃圾回收虽不会导致应用程序的暂停，但需要解决和应用程序的执行冲突，因此系统开销比较高，执行时需要更多的堆内存。</p>
</li>
<li><p>标记-清除（标记-不压缩）</p>
<p>标记-清除要遍历两次。第一次先从根集开始访问所有可达对象，并将他们标记为可达状态。第二次遍历整个内存区域，对不可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片。</p>
<p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发 full gc。</p>
</li>
<li><p>复制算法</p>
<p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。遍历空间成本小效率高，但复制的空间成本大。典型的拿“空间”换“时间”。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
</li>
<li><p>标记整理（标记-压缩）</p>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。<br>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
</li>
<li><p>增量算法</p>
<p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
</li>
</ol>
<p><strong>堆内存的分代回收</strong></p>
<p>Java垃圾回收机制的最基本的做法就是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成三个年代：年轻、年老、永久。内存的分配是发生在年轻世代中的。当一个对象存活的时间够久的时候，它就会慢慢变老(被复制到老年代中）。对于不同世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。因为年轻世代的对象很快会进入不可达状态，因此要求回收频率高且回收速度快，基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p>
<p>1、年轻代</p>
<p>采用复制式回收算法，划分两个区域，分别是E 区和 S 区。大多数对象先分配到Eden区，内存大的对象会直接被分配到老年代中。S 区又分Form、To两个小区，一个用来保存对象，另一个是空的；每次进行年轻代垃圾回收的时候，就把E大区和From小区中的可达对象都复制到To区域中，一些生存时间长的就直接复制到了老年代。最后，清理回收E大区和From小区的内存空间，原来的To空间变为From空间，原来的From空间变为To空间。</p>
<p>2、老年代 </p>
<p>回收机制 ：采用标记压缩算法回收。<br>对象来源 ：对象大直接进入老年代、Young代中生存时间长的可达对象。<br>回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。</p>
<p>3、永久代 </p>
<p>用        途 ：用来装载Class，方法等信息，默认为64M（Android的运行时应用分配的内存），不会被回收。<br>对象来源 ：像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此我们经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。</p>
<p>回收频率 ：不会被回收。</p>
<h4 id="GC垃圾回收器"><a href="#GC垃圾回收器" class="headerlink" title="GC垃圾回收器"></a>GC垃圾回收器</h4><blockquote>
<p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解JVM(3)——7种垃圾收集器</a></p>
</blockquote>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg" alt="img"></p>
<p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。</p>
<h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><h6 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h6><ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li>
</ul>
<h6 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h6><p>吞吐量就是<strong>CPU用于运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值，即</p>
<p><strong>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</strong></p>
<p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<h6 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h6><ul>
<li><strong>新生代GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li><strong>老年代GC（Major GC / Full GC）</strong>：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h6 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h6><p><strong>Serial收集器</strong></p>
<p><strong>Serial（串行）</strong>收集器是最基本、发展历史最悠久的收集器，它是采用<strong>复制算法</strong>的<strong>新生代收集器</strong>，曾经（JDK 1.3.1之前）是虚拟机<strong>新生代</strong>收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是<strong>它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）</strong>。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。</p>
<p>下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png" alt="img"></p>
<p>为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是<strong>HotSpot虚拟机运行在Client模式下的默认的新生代收集器</strong>。它也有着优于其他收集器的地方：<strong>简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</strong></p>
<p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<p><strong>ParNew 收集器</strong></p>
<p><strong>ParNew</strong>收集器就是Serial收集器的多线程版本，它也是一个<strong>新生代收集器</strong>。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。</p>
<p>ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png" alt="img"></p>
<p>ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，<strong>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作</strong>，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器。</p>
<p>ParNew 收集器在<strong>单CPU的环境</strong>中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在<strong>多CPU环境</strong>下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用<strong>-XX:ParallerGCThreads</strong>参数设置。</p>
<p><strong>Parallel Scavenge 收集器</strong></p>
<p><strong>Parallel Scavenge</strong>收集器也是一个<strong>并行</strong>的<strong>多线程新生代</strong>收集器，它也使用<strong>复制算法</strong>。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是<strong>达到一个可控制的吞吐量（Throughput）</strong>。</p>
<p><strong>停顿时间越短就越适合需要与用户交互的程序</strong>，良好的响应速度能提升用户体验。而<strong>高吞吐量</strong>则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合<strong>在后台运算而不需要太多交互的任务</strong>。</p>
<p>Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数<strong>-XX:+UseAdaptiveSizePolicy</strong>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为<strong>GC自适应的调节策略（GC Ergonomics）</strong>。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<p>另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</p>
<h6 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h6><p><strong>Serial Old收集器</strong></p>
<p>Serial Old 是 Serial收集器的老年代版本，它同样是一个<strong>单线程收集器</strong>，使用<strong>“标记-整理”（Mark-Compact）</strong>算法。</p>
<p>此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</p>
<ul>
<li>在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备预案，在并发收集发生<strong>Concurrent Mode Failure</strong>时使用。</li>
</ul>
<p>它的工作流程与Serial收集器相同，这里再次给出Serial/Serial Old配合使用的工作流程图：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png" alt="img"></p>
<p><strong>Parallel Old收集器</strong></p>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和<strong>“标记-整理”</strong>算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，<strong>“吞吐量优先”收集器</strong>终于有了比较名副其实的应用组合，在<strong>注重吞吐量</strong>以及<strong>CPU资源敏感</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/9a6b1249/b1800d45.png" alt="img"></p>
<p><strong>CMS收集器</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）</strong>收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于<strong>“标记-清除”</strong>算法实现的。</p>
<p>CMS收集器工作的整个流程分为以下4个步骤：</p>
<ul>
<li><strong>初始标记（CMS initial mark）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li><strong>并发标记（CMS concurrent mark）</strong>：进行<strong>GC Roots Tracing</strong>的过程，在整个过程中耗时最长。</li>
<li><strong>重新标记（CMS remark）</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li><strong>并发清除（CMS concurrent sweep）</strong></li>
</ul>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png" alt="img"></p>
<p><strong>优点</strong></p>
<p>CMS是一款优秀的收集器，它的主要<strong>优点</strong>在名字上已经体现出来了：<strong>并发收集</strong>、<strong>低停顿</strong>，因此CMS收集器也被称为<strong>并发低停顿收集器（Concurrent Low Pause Collector）</strong>。</p>
<p><strong>缺点</strong></p>
<ul>
<li><strong>对CPU资源非常敏感</strong> 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。<strong>CMS默认启动的回收线程数是（CPU数量+3）/4</strong>，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是<strong>当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大</strong>，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li>
<li><strong>无法处理浮动垃圾（Floating Garbage）</strong> 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。<strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。</strong>这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为<strong>“浮动垃圾”</strong>。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li><strong>标记-清除算法导致的空间碎片</strong> CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li>
</ul>
<p><strong>G1收集器</strong></p>
<p><strong>G1（Garbage-First）</strong>收集器是当今收集器技术发展最前沿的成果之一，它是一款<strong>面向服务端应用</strong>的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li><strong>并行与并发</strong> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li><strong>分代收集</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li>
<li><strong>空间整合</strong> G1从整体来看是基于<strong>“标记-整理”</strong>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>“复制”</strong>算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<p><strong>横跨整个堆内存</strong></p>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它<strong>将整个Java堆划分为多个大小相等的独立区域（Region）</strong>，虽然还保留新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合</strong>。</p>
<p><strong>建立可预测的时间模型</strong></p>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的Region（这也就是Garbage-First名称的来由）</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p><strong>避免全堆扫描——Remembered Set</strong></p>
<p>G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。</p>
<p>为了避免全堆扫描的发生，虚拟机<strong>为G1中每个Region维护了一个与之对应的Remembered Set</strong>。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable<strong>把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</strong>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<hr>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><strong>初始标记（Initial Marking）</strong> 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改<strong>TAMS（Nest Top Mark Start）</strong>的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要<strong>停顿线程</strong>，但耗时很短。</li>
<li><strong>并发标记（Concurrent Marking）</strong> 从GC Root 开始对堆中对象进行<strong>可达性分析</strong>，找到存活对象，此阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</li>
<li><strong>最终标记（Final Marking）</strong> 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在<strong>线程的Remembered Set Logs</strong>里面，最终标记阶段需要<strong>把Remembered Set Logs的数据合并到Remembered Set中</strong>，这阶段需要<strong>停顿线程</strong>，但是<strong>可并行执行</strong>。</li>
<li><strong>筛选回收（Live Data Counting and Evacuation）</strong> 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：</p>
<p><img data-src="https://pic.yupoo.com/crowhawk/53b7a589/0bce1667.png" alt="img"></p>
<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">串行、并行or并发</th>
<th align="center">新生代/老年代</th>
<th align="center">算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Serial</strong></td>
<td align="center">串行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="center"><strong>Serial Old</strong></td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td align="center"><strong>ParNew</strong></td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td align="center"><strong>Parallel Scavenge</strong></td>
<td align="center">并行</td>
<td align="center">新生代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>Parallel Old</strong></td>
<td align="center">并行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>CMS</strong></td>
<td align="center">并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td align="center"><strong>G1</strong></td>
<td align="center">并发</td>
<td align="center">both</td>
<td align="center">标记-整理+复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<h3 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h3><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p>
<ul>
<li>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>
<li>jstat：JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>
<li>jmap：JVM Memory Map命令用于生成heap dump文件</li>
<li>jhat：JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li>
<li>jstack：用于生成java虚拟机当前时刻的线程快照。</li>
<li>jinfo：JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li>
</ul>
<h3 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h3><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p>
<ul>
<li>jconsole：Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li>
<li>jvisualvm：jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li>
<li>MAT：Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>
<li>GChisto：一款专业分析gc日志的工具</li>
</ul>
<h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><ol>
<li><p><strong>类的实例化顺序</strong></p>
<p>1.首先是父类的静态变量和静态代码块（看两者的书写顺序）；</p>
<p>2.第二执行子类的静态变量和静态代码块（看两者的书写顺序）；</p>
<p>3.第三执行父类的成员变量赋值</p>
<p>4.第四执行父类类的构造代码块</p>
<p>5.第五执行父类的构造方法</p>
<p>6.执行子类的构造代码块</p>
<p>7.第七执行子类的构造方法</p>
<p>总结，也就是说虽然客户端代码是new 的构造方法，但是构造方法确实是在整个实例创建中的最后一个调用。切记切记！</p>
<p><strong>先是父类，再是子类；<br>先是类静态变量和静态代码块，再是对象的成员变量和构造代码块，最后才是构造方法。</strong></p>
</li>
<li><p><strong>JVM内存结构、Java内存模型、Java对象模型的区别</strong></p>
<blockquote>
<p><a href="https://www.hollischuang.com/archives/2509" target="_blank" rel="noopener">JVM内存结构 VS Java内存模型 VS Java对象模型</a></p>
</blockquote>
<p>JVM内存结构，和Java虚拟机的运行时区域有关。</p>
<p>Java内存模型，和Java的并发编程有关。</p>
<p>Java对象模型，和Java对象在虚拟机中的表现形式有关。</p>
</li>
<li><p><strong>如和判断一个对象是否存活?(或者GC对象的判定方法)</strong></p>
<p>判断一个对象是否存活有两种方法: <strong>引用计数法</strong>和<strong>可达性算法</strong>(引用链法) </p>
<p>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比<strong>不一定会被回收</strong>。当一个对象不可达GC Root时，这个对象并<strong>不会立马被回收</strong>，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记, 如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。</p>
</li>
<li><p><strong>简述java垃圾回收机制</strong></p>
<p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
</li>
<li><p><strong>符号引用和直接引用的区别和关联</strong></p>
<p>符号引用(Symbolic References)以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。</p>
<p>直接引用(Direct References)可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
</li>
<li><p><strong>类加载器双亲委派模型机制</strong></p>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
</li>
<li><p><strong>什么是类加载器，类加载器有哪些?</strong></p>
<p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br>主要有以下四种类加载器:</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)：用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader)：用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器(system class loader)：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
</li>
<li><p><strong>Minor GC ，Full GC 触发条件</strong></p>
<p>Minor GC触发条件：当Eden区满时，触发Minor GC。</p>
<p>Full GC触发条件：</p>
<ol>
<li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法去空间不足</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
</li>
<li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
</li>
</ol>
</li>
<li><p><strong>JVM 出现 fullGC 很频繁，怎么去线上排查问题</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/wilsonpeng3/article/details/70064336" target="_blank" rel="noopener">线上FullGC频繁的排查</a></p>
</blockquote>
<p>问题</p>
<p>前段时间发现线上的一个dubbo服务Full GC比较频繁，大约每两天就会执行一次Full GC。</p>
<p>Full GC的原因<br>我们知道Full GC的触发条件大致情况有以下几种情况： </p>
<ol>
<li><p>程序执行了System.gc() //建议jvm执行fullgc，并不一定会执行 </p>
</li>
<li><p>执行了jmap -histo:live pid命令 //这个会立即触发fullgc </p>
</li>
<li><p>在执行minor gc的时候进行的一系列检查</p>
<p>执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行Full GC。如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行Full GC。如果大于则会执行Minor GC，如果Minor GC执行失败则会执行Full GC</p>
</li>
<li><p>使用了大对象 //大对象会直接进入老年代</p>
</li>
<li><p>在程序中长期持有了对象的引用 //对象年龄达到指定阈值也会进入老年代</p>
</li>
</ol>
<p>对于我们的情况，可以初步排除1，2两种情况，最有可能是4和5这两种情况。为了进一步排查原因，我们在线上开启了 -XX:+HeapDumpBeforeFullGC。</p>
<p>注意：JVM在执行dump操作的时候是会发生stop the word事件的，也就是说此时所有的用户线程都会暂停运行。为了在此期间也能对外正常提供服务，建议采用分布式部署，并采用合适的负载均衡算法</p>
<p>JVM参数的设置：<br>线上这个dubbo服务是分布式部署，在其中一台机子上开启了 -XX:HeapDumpBeforeFullGC，总体JVM参数如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xmx2g </span><br><span class="line">-XX:+HeapDumpBeforeFullGC </span><br><span class="line">-XX:HeapDumpPath=. </span><br><span class="line">-Xloggc:gc.log </span><br><span class="line">-XX:+PrintGC </span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCDateStamps </span><br><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line">-XX:NumberOfGCLogFiles=10 </span><br><span class="line">-XX:GCLogFileSize=100m </span><br><span class="line">-XX:HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>

<p>Dump文件分析</p>
<p>dump下来的文件大约1.8g，用jvisualvm查看，发现用char[]类型的数据占用了41%内存，同时另外一个com.alibaba.druid.stat.JdbcSqlStat类型的数据占用了35%的内存，也就是说整个堆中几乎全是这两类数据。</p>
<p><img data-src="https://img-blog.csdn.net/20170411171801782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsc29ucGVuZzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>查看char[]类型数据，发现几乎全是sql语句。</p>
<p><img data-src="https://img-blog.csdn.net/20170411171833819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsc29ucGVuZzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>接下来查看char[]的引用情况：</p>
<p>找到了JdbcSqlStat类，在代码中查看这个类的代码，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数只有这一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcSqlStat</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sql = sql;</span><br><span class="line">    <span class="keyword">this</span>.id = DruidDriver.createSqlStatId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看这个函数的调用情况，找到com.alibaba.druid.stat.JdbcDataSourceStat#createSqlStat方法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcSqlStat <span class="title">createSqlStat</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JdbcSqlStat sqlStat = sqlStatMap.get(sql);</span><br><span class="line">        <span class="keyword">if</span> (sqlStat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlStat = <span class="keyword">new</span> JdbcSqlStat(sql);</span><br><span class="line">            sqlStat.setDbType(<span class="keyword">this</span>.dbType);</span><br><span class="line">            sqlStat.setName(<span class="keyword">this</span>.name);</span><br><span class="line">            sqlStatMap.put(sql, sqlStat);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sqlStat;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用了一个map来存放所有的sql语句。</span></span><br></pre></td></tr></table></figure>

<p>其实到这里也就知道什么原因造成了这个问题，因为我们使用的数据源是阿里巴巴的druid，这个druid提供了一个sql语句监控功能，同时我们也开启了这个功能。只需要在配置文件中把这个功能关掉应该就能消除这个问题，事实也的确如此，关掉这个功能后到目前为止线上没再触发FullGC</p>
<p><img data-src="https://img-blog.csdn.net/20170411171944617?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsc29ucGVuZzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>其他<br>如果用mat工具查看，建议把 “Keep unreachable objects” 勾上，否则mat会把堆中不可达的对象去除掉，这样我们的分析也许会变得没有意义。如下图：Window–&gt;References 。另外jvisualvm对ool的支持不是很好，如果需要oql建议使用mat。</p>
<p><img data-src="https://img-blog.csdn.net/20180713093200563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNTg5ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
</li>
<li><p><strong>什么情况下会出现内存溢出，内存泄漏</strong></p>
<p>内存泄漏memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 </p>
<p>内存溢出 out of memory：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>
<p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p>
<ol>
<li><p><strong>静态集合类引起内存泄漏：</strong></p>
<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Static Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p>
</li>
<li><p><strong>当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>, <span class="string">"pwd1"</span>, <span class="number">25</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>, <span class="string">"pwd2"</span>, <span class="number">26</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>, <span class="string">"pwd3"</span>, <span class="number">27</span>);</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line">    System.out.println(<span class="string">"总共有:"</span> + set.size() + <span class="string">" 个元素!"</span>);</span><br><span class="line">    <span class="comment">// 结果：总共有:3 个元素!  </span></span><br><span class="line">    p3.setAge(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 修改p3的年龄,此时p3元素对应的hashcode值发生改变  </span></span><br><span class="line">    set.remove(p3);</span><br><span class="line">    <span class="comment">// 此时remove不掉，造成内存泄漏  </span></span><br><span class="line">    set.add(p3);</span><br><span class="line">    <span class="comment">// 重新添加，居然添加成功  </span></span><br><span class="line">    System.out.println(<span class="string">"总共有:"</span> + set.size() + <span class="string">" 个元素!"</span>);</span><br><span class="line">    <span class="comment">//结果：总共有:4 个元素!  </span></span><br><span class="line">    <span class="keyword">for</span> (Person person : set) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监听器</strong></p>
<p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
</li>
<li><p><strong>各种连接</strong></p>
<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和IO连接，除非其显式的调用了其close() 方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p>
</li>
<li><p><strong>内部类和外部模块的引用</strong></p>
<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：</p>
<p><code>public void registerMsg(Object b);</code></p>
<p>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>
</li>
<li><p><strong>单例模式</strong></p>
<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//B类采用单例模式  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B instance = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。</p>
</li>
</ol>
<p><strong>java内存溢出常见的有：</strong></p>
<ol>
<li><p>PermGen space</p>
<p>发生这种问题的原意是程序中使用了大量的jar或class，使java虚拟机装载类的空间不够，与Permanent Generation space有关。解决这类问题有以下两种办法：</p>
<ol>
<li>增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。如针对tomcat6.0，在catalina.sh 或catalina.bat文件中一系列环境变量名说明结束处（大约在70行左右） 增加一行： <code>JAVA_OPTS=&quot; -XX:PermSize=64M -XX:MaxPermSize=128m&quot;</code> 如果是windows服务器还可以在系统环境变量中设置。感觉用tomcat发布sprint+struts+hibernate架构的程序时很容易发生这种内存溢出错误。</li>
<li>清理应用程序中web-inf/lib下的jar，如果tomcat部署了多个应用，很多应用都使用了相同的jar，可以将共同的jar移到 tomcat共同的lib下，减少类的重复加载。</li>
</ol>
</li>
<li><p>Java heap space</p>
<p>发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之前，虚拟机分配的到堆内存空间已经用满了，与Heap space有关。解决这类问题有两种思路：</p>
<ol>
<li>检查程序，看是否有死循环或不必要地重复创建大量对象。找到原因后，修改程序和算法。 我以前写一个使用K-Means文本聚类算法对几万条文本记录（每条记录的特征向量大约10来个）进行文本聚类时，由于程序细节上有问题，就导致了 Java heap space的内存溢出问题，后来通过修改程序得到了解决。</li>
<li>增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。如：<code>set JAVA_OPTS= -Xms256m -Xmx1024m</code></li>
</ol>
</li>
<li><p>unable to create new native thread</p>
<p>在java应用中，有时候会出现这样的错误：OutOfMemoryError: unable to create new native thread.这种怪事是因为JVM已经被系统分配了大量的内存(比如1.5G)，并且它至少要占用可用内存的一半。有人发现，在线程个数很多的情况下， 你分配给JVM的内存越多，那么，上述错误发生的可能性就越大。</p>
<p>那么是什么原因造成这种问题呢？</p>
<p>每一个32位的进程最多可以使用2G的可用内存，因为另外2G被操作系统保留。这里假设使用1.5G给JVM，那么还余下500M可用内存。这 500M内存中的一部分必须用于系统dll的加载，那么真正剩下的也许只有400M，现在关键的地方出现了：当你使用Java创建一个线程，在JVM的内存里也会创建一个Thread对象，但是同时也会在操作系统里创建一个真正的物理线程(参考JVM规范)，操作系统会在余下的400兆内存里创建这个物理线程，而不是在JVM的1500M的内存堆里创建。在jdk1.4里头，默认的栈大小是256KB，但是在jdk1.5里头，默认的栈大小为1M每线程， 因此，在余下400M的可用内存里边我们最多也只能创建400个可用线程。</p>
<p>这样结论就出来了，要想创建更多的线程，你必须减少分配给JVM的最大内存。还有一种做法是让JVM宿主在你的 JNI 代码里边。</p>
</li>
</ol>
</li>
</ol>
<ol start="11">
<li><p><strong>简述Java线程栈</strong></p>
<p>Java线程栈从线程创建时存在，并且是私有的。线程栈用户存储栈帧，栈帧用于存储局部变量、中间运算结果。所以局部是不存在并发的问题，因为每个栈是私有的。虚拟机只会对Java栈进行二种操作：以栈帧为单位的压栈和出栈。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。（栈帧中各个部分的作用和数据结构详见《深入理解虚拟机》第8章）。</p>
</li>
<li><p><strong>JVM 年轻代到年老代的晋升过程的判断条件是什么呢</strong></p>
<p>虚拟机给每个对象定义一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
<p>还有一种方式是动态对象年龄判定。为了适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到看MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</li>
<li><p><strong>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式</strong></p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，有各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。</p>
<p>双亲委派模型的实现很简单，实现代码都集中在java.lang.ClassLoader的loadClass()方法之中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
<p>破坏双亲委派模式的场景：</p>
<ol>
<li><p>JDK1.2之前还没有引入双亲委派模式，为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
</li>
<li><p>JNDI服务的代码有启动类加载器去加载，但JNDI的目的就是对资源进行集中管理和查找，它需要调用有独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，单启动类加载器不可能“认识”这些代码。为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这个行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都是采用这种方式，例如：JNDI、JDBC、JCE、JAXB、和JBI等。</p>
</li>
<li><p>业界“事实上”Java模块化标准的OSGi，它实现模块化热部署的关键就是它自定义的类加载器机制的实现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。具体详见《深入理解虚拟机》第7章。</p>
</li>
</ol>
</li>
<li><p><strong>OOM错误，stackoverflow错误，permgen space错误</strong></p>
<ol>
<li><p><strong>OutOfMemoryError异常</strong></p>
<p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，</p>
<p>Java Heap 溢出</p>
<p>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess</p>
<p>java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p>
<p>出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。</p>
<p>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p>
</li>
<li><p><strong>虚拟机栈和本地方法栈溢出</strong></p>
<p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常</p>
<p>这里需要注意当栈的大小越大可分配的线程数就越少。</p>
</li>
<li><p><strong>运行时常量池溢出</strong></p>
<p>异常信息：java.lang.OutOfMemoryError:PermGen space</p>
<p>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p>
</li>
<li><p><strong>方法区溢出</strong></p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>异常信息：java.lang.OutOfMemoryError:PermGen space</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。</p>
</li>
<li><p><strong>本机直接内存溢出</strong></p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，是jvm外部的内存区域，这部分区域也可能导致OutOfMemoryError异常。</p>
<p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>
</li>
</ol>
</li>
<li><p><strong>GC日志分析</strong></p>
<p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs] </span><br><span class="line"></span><br><span class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]</span><br></pre></td></tr></table></figure>

<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
</li>
<li><p><strong>回收方法区</strong></p>
<p>方法区回收价值很低，主要回收废弃的常量和无用的类。</p>
<p>如何判断无用的类：</p>
<ol>
<li><p>该类所有实例都被回收（Java堆中没有该类的对象）</p>
</li>
<li><p>加载该类的ClassLoader已经被回收</p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方利用反射访问该类</p>
</li>
</ol>
</li>
<li><p><strong>Java对象创建过程</strong></p>
<ol>
<li><p>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</p>
</li>
<li><p>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</p>
</li>
<li><p>将除对象头外的对象内存空间初始化为0</p>
</li>
<li><p>对对象头进行必要设置</p>
</li>
</ol>
</li>
<li><p><strong>Java对象结构</strong></p>
<p>Java对象由三个部分组成：对象头、实例数据、对齐填充。</p>
<ol>
<li><p>对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。</p>
</li>
<li><p>实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</p>
</li>
<li><p>对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）</p>
</li>
</ol>
</li>
<li><p><strong>Java对象的定位方式</strong></p>
<p>句柄池、直接指针。</p>
</li>
<li><p>JVM的永久代中会发生垃圾回收么？</p>
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
</li>
<li><p>与垃圾回收相关的JVM参数：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms / -Xmx</td>
<td>堆的初始大小 / 堆的最大大小</td>
</tr>
<tr>
<td>-Xmn</td>
<td>堆中年轻代的大小</td>
</tr>
<tr>
<td>-XX:-DisableExplicitGC</td>
<td>让System.gc()不产生任何作用</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印GC的细节</td>
</tr>
<tr>
<td>-XX:+PrintGCDateStamps</td>
<td>打印GC操作的时间戳</td>
</tr>
<tr>
<td>-XX:NewSize / XX:MaxNewSize</td>
<td>设置新生代大小/新生代最大大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>可以设置老生代和新生代的比例</td>
</tr>
<tr>
<td>-XX:PrintTenuringDistribution</td>
<td>设置每次新生代GC后输出幸存者乐园中对象年龄的分布</td>
</tr>
<tr>
<td>-XX:InitialTenuringThreshold</td>
<td>设置老年代阀值的初始值</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>设置老年代阀值的最大值</td>
</tr>
<tr>
<td>-XX:TargetSurvivorRatio</td>
<td>设置幸存区的目标使用率</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>显示目录内容</p>
<ul>
<li><code>ls -a</code> 显示当前目录下的所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li>
<li><code>ls -ltr s*</code> 列出当前目录下所有名称以 s 开头的文件，越新的排越后面</li>
</ul>
</li>
<li><p>查看文本文件内容</p>
<ol>
<li><p>cat</p>
<p>从第一行开始显示全部的文本内容； </p>
</li>
<li><p>tac</p>
<p>从最后一行开始，倒序显示全部分文本内容，与cat相反； </p>
</li>
<li><p>nl</p>
<p>显示文本时，可以输出行号； </p>
</li>
<li><p>more</p>
<p>按页显示文本内容；</p>
<ul>
<li>按一下空格则往下翻一页</li>
<li>按一下Enter则往下翻一行</li>
<li>按一下B键往上翻一页</li>
<li>不能往上一行一行的翻回去了</li>
<li>：f 可以显示文件名和现在的行数</li>
<li>q退出 </li>
</ul>
</li>
<li><p>less</p>
<p>与more差不多，也是按页显示文本内容，区别是less可以一行一行的回退，more回退只能一页一页回退； </p>
<ul>
<li>more命令的所有按键less都支持</li>
<li>↑↓箭头可以实现一行一行的上下翻</li>
<li>PageDown/PageUp可以实现一页一页的上下翻</li>
</ul>
</li>
<li><p>head</p>
<p>从头开始显示文件指定的行数； </p>
<p>默认只显示文件的前10行文本内容</p>
</li>
<li><p>tail</p>
<p>显示文件指定的结尾的行数，但每一行的位置还是原文件中的位置，不会像tac那样与原文件相反。 </p>
<p>默认只显示从文件最后一行开始的10行文本内容</p>
<p><code>tail -100f test.log</code> : 实时监控100行日志</p>
</li>
</ol>
</li>
<li><p>查找文件</p>
<ul>
<li><code>find -name &quot;filename&quot;</code> 在当前目录下查找指定文件</li>
<li><code>find path -name &quot;filename&quot;</code> 在指定目录下查找指定文件</li>
<li><code>find path -name &quot;prefix*&quot;</code> 在指定目录下查找以prefix为前缀的文件</li>
<li><code>find path -iname &quot;prefix*&quot;</code> 在指定目录下查找以prefix为前缀的文件，忽略大小写。</li>
<li><code>man find</code> 查看find命令的帮助文档</li>
</ul>
</li>
<li><p>检索文件内容：grep</p>
<ul>
<li><code>grep &#39;partial\[true\]&#39; test.log</code> 在test.log文件中检索包含patrial[true]的行</li>
<li><code>grep -o &#39;engine\[[0-9a-z]*\]&#39;</code> 筛选出能够匹配指定正则表达式的内容，如engine[d93kd93nfut48]</li>
<li><code>grep -v &#39;abc&#39;</code> 过滤掉包含指定字符串的内容（反向查找）</li>
</ul>
</li>
<li><p>查看进程状态：ps</p>
<ul>
<li><code>ps -ef|grep java</code> 查找特定进程</li>
</ul>
</li>
<li><p>文本分析工具：awk</p>
<ul>
<li><code>awk &#39;{print $1,$4}&#39; test.txt</code> 每行按空格或TAB分割，输出文本中的1、4项</li>
<li><code>awk  -F &#39;,&#39;  $1,$4}&#39; test.txt</code> 每行按逗号分割，输入文本的1、4项</li>
<li><code>awk &#39;$1 == &quot;tcp&quot; &amp;&amp; $2 == 1 {print $0}&#39; test.txt</code> 输出第一项为tcp，第二项为1的行</li>
</ul>
</li>
</ol>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>流(Stream)，输入或输出管道中一串连续不断的有序数据。平常我们说的输入流与输出流指的就是输入流管道和输出流管道。与输入流管道相连的盛放数据的媒介就是流的源头，用于提供输入流管道抽取的流；与输出流管道相连的就是流的目的地，就是接收输出流管道中流的媒介，这些媒介可以是内存、磁盘、网络等。</p>
<p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。</p>
<p>为什么需要序列化呢？</p>
<ul>
<li><p>一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。</p>
</li>
<li><p>需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。</p>
</li>
</ul>
<h5 id="序列化及反序列化相关知识"><a href="#序列化及反序列化相关知识" class="headerlink" title="序列化及反序列化相关知识"></a>序列化及反序列化相关知识</h5><ol>
<li><p>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以被序列化。</p>
</li>
<li><p>通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>对对象进行序列化及反序列化</p>
</li>
<li><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 <code>private static final long serialVersionUID</code>）</p>
</li>
<li><p>序列化并不保存静态变量。</p>
</li>
<li><p>要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code> 接口。</p>
</li>
<li><p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
</li>
<li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p>
</li>
</ol>
<h5 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h5><p>serialVersionUID 表示可序列化类的版本，在反序列化对象时，用来确认序列化与反序列化该对象所使用的类的版本是否兼容。 如果类的版本不一致，那么反序列化将不能正常进行，抛出InvalidClassException。</p>
<p>如果一个可序列化的类没有包含serialVersionUID，运行时会根据这个类的特征自动计算出一个serialVersionUID。 那么，为什么不能用默认的这个实现呢，似乎更省事? 因为不同的编译器实现会导致同一个类的源代码文件，被计算出不同的serialVersionUID.</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>按流方向分类<br>从流的方向上可分为两类(在java中是站在程序角度来区分流的方向，将数据读取到程序中就是输入流；反之，将程序中的数据写出去就是输出流)： </p>
<ul>
<li>输入流： 从数据源中将数据读取到程序中的流。 </li>
<li>输出流：程序将数据写入到目的地的流。</li>
</ul>
</li>
<li><p>按流的数据类型分类</p>
<ul>
<li>字节流： 以8位的字节形式来读写的流。他们的标志是名称以Stream结尾。InputStream与OutputStream分别是所有字节输入流与字节输出流的抽象父类。</li>
<li>字符流： 以字符形式来读写的流。它们的标志是名称以Reader或者Writer结尾。并且Reader和Writer分别是所有字符输入流与字符输出流的抽象父类。</li>
</ul>
</li>
<li><p>按照实现功能分类</p>
<ul>
<li>节点流：程序用于直接操作目标设备所对应的类叫节点流。 </li>
<li>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据，这个间接流类就是处理流。</li>
</ul>
<table border=0 cellpadding=0 cellspacing=0 width=793 style='border-collapse: 
 collapse;table-layout:fixed;width:594pt'>
 <col width=59 style='mso-width-source:userset;width:44pt'>
 <col width=74 style='mso-width-source:userset;width:55pt'>
 <col width=165 span=4 style='mso-width-source:userset;width:123pt'>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r0'>
<td height=39 class=x21 width=59 style='height:29.25pt;width:44.25pt;' >流分类</td>
<td class=x21 width=74 style='width:55.5pt;' >使用分类</td>
<td class=x21 width=165 style='width:123.75pt;' >字节输入流</td>
<td class=x21 width=165 style='width:123.75pt;' >字节输出流</td>
<td class=x21 width=165 style='width:123.75pt;' >字符输入流</td>
<td class=x21 width=165 style='width:123.75pt;' >字符输出流</td>
 </tr>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r1'>
<td height=39 class=x22 style='height:29.25pt;' ></td>
<td class=x22>抽象基类</td>
<td class=x23>InputStream</td>
<td class=x23>OutputStream</td>
<td class=x23>Reader</td>
<td class=x23>Writer</td>
 </tr>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r2'>
<td rowspan=4 height=194 class=x21 style='border-right:2px solid #C0C0C0;border-bottom:2px solid #C0C0C0;height:145.5pt;' >节点流</td>
<td class=x21>访问文件</td>
<td class=x24>FileInputStream</td>
<td class=x24>FileOutStream</td>
<td class=x24>FileReader</td>
<td class=x24>FileWriter</td>
 </tr>
 <tr height=58 style='mso-height-source:userset;height:43.5pt' id='r3'>
<td class=x25>访问数值</td>
<td class=x26 style='overflow:hidden;' >ByteArrayInputStream</td>
<td class=x26 style='overflow:hidden;' >ByteArrayOutStream</td>
<td class=x26>CharArrayReader</td>
<td class=x26>CharArrayWriter</td>
 </tr>
 <tr height=58 style='mso-height-source:userset;height:43.5pt' id='r4'>
<td class=x21>访问管道</td>
<td class=x24>PipedInputStream</td>
<td class=x24>PipedOutStream</td>
<td class=x24>PipedReader</td>
<td class=x24>PipedWriter</td>
 </tr>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r5'>
<td class=x25>访问字符串</td>
<td class=x22></td>
<td class=x22></td>
<td class=x26>StringReader</td>
<td class=x26>StringWriter</td>
 </tr>
 <tr height=58 style='mso-height-source:userset;height:43.5pt' id='r6'>
<td rowspan=7 height=349 class=x21 style='border-right:2px solid #C0C0C0;border-bottom:2px solid #C0C0C0;height:261.75pt;' >处理流</td>
<td class=x21>缓冲流</td>
<td class=x21>BufferedInputStream</td>
<td class=x21 style='overflow:hidden;' >BufferedOutputStream</td>
<td class=x21>BufferedReader</td>
<td class=x21>BufferedWriter</td>
 </tr>
 <tr height=58 style='mso-height-source:userset;height:43.5pt' id='r7'>
<td class=x22>转换流</td>
<td class=x22></td>
<td class=x22></td>
<td class=x22>InputStreamReader</td>
<td class=x22>OutputStreamWriter</td>
 </tr>
 <tr height=58 style='mso-height-source:userset;height:43.5pt' id='r8'>
<td class=x21>对象流</td>
<td class=x21>ObjectInputStream</td>
<td class=x21>ObjectOutputStream</td>
<td class=x21></td>
<td class=x21></td>
 </tr>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r9'>
<td class=x22 style='overflow:hidden;' >抽象基类（过滤）</td>
<td class=x23>FilterInputStream</td>
<td class=x23>FilterOutputStream</td>
<td class=x23>FilterReader</td>
<td class=x23>FilterWriter</td>
 </tr>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r10'>
<td class=x21>打印流</td>
<td class=x21></td>
<td class=x21>PrintStream</td>
<td class=x21></td>
<td class=x21>PrintWriter</td>
 </tr>
 <tr height=58 style='mso-height-source:userset;height:43.5pt' id='r11'>
<td class=x22 style='overflow:hidden;' >推回输入流</td>
<td class=x22>PushbackInputStream</td>
<td class=x22></td>
<td class=x22>PushbackReader</td>
<td class=x22></td>
 </tr>
 <tr height=39 style='mso-height-source:userset;height:29.25pt' id='r12'>
<td class=x21>特殊流</td>
<td class=x21>DataInputStream</td>
<td class=x21>DataOutputStream</td>
<td class=x21></td>
<td class=x21></td>
 </tr>
<![if supportMisalignedColumns]>
 <tr height=0 style='display:none'>
  <td width=59 style='width:44.25pt'></td>
  <td width=74 style='width:55.5pt'></td>
  <td width=200 style='width:123.75pt'></td>
  <td width=200 style='width:123.75pt'></td>
  <td width=200 style='width:123.75pt'></td>
  <td width=200 style='width:123.75pt'></td>
 </tr>
 <![endif]>
</table>

</li>
</ol>
<h3 id="Java-IO体系架构图"><a href="#Java-IO体系架构图" class="headerlink" title="Java IO体系架构图"></a>Java IO体系架构图</h3><p>java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><img data-src="https://img-blog.csdn.net/20170915145559782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanNzZ190enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>（1） 按操作方式分类结构图：</strong></p>
<p><img data-src="https://segmentfault.com/img/remote/1460000014932362?w=720&h=1080" alt="按操作方式分类结构图："></p>
<p><strong>（2）按操作对象分类结构图</strong></p>
<p><img data-src="https://segmentfault.com/img/remote/1460000014932363" alt="按操作对象分类结构图"></p>
<h3 id="常用IO流"><a href="#常用IO流" class="headerlink" title="常用IO流"></a>常用IO流</h3><blockquote>
<p> <a href="https://blog.csdn.net/nightcurtis/article/details/51324105#t4" target="_blank" rel="noopener">常用的IO流的用法</a></p>
</blockquote>
<h4 id="IO体系的基类（InputStream-Reader，OutputStream-Writer）"><a href="#IO体系的基类（InputStream-Reader，OutputStream-Writer）" class="headerlink" title="IO体系的基类（InputStream/Reader，OutputStream/Writer）"></a>IO体系的基类（InputStream/Reader，OutputStream/Writer）</h4><p>字节流和字符流的操作方式基本一致，只是操作的数据单元不同——字节流的操作单元是字节，字符流的操作单元是字符。</p>
<p>InputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可使用的方法。 </p>
<p>在InputStream里面包含如下3个方法。</p>
<ol>
<li><code>int read();</code> 从输入流中读取单个字节（相当于从水管中取出一滴水），返回所读取的字节数据（字节数据可直接转换为int类型）。</li>
<li><code>int read(byte[] b)</code> 从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。</li>
<li><code>int read(byte[] b,int off,int len);</code> 从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。</li>
</ol>
<p>在Reader中包含如下3个方法。</p>
<ol>
<li><code>int read();</code> 从输入流中读取单个字符（相当于从水管中取出一滴水），返回所读取的字符数据（字节数据可直接转换为int类型）。</li>
<li><code>int read(char[] b)</code> 从输入流中最多读取b.length个字符的数据，并将其存储在字节数组b中，返回实际读取的字符数。</li>
<li><code>int read(char[] b,int off,int len);</code> 从输入流中最多读取len个字符的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数。</li>
</ol>
<p>对比InputStream和Reader所提供的方法，就不难发现这两个基类的功能基本是一样的。InputStream和Reader都是将输入数据抽象成水管，所以程序即可以通过read()方法每次读取一个”水滴“，也可以通过read（char[] chuf）或者read（byte[] b）方法来读取多个“水滴”。当使用数组作为read（）方法中的参数, 我们可以理解为使用一个“竹筒”到水管中取水，read(char[] cbuf)方法的参数可以理解成一个”竹筒“，程序每次调用输入流read(char[] cbuf)或read（byte[] b）方法，就相当于用“竹筒”从输入流中取出一筒“水滴”，程序得到“竹筒”里面的”水滴“后，转换成相应的数据即可；程序多次重复这个“取水”过程，直到最后。程序如何判断取水取到了最后呢？直到read（char[] chuf）或者read（byte[] b）方法返回-1，即表明到了输入流的结束点。</p>
<p><img data-src="https://img-blog.csdn.net/20160507103905278" alt=""></p>
<p>InputStream和Reader提供的一些移动指针的方法：</p>
<ul>
<li><code>void mark(int readAheadLimit);</code> 在记录指针当前位置记录一个标记（mark）。</li>
<li><code>boolean markSupported();</code> 判断此输入流是否支持mark()操作，即是否支持记录标记。</li>
<li><code>void reset();</code> 将此流的记录指针重新定位到上一次记录标记（mark）的位置。</li>
<li><code>long skip(long n);</code> 记录指针向前移动n个字节/字符。</li>
</ul>
<p>OutputStream和Writer： </p>
<p>OutputStream和Writer的用法也非常相似，两个流都提供了如下三个方法：</p>
<ol>
<li><code>void write(int c);</code> 将指定的字节/字符输出到输出流中，其中c即可以代表字节，也可以代表字符。</li>
<li><code>void write(byte[]/char[] buf);</code> 将字节数组/字符数组中的数据输出到指定输出流中。</li>
<li><code>void write(byte[]/char[] buf, int off,int len );</code> 将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。</li>
</ol>
<p>因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String对象作为参数。Writer里面还包含如下两个方法。</p>
<ol start="4">
<li><code>void write(String str);</code> 将str字符串里包含的字符输出到指定输出流中。</li>
<li><code>void write (String str, int off, int len);</code> 将str字符串里面从off位置开始，长度为len的字符输出到指定输出流中。</li>
</ol>
<h4 id="IO体系的基类文件流的使用-FileInputStream-FileReader-，FileOutputStream-FileWriter"><a href="#IO体系的基类文件流的使用-FileInputStream-FileReader-，FileOutputStream-FileWriter" class="headerlink" title="IO体系的基类文件流的使用(FileInputStream/FileReader ，FileOutputStream/FileWriter)"></a>IO体系的基类文件流的使用(FileInputStream/FileReader ，FileOutputStream/FileWriter)</h4><p>前面说过InputStream和Reader都是抽象类，本身不能创建实例，但它们分别有一个用于读取文件的输入流：FileInputStream和FileReader，它们都是节点流——会直接和指定文件关联。下面程序示范使用FileInputStream和FileReader。 </p>
<p>使用FileInputStream读取文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//创建字节输入流</span></span><br><span class="line">          fis=<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\Test.txt"</span>);</span><br><span class="line">          <span class="comment">//创建一个长度为1024的竹筒</span></span><br><span class="line">          <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">          <span class="comment">//用于保存的实际字节数</span></span><br><span class="line">          <span class="keyword">int</span> hasRead=<span class="number">0</span>;</span><br><span class="line">          <span class="comment">//使用循环来重复取水的过程</span></span><br><span class="line">          <span class="keyword">while</span>((hasRead=fis.read(b))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="comment">//取出竹筒中的水滴（字节），将字节数组转换成字符串进行输出</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(b,<span class="number">0</span>,hasRead));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          fis.close();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：上面程序最后使用了fis.close()来关闭该文件的输入流，与JDBC编程一样，程序里面打开的文件IO资源不属于内存的资源，垃圾回收机制无法回收该资源，所以应该显示的关闭打开的IO资源。Java 7改写了所有的IO资源类，它们都实现了AntoCloseable接口，因此都可以通过自动关闭资源的try语句来关闭这些IO流。</p>
<p>使用FileReader读取文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileReader fis=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建字节输入流</span></span><br><span class="line">            fis=<span class="keyword">new</span> FileReader(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\Test.txt"</span>);</span><br><span class="line">            <span class="comment">//创建一个长度为1024的竹筒</span></span><br><span class="line">            <span class="keyword">char</span>[] b=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//用于保存的实际字节数</span></span><br><span class="line">            <span class="keyword">int</span> hasRead=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//使用循环来重复取水的过程</span></span><br><span class="line">            <span class="keyword">while</span>((hasRead=fis.read(b))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//取出竹筒中的水滴（字节），将字节数组转换成字符串进行输出</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> String(b,<span class="number">0</span>,hasRead));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出使用FileInputStream和FileReader进行文件的读写并没有什么区别，只是操作单元不同而且。</p>
<p>FileOutputStream/FileWriter是IO中的文件输出流，下面介绍这两个类的用法。</p>
<p>FileOutputStream的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建字节输入流</span></span><br><span class="line">            fis=<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\Test.txt"</span>);</span><br><span class="line">            <span class="comment">//创建字节输出流</span></span><br><span class="line">            fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\newTest.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> hasRead=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环从输入流中取出数据</span></span><br><span class="line">            <span class="keyword">while</span>((hasRead=fis.read(b))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//每读取一次，即写入文件输入流，读了多少，就写多少。</span></span><br><span class="line">                fos.write(b,<span class="number">0</span>,hasRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序可以看到输出流指定的目录下多了一个文件：newTest.txt, 该文件的内容和Test.txt文件的内容完全相同。FileWriter的使用方式和FileOutputStream基本类似，这里就带过。</p>
<p>注： 使用java的io流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区中的数据flush到物理节点中里（因为在执行close（）方法之前，自动执行输出流的flush（）方法）。java很多输出流默认都提供了缓存功能，其实我们没有必要刻意去记忆哪些流有缓存功能，哪些流没有，只有正常关闭所有的输出流即可保证程序正常。</p>
<h4 id="缓冲流的使用（BufferedInputStream-BufferedReader-BufferedOutputStream-BufferedWriter）："><a href="#缓冲流的使用（BufferedInputStream-BufferedReader-BufferedOutputStream-BufferedWriter）：" class="headerlink" title="缓冲流的使用（BufferedInputStream/BufferedReader, BufferedOutputStream/BufferedWriter）："></a>缓冲流的使用（BufferedInputStream/BufferedReader, BufferedOutputStream/BufferedWriter）：</h4><p>下面介绍字节缓存流的用法（字符缓存流的用法和字节缓存流一致就不介绍了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        BufferedInputStream bis=<span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建字节输入流</span></span><br><span class="line">            fis=<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\Test.txt"</span>);</span><br><span class="line">            <span class="comment">//创建字节输出流</span></span><br><span class="line">            fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\newTest.txt"</span>);</span><br><span class="line">            <span class="comment">//创建字节缓存输入流</span></span><br><span class="line">            bis=<span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            <span class="comment">//创建字节缓存输出流</span></span><br><span class="line">            bos=<span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> hasRead=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//循环从缓存流中读取数据</span></span><br><span class="line">            <span class="keyword">while</span>((hasRead=bis.read(b))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//向缓存流中写入数据，读取多少写入多少</span></span><br><span class="line">                bos.write(b,<span class="number">0</span>,hasRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到使用字节缓存流读取和写入数据的方式和文件流（FileInputStream,FileOutputStream）并没有什么不同，只是把处理流套接到文件流上进行读写。</p>
<p>上面代码中我们使用了缓存流和文件流，但是我们只关闭了缓存流。这个需要注意一下，当我们使用处理流套接到节点流上的使用的时候，只需要关闭最外层的处理就可以了。java会自动帮我们关闭下层的节点流。</p>
<h4 id="转换流的使用（InputStreamReader-OutputStreamWriter）"><a href="#转换流的使用（InputStreamReader-OutputStreamWriter）" class="headerlink" title="转换流的使用（InputStreamReader/OutputStreamWriter）"></a>转换流的使用（InputStreamReader/OutputStreamWriter）</h4><p>下面以获取键盘输入为例来介绍转换流的用法。java使用System.in代表输入。即键盘输入，但这个标准输入流是InputStream类的实例，使用不太方便，而且键盘输入内容都是文本内容，所以可以使用InputStreamReader将其包装成BufferedReader,利用BufferedReader的readLine()方法可以一次读取一行内容，如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将System.in(InputStream)对象转化为Reader对象</span></span><br><span class="line">            InputStreamReader reader=<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            <span class="comment">//将普通的Reader包装成BufferedReader</span></span><br><span class="line">            BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">           String buffer=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">while</span> ((buffer=bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果读取到的字符串为“exit”,则程序退出</span></span><br><span class="line">               <span class="keyword">if</span>(buffer.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                   System.exit(<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//打印读取的内容</span></span><br><span class="line">               System.out.print(<span class="string">"输入内容："</span>+buffer);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序将System.in包装成BufferedReader,BufferedReader流具有缓存功能，它可以一次读取一行文本——以换行符为标志，如果它没有读到换行符，则程序堵塞。等到读到换行符为止。运行上面程序可以发现这个特征，当我们在控制台执行输入时，只有按下回车键，程序才会打印出刚刚输入的内容。</p>
<h4 id="对象流的使用（ObjectInputStream-ObjectOutputStream）的使用"><a href="#对象流的使用（ObjectInputStream-ObjectOutputStream）的使用" class="headerlink" title="对象流的使用（ObjectInputStream/ObjectOutputStream）的使用"></a>对象流的使用（ObjectInputStream/ObjectOutputStream）的使用</h4><p>写入对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OutputStream outputStream=<span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream buf=<span class="keyword">null</span>;</span><br><span class="line">    ObjectOutputStream obj=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//序列化文件輸出流</span></span><br><span class="line">        outputStream=<span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\myfile.tmp"</span>);</span><br><span class="line">        <span class="comment">//构建缓冲流</span></span><br><span class="line">        buf=<span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">        <span class="comment">//构建字符输出的对象流</span></span><br><span class="line">        obj=<span class="keyword">new</span> ObjectOutputStream(buf);</span><br><span class="line">        <span class="comment">//序列化数据写入</span></span><br><span class="line">        obj.writeObject(<span class="keyword">new</span> Person(<span class="string">"A"</span>, <span class="number">21</span>));<span class="comment">//Person对象</span></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        obj.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream inputStream=<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\learnproject\\Iotest\\lib\\src\\main\\java\\com\\myfile.tmp"</span>);</span><br><span class="line">        <span class="comment">//构建缓冲流</span></span><br><span class="line">        BufferedInputStream buf=<span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">        <span class="comment">//构建字符输入的对象流</span></span><br><span class="line">        ObjectInputStream obj=<span class="keyword">new</span> ObjectInputStream(buf);</span><br><span class="line">        Person tempPerson=(Person)obj.readObject();</span><br><span class="line">        System.out.println(<span class="string">"Person对象为："</span>+tempPerson);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        obj.close();</span><br><span class="line">        buf.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用对象流的一些注意事项 </p>
<ol>
<li><p>读取顺序和写入顺序一定要一致，不然会读取出错。 </p>
</li>
<li><p>在对象属性前面加transient关键字，则该对象的属性不会被序列化。</p>
</li>
</ol>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484951&amp;idx=1&amp;sn=0cef67df4b883b198da467c927533316&source=41#wechat_redirect" target="_blank" rel="noopener">Java NIO 概览</a></p>
</blockquote>
<p>Java NIO 是 java 1.4 之后新出的一套IO接口，NIO中的N可以理解为Non-blocking，不单纯是New。</p>
<p>我们使用InputStream从输入流中读取数据时，如果没有读取到有效的数据，程序将在此处阻塞该线程的执行。其实传统的输入里和输出流都是阻塞式的进行输入和输出。 不仅如此，传统的输入流、输出流都是通过字节的移动来处理的（即使我们不直接处理字节流，但底层实现还是依赖于字节处理），也就是说，面向流的输入和输出一次只能处理一个字节，因此面向流的输入和输出系统效率通常不高。 </p>
<p>从JDk1.4开始，java提供了一系列改进的输入和输出处理的新功能，这些功能被统称为新IO(NIO)。新增了许多用于处理输入和输出的类，这些类都被放在java.nio包及其子包下，并且对原io的很多类都以NIO为基础进行了改写。新增了满足NIO的功能。 </p>
<p>NIO采用了内存映射对象的方式来处理输入和输出，NIO将文件或者文件的一块区域映射到内存中，这样就可以像访问内存一样来访问文件了。通过这种方式来进行输入/输出比传统的输入和输出要快的多。</p>
<h4 id="Java-NIO-概览"><a href="#Java-NIO-概览" class="headerlink" title="Java NIO 概览"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483956&idx=1&sn=57692bc5b7c2c6dfb812489baadc29c9&chksm=fd985455caefdd4331d828d8e89b22f19b304aa87d6da73c5d8c66fcef16e4c0b448b1a6f791#rd" target="_blank" rel="noopener">Java NIO 概览</a></h4><p>主要内容:</p>
<ol>
<li>NIO简介：Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。</li>
<li><strong>NIO的特性/NIO与IO区别:</strong><ul>
<li>1)IO是面向流的，NIO是面向缓冲区的；</li>
<li>2)IO流是阻塞的，NIO流是不阻塞的;</li>
<li>3)NIO有选择器，而IO没有。</li>
</ul>
</li>
<li><strong>读数据和写数据方式:</strong><ul>
<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
</li>
<li><strong>NIO核心组件简单介绍</strong><ul>
<li><strong>Channels</strong></li>
<li><strong>Buffers</strong></li>
<li><strong>Selectors</strong></li>
</ul>
</li>
</ol>
<h4 id="Java-NIO-之-Buffer-缓冲区"><a href="#Java-NIO-之-Buffer-缓冲区" class="headerlink" title="Java NIO 之 Buffer(缓冲区)"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483961&idx=1&sn=f67bef4c279e78043ff649b6b03fdcbc&chksm=fd985458caefdd4e3317ccbdb2d0a5a70a5024d3255eebf38183919ed9c25ade536017c0a6ba#rd" target="_blank" rel="noopener">Java NIO 之 Buffer(缓冲区)</a></h4><p>主要内容:</p>
<ol>
<li><p><strong>Buffer(缓冲区)介绍:</strong></p>
<ul>
<li>Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；</li>
<li>Buffer本质上就是一块内存区；</li>
<li>一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。</li>
</ul>
</li>
<li><p><strong>Buffer的常见方法</strong></p>
<ul>
<li>Buffer clear()</li>
<li>Buffer flip()</li>
<li>Buffer rewind()</li>
<li>Buffer position(int newPosition)</li>
</ul>
</li>
<li><p><strong>Buffer的使用方式/方法介绍:</strong></p>
<ul>
<li><p>分配缓冲区（Allocating a Buffer）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(28); &#x2F;&#x2F;以ByteBuffer为例子</span><br></pre></td></tr></table></figure>
</li>
<li><p>写入数据到缓冲区（Writing Data to a Buffer）</p>
<p><strong>写数据到Buffer有两种方法：</strong></p>
<p>1.从Channel中写数据到Buffer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</span><br></pre></td></tr></table></figure>

<p>2.通过put写数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Buffer常用方法测试</p>
<p>说实话，NIO编程真的难，通过后面这个测试例子，你可能才能勉强理解前面说的Buffer方法的作用。</p>
</li>
</ol>
<h4 id="Java-NIO-之-Channel（通道）"><a href="#Java-NIO-之-Channel（通道）" class="headerlink" title="Java NIO 之 Channel（通道）"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483966&idx=1&sn=d5cf18c69f5f9ec2aff149270422731f&chksm=fd98545fcaefdd49296e2c78000ce5da277435b90ba3c03b92b7cf54c6ccc71d61d13efbce63#rd" target="_blank" rel="noopener">Java NIO 之 Channel（通道）</a></h4><p>主要内容:</p>
<ol>
<li><strong>Channel（通道）介绍</strong><ul>
<li>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</li>
<li>NIO Channel通道和流的区别：</li>
</ul>
</li>
<li><strong>FileChannel的使用</strong></li>
<li><strong>SocketChannel和ServerSocketChannel的使用</strong></li>
<li><strong>️DatagramChannel的使用</strong></li>
<li><strong>Scatter / Gather</strong><ul>
<li>Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).</li>
<li>Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.</li>
</ul>
</li>
<li><strong>通道之间的数据传输</strong><ul>
<li>在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。</li>
<li>transferFrom() :transferFrom方法把数据从通道源传输到FileChannel</li>
<li>transferTo() :transferTo方法把FileChannel数据传输到另一个channel</li>
</ul>
</li>
</ol>
<h4 id="Java-NIO之Selector（选择器）"><a href="#Java-NIO之Selector（选择器）" class="headerlink" title="Java NIO之Selector（选择器）"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483970&idx=1&sn=d5e2b133313b1d0f32872d54fbdf0aa7&chksm=fd985423caefdd354b587e57ce6cf5f5a7bec48b9ab7554f39a8d13af47660cae793956e0f46#rd" target="_blank" rel="noopener">Java NIO之Selector（选择器）</a></h4><p>主要内容:</p>
<ol>
<li><p><strong>Selector（选择器）介绍</strong></p>
<ul>
<li>Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。</li>
<li>使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</li>
</ul>
</li>
<li><p><strong>Selector（选择器）的使用方法介绍</strong></p>
<ul>
<li>Selector的创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br></pre></td></tr></table></figure>

<ul>
<li>注册Channel到Selector(Channel必须是非阻塞的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey key &#x3D; channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SelectionKey介绍</p>
<p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p>
</li>
<li><p>从Selector中选择channel(Selecting Channels via a Selector)</p>
<p>选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.</p>
</li>
<li><p>停止选择的方法</p>
<p>wakeup()方法 和close()方法。</p>
</li>
</ul>
</li>
<li><p>模板代码</p>
<p>有了模板代码我们在编写程序时，大多数时间都是在模板代码中添加相应的业务代码。</p>
</li>
<li><p><strong>客户端与服务端简单交互实例</strong></p>
</li>
</ol>
<h4 id="Java-NIO之拥抱Path和Files"><a href="#Java-NIO之拥抱Path和Files" class="headerlink" title="Java NIO之拥抱Path和Files"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&tempkey=OTU3X2k5RHFXbjA4MHhzcC9DN0F6TU1OdlgzVno5ZkhYV29GSEZURmktTWJRUkFib2FKNnRwZGE2RHdPTDJMUXl5cVVwMVJWUUVodU4zWlg4YUw1ZURPVXRXakJLcXhDN0VaenkyYjdJdm9uRVJrcWROcGh3d2c2NWNsQjFNWld5N2lNNmxVUWJ1enlad1dUNVoyNFBPaEJyU05KMmpaZEJCLVFSUWllbGd%2Bfg%3D%3D&chksm=7d9854254aefdd33a40a4bad918bdc54cc64450bc3d4597ee53151fdedcdbd2ce722fc8aca4d#rd" target="_blank" rel="noopener">Java NIO之拥抱Path和Files</a></h4><p>主要内容</p>
<p><strong>一 文件I/O基石：Path：</strong></p>
<ul>
<li>创建一个Path</li>
<li>File和Path之间的转换，File和URI之间的转换</li>
<li>获取Path的相关信息</li>
<li>移除Path中的冗余项</li>
</ul>
<p><strong>二 拥抱Files类：</strong></p>
<ul>
<li>Files.exists() 检测文件路径是否存在</li>
<li>Files.createFile() 创建文件</li>
<li>Files.createDirectories()和Files.createDirectory()创建文件夹</li>
<li>Files.delete()方法 可以删除一个文件或目录</li>
<li>Files.copy()方法可以吧一个文件从一个地址复制到另一个位置</li>
<li>获取文件属性</li>
<li>遍历一个文件夹</li>
<li>Files.walkFileTree()遍历整个目录</li>
</ul>
<h3 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h3><p>在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。</p>
<ol>
<li><p>阻塞IO模型</p>
<p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<p>典型的阻塞IO模型的例子为：<code>data = socket.read();</code></p>
<p>如果数据没有就绪，就会一直阻塞在read方法。</p>
</li>
<li><p>非阻塞IO模型</p>
<p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<p>典型的非阻塞IO模型一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;</span><br><span class="line">        处理数据</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</p>
</li>
<li><p>多路复用IO模型</p>
<p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p>
<p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
<p>在<strong>Java NIO</strong>中，是通过<strong>selector.select()</strong>去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p>
<p>也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</p>
<p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
</li>
<li><p>信号驱动IO模型</p>
<p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
</li>
<li><p>异步IO模型</p>
<p>异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个<strong>asynchronous read</strong>之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p>也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。</p>
<p>注意，<em>异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。</em></p>
</li>
</ol>
<p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>
<h3 id="两种高性能IO设计模式"><a href="#两种高性能IO设计模式" class="headerlink" title="两种高性能IO设计模式"></a>两种高性能IO设计模式</h3><p>在传统的网络服务设计模式中，有两种比较经典的模式：一种是多线程，一种是线程池。</p>
<p>对于多线程模式，也就是说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：</p>
<p><img data-src="https://blog.yoodb.com/upload/images/20180324/1521879385289017631.png" alt="image.png"></p>
<p>这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。</p>
<p>但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。</p>
<p>因此便出现了下面的两种高性能IO设计模式：<strong>Reactor</strong>和<strong>Proactor</strong>。</p>
<ol>
<li><p>在<strong>Reactor</strong>模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：</p>
<p><img data-src="https://blog.yoodb.com/upload/images/20180324/1521879397512085247.png" alt="image.png"></p>
<p>从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。</p>
</li>
<li><p>在<strong>Proactor</strong>模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是<strong>Proactor</strong>模式。</p>
</li>
</ol>
<h3 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h3><ol>
<li><p><strong>什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别</strong></p>
<p>Bit：最小的二进制单位 ，是计算机的操作部分 取值0或者1<br>Byte：是计算机操作数据的最小单位由8位bit组成 取值（-128-127）<br>Char：是用户的可读写的最小单位，在Java里面由16位bit组成 取值（0-65535）</p>
<p>Bit 是最小单位 计算机 只认识 0或者1 </p>
<p>8个字节 是给计算机看的</p>
<p>字符 是看到的东西  一个字符=二个字节</p>
</li>
<li><p><strong>PrintStream、BufferedWriter、PrintWriter的比较?</strong> </p>
<ul>
<li>PrintStream类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成PrintStream后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了<strong>自动刷新</strong>，可以创建一个 PrintStream</li>
<li>BufferedWriter：将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过write()方法可以将获取到的字符输出，然后通过newLine()进行换行操作。BufferedWriter中的字符流必须通过调用flush方法才能将其刷出去。并且BufferedWriter只能对字符流进行操作。如果要对字节流操作，则使用BufferedInputStream。</li>
<li>PrintWriter的println方法自动添加换行，不会抛异常，若关心异常，需要调用checkError方法看是否有异常发生，PrintWriter构造方法可指定参数，实现自动刷新缓存（autoflush）；</li>
</ul>
</li>
<li><p><strong><code>System.out.println()</code>是什么？</strong><br><code>println</code>是PrintStream的一个方法。<code>out</code>是一个静态PrintStream类型的成员变量，<code>System</code>是一个java.lang包中的类，用于和底层的操作系统进行交互。</p>
</li>
<li><p><strong>什么是Filter流？</strong><br>Filter Stream主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能。</p>
</li>
<li><p><strong>有哪些可用的Filter流？</strong><br>在java.io包中主要由4个可用的filter Stream。两个字节filter stream，两个字符filter stream. 分别是FilterInputStream, FilterOutputStream, FilterReader and FilterWriter.这些类是抽象类，不能被实例化。</p>
<p>有些Filter流的子类：</p>
<ul>
<li>LineNumberInputStream：给目标文件增加行号</li>
<li>DataInputStream：有些特殊的方法如<code>readInt()</code>, <code>readDouble()</code>和<code>readLine()</code> 等可以读取一个 int, double和一个string一次性的。</li>
<li>BufferedInputStream：增加性能</li>
<li>PushbackInputStream：推送要求的字节到系统中</li>
</ul>
</li>
<li><p><strong>SequenceInputStream的作用？</strong></p>
<p>SequenceInputStream 合并流：能够将两个流合并成一个流。在拷贝多个文件到一个目标文件的时候是非常有用的。可用使用很少的代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoFiles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream fistream1 = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/aihe/Desktop/Songshu/code/java8source/src/main/resources/A.txt"</span>);  <span class="comment">// first source file</span></span><br><span class="line">        FileInputStream fistream2 = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/aihe/Desktop/Songshu/code/java8source/src/main/resources/B.txt"</span>);  <span class="comment">//second source file</span></span><br><span class="line"></span><br><span class="line">        SequenceInputStream sistream = <span class="keyword">new</span> SequenceInputStream(fistream1, fistream2);</span><br><span class="line">        FileOutputStream fostream = <span class="keyword">new</span> FileOutputStream(<span class="string">"C.txt"</span>);        <span class="comment">// destination file</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>( ( temp = sistream.read() ) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print( (<span class="keyword">char</span>) temp ); <span class="comment">// to print at DOS prompt</span></span><br><span class="line">            fostream.write(temp);   <span class="comment">// to write to file</span></span><br><span class="line">        &#125;</span><br><span class="line">        fostream.close();</span><br><span class="line">        sistream.close();</span><br><span class="line">        fistream1.close();</span><br><span class="line">        fistream2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>说说管道流(Piped Stream)</strong><br>有四种管道流， PipedInputStream, PipedOutputStream, PipedReader 和 PipedWriter，用于不同线程之间的相互通信。</p>
<p>java的管道输入与输出实际上使用的是一个循环缓冲数组来实现，这个数组默认大小为1024字节。输入流PipedInputStream从这个循环缓冲数组中读数据，输出流PipedOutputStream往这个循环缓冲数组中写入数据。当这个缓冲数组已满的时候，输出流PipedOutputStream所在的线程将阻塞；当这个缓冲数组首次为空的时候，输入流PipedInputStream所在的线程将阻塞。</p>
<p>Java在它的jdk文档中提到不要在一个线程中同时使用PipeInpuStream和PipeOutputStream，这会造成死锁。</p>
</li>
<li><p>NIO与IO区别</p>
<ol>
<li><p>IO是面向流的，NIO是面向缓冲区的；</p>
</li>
<li><p>IO流是阻塞的，NIO流是不阻塞的;</p>
</li>
<li><p>NIO有选择器，而IO没有。</p>
</li>
</ol>
</li>
<li><p>说说File类</p>
<p>它不属于 IO流，也不是用于文件操作的，它主要用于知道一个文件的属性，读写权限，大小等信息。</p>
</li>
<li><p>说说RandomAccessFile?</p>
<p>它在java.io包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是Object的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是RandomAccessFile既可以读文件，也可以写文件。 DataInputStream 和 DataOutStream有的方法，在RandomAccessFile中都存在。</p>
</li>
<li><p>把包括基本类型在内的数据和字符串按顺序输出到数据源，或者按照顺序从数据源读入，一般用哪两个流</p>
</li>
</ol>
<p>​    DataInputStream DataOutputStream</p>
<ol start="12">
<li><p>File类型中定义了什么方法来创建一级目录？</p>
<p>File类的mkdir方法根据抽象路径创建目录；File类的mkdirs方法根据抽象路径创建目录，包括创建必需但不存在的父目录</p>
</li>
<li><p>在unix服务器 <a href="http://www.openlab.com.cn" target="_blank" rel="noopener">www.openlab.com.cn</a> 上提供了基于TCP的时间服务应用，该应用使用port为13。创建连接到此服务器的语句是：（A ）<br>A Socket s = new Socket(“<a href="http://www.openlab.com.cn”" target="_blank" rel="noopener">www.openlab.com.cn”</a>, 13);<br>B Socket s = new Socket(“<a href="http://www.openlab.com.cn" target="_blank" rel="noopener">www.openlab.com.cn</a> :13”);<br>C Socket s = accept(“<a href="http://www.openlab.com.cn”" target="_blank" rel="noopener">www.openlab.com.cn”</a>, 13);</p>
</li>
<li><p>创建一个TCP客户程序的顺序是：（DACBE ）<br>A 获得I/O流<br>B 关闭I/O流<br>C 对I/O流进行读写操作<br>D 建立socket<br>E 关闭socket</p>
</li>
<li><p>创建一个TCP服务程序的顺序是：（BCADEGF ）<br>A 创建一个服务线程处理新的连接<br>B 创建一个服务器socket<br>C 从服务器socket接受客户连接请求<br>D 在服务线程中，从socket中获得I/O流<br>E 对I/O流进行读写操作，完成与客户的交互<br>F 关闭socket<br>G 关闭I/O流</p>
</li>
<li><p>Java UDP编程主要用到的两个类型是：（ BD）<br>A UDPSocket<br>B DatagramSocket<br>C UDPPacket<br>D DatagramPacket</p>
</li>
<li><p>说说File类</p>
<p>它不属于 IO流，也不是用于文件操作的，它主要用于知道一个文件的属性，读写权限，大小等信息。</p>
</li>
<li><p>说说RandomAccessFile?</p>
<p>它在java.io包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是Object的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是RandomAccessFile既可以读文件，也可以写文件。 DataInputStream 和 DataOutStream有的方法，在RandomAccessFile中都存在。</p>
</li>
</ol>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList直接通过<code>transient Object[] elementData</code>一个Object的数组存储数据，默认初始容量是 10。每次扩容采用半倍扩容 <code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList是靠一个名为Node的数据结构来存储数据和前后元素的指针，和双向链表类似。first和last分别存储了第一个和最后一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>ArrayList 和 LinkedList 遍历时的时间复杂度</p>
<blockquote>
<p><a href="http://www.gcssloop.com/tips/arratlist-linkedlist-performance" target="_blank" rel="noopener">ArrayList与LinkedList遍历性能比较</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopList</span><span class="params">(List&lt;Integer&gt; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; lists.size(); i++) &#123;</span><br><span class="line">        Integer integer = lists.get(i);</span><br><span class="line">        <span class="comment">// TODO 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>List</th>
<th>for 循环时间复杂度</th>
<th>get(i)时间复杂度</th>
<th>总时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>LinkedList</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n2)</td>
</tr>
</tbody></table>
<p>在数据量为 10000 的情况下，for 循环的用时分别是 20ms 和 648ms，而使用迭代器和 ForEach 遍历时用时均在 4-6ms 之间。</p>
<p><strong>ForEach 循环底层使用的也是迭代器，所以和迭代器性能类似。</strong></p>
<p><strong>使用 迭代器(Iterator) 和 ForEach 遍历 List，不要使用传统的 For 循环。</strong></p>
<p><strong>LinkedList迭代器的next函数只是通过next指针快速得到下一个元素并返回。而get方法会从头遍历直到index下标。</strong></p>
</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote>
<p><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java泛型详解</a></p>
</blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>泛型是Java SE 1.5的新特性，<strong>泛型的本质</strong>是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li><p>泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</p>
</li>
<li><p>泛型的类型参数可以有多个</p>
</li>
<li><p>不能创建一个确切的泛型类型的数组，但可以创建通配符类型的泛型数组</p>
<p>编译错误：<code>List&lt;String&gt;[] list = new List&lt;String&gt;[10];</code></p>
<p>编译通过：<code>List&lt;?&gt;[] list = new List&lt;?&gt;[10];</code></p>
</li>
<li><p>不能利用类型参数直接创建实例（<code>E = new E();</code>）</p>
</li>
<li><p>不能对确切的泛型类型使用<code>instanceof</code>关键字</p>
<p>编译错误：<code>list instanceof ArrayList&lt;Integer&gt;</code></p>
<p>编译通过：<code>list instanceof ArrayList&lt;?&gt;</code></p>
</li>
<li><p>静态方法无法访问类上定义的泛型，所以静态方法要使用泛型的话，必须定义成泛型方法。</p>
</li>
<li><p>多接口限制：<code>&lt;T extends SomeClass &amp; interface1 &amp; interface2 &amp; interface3&gt;</code></p>
</li>
</ol>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java泛型只能用于在<strong>编译期间的静态类型检查</strong>，编译器生成的代码会擦除相应的类型信息，到了运行期间实际上JVM知道泛型所代表的具体类型。这样做的原因是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。</p>
<p>对于泛型代码，Java编译器实际上还会帮我们实现一个Bridge method。</p>
<ul>
<li><p>一条规律，”Producer Extends, Consumer Super”：</p>
<ul>
<li>“Producer Extends” – 如果你需要一个只读List，用它来produce T，那么使用<code>? extends T</code>。</li>
<li>“Consumer Super” – 如果你需要一个只写List，用它来consume T，那么使用<code>? super T</code>。</li>
<li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li>
</ul>
</li>
<li><p>方法上是否定义泛型和类上是否定义没有必然的联系</p>
</li>
<li><p>在Java集合类框架中泛型被广泛应用</p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<p>Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method。</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象。</p>
<p>反射：程序在运行状态中，可以动态加载一个只有名称的类，加载完类之后，在堆内存中，就产生了一个 Class 类型的对象，这个对象就包含了这个类完整的结构信息，通过这个对象我们可以看到类的结构。这个对象就像一面镜子，所以我们形象的称之为——反射</p>
<h3 id="反射能做什么？"><a href="#反射能做什么？" class="headerlink" title="反射能做什么？"></a>反射能做什么？</h3><p>代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等，JDBC原生代码注册驱动，hibernate 的实体类，Spring 的 AOP 等等都有反射的实现。通过反射运行配置文件内容，通过反射越过泛型检查。</p>
<ul>
<li>RTTI（Run-Time Type Identification 运行时类型识别）和反射之间的区别在于，RTTI 编译器在编译时打开和检查.class文件，反射在运行时打开和检查.class文件</li>
<li>获取 Class 类对象有三种方法，使用 Class.forName 静态方法、使用 .class 方法、使用类对象的 getClass() 方法。</li>
<li>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</li>
<li>Method 类的 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式Native 版本一开始启动快，但是随着运行时间变长，速度变慢。Java 版本一开始加载慢，但是随着运行时间变长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口设计规范"><a href="#接口设计规范" class="headerlink" title="接口设计规范"></a>接口设计规范</h3><ol>
<li><p>字段类型统一使用 String 类型，参数和返回值都使用 String 类型。Boolean类型一律使用1/0来表示。</p>
<p>使用此接口的用户，对方可能是Java，也可能是VB6，也可能是C#，不要使用某种编程语言的特定类型，比较好的一种方式是，参数和返回值都使用string类型，这样基本上的编程语言都能支持。</p>
</li>
<li><p>响应数据统一格式：code、msg、data。</p>
</li>
<li><p>接口路径中需要加入版本号信息（使用 v1、v2 依次递推）</p>
</li>
<li><p>分页数据中必须包含：</p>
<p>recordCount: 当前页记录数<br>totalCount: 总记录数<br>pageNo: 当前页码<br>pageSize: 每页大小<br>totalPage: 总页数</p>
</li>
</ol>
<h3 id="支付接口的设计"><a href="#支付接口的设计" class="headerlink" title="支付接口的设计"></a>支付接口的设计</h3><blockquote>
<p><a href="https://www.cnblogs.com/vianzhang/p/7603184.html" target="_blank" rel="noopener">支付网关的设计</a></p>
<p><a href="https://blog.csdn.net/think2017/article/details/79820786" target="_blank" rel="noopener">聚合支付系统设计</a></p>
</blockquote>
<p>聚合支付平台的核心，就是怎么合理的去管理接入的各种支付SDK，从官网下载的 SDK，不做任何逻辑修改，就直接放到项目的目录中使用，这样做虽然开发成本很低，但弊端颇多：</p>
<ol>
<li>首先要说的就是不易维护，各支付SDK代码结构、风格不一样，后期维护成本高；</li>
<li>代码各自为政，没有统一的调用方法；</li>
<li>配置分散，无法集中维护系统配置项；</li>
<li>无法提供统一有效的日志数据等</li>
</ol>
<p>因此，首先定义一个Interface，然后每次接入新的支付方式的过程，其实就是实现该Interface的过程。</p>
<p>通常情况下，一种支付方式有一个class来实现，但面对一种支付方式提供了多种支付场景，比如微信（提供了公众号支付、APP支付、扫码支付、H5支付、小程序支付、微信免密代扣等）、中国银联（提供了PC网关支付、WAP支付、APP支付、银联云闪付等），建议针对每种不同的支付场景，都有单独的class来实现，理由如下：</p>
<ul>
<li>不同的支付场景，程序执行的流程也不一样，比如中国银联PC网关支付，是需要将支付报文通过客户端浏览器表单POST给银联支付网关，跳转至银联支付网页进行支付，而银联APP支付则是通过curl将支付报文提交给银联支付网关，再将其返回的tn码返回给商户APP，商户APP凭该tn码发起支付交易；</li>
<li>对订单系统的订单支付方式展示更加准确，分配给商户不同购物平台（PC端、H5端、APP）的支付方式id是唯一的。如果商户系统不同支付场景所申请的商户号不一样，则需要在推送至财务系统的支付方式也不能重复，否则无法对账；</li>
<li>支付类的代码逻辑只关注于自身的支付逻辑处理，不引入额外的判断流程。</li>
</ul>
<p>那么这时候就有一个很头疼的问题，代码冗余。大部分第三方支付，虽然提供了不同支付场景，但基础接口都是一样的，只是部分参数不同，或支付流程上面的少许差别。这时候就要考虑好以第三方支付平台为单位来封装一个支付抽象类，实现对第三方支付平台的所有api对接，不涉及到商户系统的业务流程，比如微信支付，创建一个WechatDriver抽象类</p>
<p>有了支付抽象类，针对每一种支付方法，都可以继承该抽象类，并拥有自己的独立的支付流程，比如：微信app支付，可以创建一个 WechatAppDriver 支付子类，支付子类调用抽象类提供的各种底层api，来实现支付、查询、退款等功能。</p>
<p>支付Interface、支付抽象类、支付子类三种支付类，它们之间的关系如下：</p>
<p><img data-src="https://img-blog.csdn.net/20180404181515932" alt=""></p>
<p>对上图做简要说明，PaymentHandlerInterface是所有支付类的接口，WechatPayment是所有微信支付类的基类，WechatAPPPayment、WechatJSAPIPayment、WechatNativePayment都是提供支付服务的支付类，都需要继承WechatPayment并实现PaymentHandlerInterface接口。同理，系统如果需要接入银联在线支付，那么就需要按照开发文档实现一个ChinaPayPayment做为银联在线支付的基类，然后分别开发出具体支付场景的支付类，比如ChinaPayAPPPayment(银联app支付)、ChinaPayWAPPayment(银联wap支付)、ChinaPayPCPayment(银联pc支付)，这三个支付类需要继承ChinaPayPayment并实现PaymentHandlerInterface接口。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="无限级数据库设计"><a href="#无限级数据库设计" class="headerlink" title="无限级数据库设计"></a>无限级数据库设计</h4><blockquote>
<p><a href="https://www.phpbloger.com/index.php/article/50.html" target="_blank" rel="noopener">mysql（多级分销）无限极数据库设计方法</a></p>
<p><a href="http://www.php.cn/mysql-tutorials-369214.html" target="_blank" rel="noopener">数据库表设计-邻接表、路径枚举、嵌套集、闭包表</a></p>
</blockquote>
<h5 id="采用邻接表的设计方式"><a href="#采用邻接表的设计方式" class="headerlink" title="采用邻接表的设计方式"></a>采用<strong>邻接表</strong>的设计方式</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment <span class="keyword">COMMENT</span> <span class="string">'自增ID'</span>,</span><br><span class="line">    parentid <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">'父节点ID'</span>,</span><br><span class="line">    username <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COMMENT</span> <span class="string">'密码'</span></span><br><span class="line">    ……</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查询一个节点的所有后代</p>
<p>方式一：定义 SQL 函数递归查询</p>
<blockquote>
<p><a href="https://www.cnblogs.com/franson-2016/p/6873233.html" target="_blank" rel="noopener">MySQL递归查询树状表的子节点、父节点</a></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="string">`getChildList`</span>(rootId <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> idList <span class="built_in">VARCHAR</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> idTemp <span class="built_in">VARCHAR</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">SET</span> idTemp = <span class="keyword">CAST</span>(rootId <span class="keyword">AS</span> <span class="built_in">CHAR</span>);</span><br><span class="line">  WHILE idTemp IS NOT NULL <span class="keyword">DO</span></span><br><span class="line">	<span class="keyword">IF</span> (idList <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>) <span class="keyword">THEN</span></span><br><span class="line">	  <span class="keyword">SET</span> idList = <span class="keyword">CONCAT</span>(idList,<span class="string">','</span>,idTemp);</span><br><span class="line">	ELSE</span><br><span class="line">	  <span class="keyword">SET</span> idList = <span class="keyword">CONCAT</span>(idTemp);</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">GROUP_CONCAT</span>(<span class="keyword">id</span>) <span class="keyword">INTO</span> idTemp <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">WHERE</span> FIND_IN_SET(parentid,idTemp)&gt;<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">  RETURN idList;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p><a href="https://blog.csdn.net/dream_broken/article/details/69554303" target="_blank" rel="noopener">mysql之使用find_in_set和group_concat组合递归函数时数据不全</a></p>
</blockquote>
<p>group_concat 是有长度限制的，超过限制时会导致数据不全。</p>
<p>方式二：使用共用表表达式递归查询（8.0 的版本才支持 WITH）</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/with.html" target="_blank" rel="noopener">WITH语法（公用表表达式）</a></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte(<span class="keyword">id</span>, parentid, username, <span class="string">`level`</span>) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span>, parentid, username, <span class="number">0</span> <span class="keyword">AS</span> <span class="string">`level`</span> <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">WHERE</span> parentid = <span class="number">4</span></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> u.id, u.parentid, u.username, ce.<span class="string">`level`</span> + <span class="number">1</span> <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">AS</span> u </span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> cte <span class="keyword">AS</span> ce</span><br><span class="line">    <span class="keyword">ON</span> u.parentid = ce.id</span><br><span class="line">)<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cte；</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询一个节点的祖先节点</p>
<p>方式一：定义 SQL 函数递归查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="string">`getParentList`</span>(rootId <span class="built_in">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">DECLARE</span> idList <span class="built_in">varchar</span>(<span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">DECLARE</span> idTemp <span class="built_in">varchar</span>(<span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">SET</span> idTemp = <span class="keyword">CAST</span>(rootId <span class="keyword">as</span> <span class="built_in">CHAR</span>);</span><br><span class="line">		WHILE idTemp is not null <span class="keyword">DO</span></span><br><span class="line">			<span class="keyword">IF</span> (idList <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>) <span class="keyword">THEN</span></span><br><span class="line">				<span class="keyword">SET</span> idList = <span class="keyword">concat</span>(idTemp,<span class="string">','</span>,idList);</span><br><span class="line">			ELSE</span><br><span class="line">				<span class="keyword">SET</span> idList = <span class="keyword">concat</span>(idTemp);</span><br><span class="line">			<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">			<span class="keyword">SELECT</span> <span class="keyword">group_concat</span>(parentid) <span class="keyword">INTO</span> idTemp <span class="keyword">FROM</span> user_role <span class="keyword">where</span> FIND_IN_SET(<span class="keyword">id</span>,idTemp)&gt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">	  RETURN idList;</span><br><span class="line">	<span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>方式二：使用共用表表达式递归查询（8.0 的版本才支持 WITH）</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/with.html" target="_blank" rel="noopener">WITH语法（公用表表达式）</a></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> <span class="keyword">RECURSIVE</span> cte(<span class="keyword">id</span>, parentid, username, <span class="string">`level`</span>) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span>, parentid, username, <span class="number">0</span> <span class="keyword">AS</span> <span class="string">`level`</span> <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">6</span></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> u.id, u.parentid, u.username, ce.<span class="string">`level`</span> - <span class="number">1</span>  <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">AS</span> u </span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> COMMENT_CTE <span class="keyword">AS</span> ce　　</span><br><span class="line">	<span class="keyword">ON</span> ce.parentid = u.id <span class="keyword">where</span> ce.id &lt;&gt; ce.parentid</span><br><span class="line">)<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cte;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="路径枚举"><a href="#路径枚举" class="headerlink" title="路径枚举"></a>路径枚举</h5><p>路径枚举是一个由连续的直接层级关系组成的完整路径。如”1/4/7”,其中 1 是 4 的直接父亲，这也就意味着 1 是 7 的祖先。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment <span class="keyword">COMMENT</span> <span class="string">'自增ID'</span>,</span><br><span class="line">    <span class="keyword">path</span> <span class="built_in">int</span> <span class="keyword">COMMENT</span> <span class="string">'节点路径'</span>,</span><br><span class="line">    username <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COMMENT</span> <span class="string">'密码'</span></span><br><span class="line">    ……</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查询一个节点的所有后代</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">AS</span> u <span class="keyword">WHERE</span> u.path <span class="keyword">LIKE</span> <span class="string">'1/%'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询一个节点的祖先节点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">AS</span> u <span class="keyword">WHERE</span> <span class="string">'1/3/5/7/'</span> <span class="keyword">LIKE</span> u.path + <span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>路径枚举的缺点:</strong></p>
<p>　　1、数据库不能确保路径的格式总是正确或者路径中的节点确实存在(中间节点被删除的情况，没外键约束)。</p>
<p>　　2、要依赖高级程序来维护路径中的字符串，并且验证字符串的正确性的开销很大。</p>
<p>　　3、VARCHAR的长度很难确定。无论VARCHAR的长度设为多大，都存在不能够无限扩展的情况。</p>
<p><strong>路径枚举的优点:</strong></p>
<p>​    1、 查询父子节点的 SQL 语句简单</p>
<p>​    2、 能够很方便地根据节点的层级排序，因为通过比较字符串长度就能知道层级的深浅</p>
<h5 id="嵌套集"><a href="#嵌套集" class="headerlink" title="嵌套集"></a>嵌套集</h5><p>嵌套集解决方案是存储子孙节点的信息，而不是节点的直接祖先。我们使用两个数字来编码每个节点，表示这个信息。可以将这两个数字称为nsleft和nsright。这些数字和 当前节点的主键ID 的值并没有任何关联。</p>
<p>nsleft值的确定：nsleft 的数值小于该节点所有后代的nsleft和nsright。</p>
<p>nsright值的确定：nsright 的值大于该节点所有后代的nsleft和nsright。</p>
<p>也就是当前节点的（nsleft，nsright）要包含其所有子孙节点的（nsleft，nsright）</p>
<p>确定值的方式是对树进行一次深度优先遍历，在逐层深入的过程中依次递增地分配nsleft的值，并在返回时依次递增地分配nsright的值。</p>
<ul>
<li><p>查询一个节点的所有后代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT u2.* FROM &#96;user&#96; AS u1 JOIN &#96;user&#96; AS u2 ON u2.neleft BETWEEN u1.nsleft AND u1.nsright WHERE u1.id &#x3D; 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询一个节点的祖先节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT u2.* FROM &#96;user&#96; AS u1 JOIN &#96;user&#96; AS u2 ON u1.nsleft BETWEEN u2.nsleft AND u2.nsright WHERE u1.id &#x3D; 7;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>嵌套集的优点:</strong></p>
<p>​    1、 查询父子节点的 SQL 语句简单</p>
<p>​    2、 当删除一个节点造成数值不连续时，并不会对树的结构产生任何影响。</p>
<p><strong>嵌套集的缺点:</strong></p>
<p>　　1、插入操作比较麻烦</p>
<h5 id="闭包表"><a href="#闭包表" class="headerlink" title="闭包表"></a>闭包表</h5><p>闭包表是解决分层存储一个简单而又优雅的解决方案，它记录了表中所有的节点关系，并不仅仅是直接的父子关系。在闭包表的设计中，额外创建了一张tree_paths的表(空间换取时间)，它包含祖先，后代两列。</p>
<p>可以优化闭包表来使它更方便地查询直接父亲节点或者子节点： 在 tree_paths 表中添加一个 path_length 字段。一个节点的自我引用的path_length 为0，到它直接子节点的path_length 为1，再下一层为2，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tree_paths (</span><br><span class="line">	ancestor    int COMMENT &#39;祖先ID&#39;,</span><br><span class="line">　　descendant int COMMENT &#39;后代ID&#39;,</span><br><span class="line">	path_length int COMMENT &#39;代际层数&#39;</span><br><span class="line">    ……</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查询一个节点的所有后代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT u.* FROM &#96;user&#96; AS u INNER JOIN tree_paths t on c.id &#x3D; t.descendant WHERE t.ancestor &#x3D; 4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询一个节点的祖先节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT u.* FROM &#96;user&#96; AS u INNER JOIN tree_paths t on c.id &#x3D; t.ancestor WHERE t.descendant &#x3D; 4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入新节点</p>
<p>要插入一个新的叶子节点，比如 6 的一个子节点，应首先插入一条自己到自己的关系，然后搜索 tree_paths 表中后代是 6 的节点，增加这些节点和新插入节点的“祖先一后代”关系（假设新节点 ID 为8）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO tree_paths (ancestor, descendant) SELECT t.ancestor, 8 FROM tree_paths AS t WHERE t.descendant &#x3D; 6 UNION ALL SELECT 8, 8;</span><br></pre></td></tr></table></figure>

<p>要删除一颗完整的子树，比如 4 和它所有的后代，可删除所有在 tree_paths 表中后代为 4 的行，以及那些以4 的后代为后代的行。</p>
</li>
</ul>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>设计</th>
<th>表数量</th>
<th>查询子</th>
<th>查询树</th>
<th>插入</th>
<th>删除</th>
<th>引用完整性</th>
</tr>
</thead>
<tbody><tr>
<td>邻接表</td>
<td>1</td>
<td>简单</td>
<td>简单</td>
<td>简单</td>
<td>简单</td>
<td>是</td>
</tr>
<tr>
<td>枚举路径</td>
<td>1</td>
<td>简单</td>
<td>简单</td>
<td>简单</td>
<td>简单</td>
<td>否</td>
</tr>
<tr>
<td>嵌套集</td>
<td>1</td>
<td>困难</td>
<td>简单</td>
<td>困难</td>
<td>困难</td>
<td>否</td>
</tr>
<tr>
<td>闭包表</td>
<td>2</td>
<td>简单</td>
<td>简单</td>
<td>简单</td>
<td>简单</td>
<td>是</td>
</tr>
</tbody></table>
<p>　　1、邻接表是最方便的设计，并且很多软件开发者都了解它。并且在递归查询的帮助下，使得邻接表的查询更加高效。</p>
<p>　　2、枚举路径能够很直观地展示出祖先到后代之间的路径，但由于不能确保引用完整性，使得这个设计比较脆弱。枚举路径也使得数据的存储变得冗余。</p>
<p>　　3、嵌套集是一个聪明的解决方案，但不能确保引用完整性，并且只能使用于查询性能要求较高，而其他要求一般的场合使用它。</p>
<p>　　4、闭包表是最通用的设计，并且最灵活，易扩展，并且一个节点能属于多棵树，能减少冗余的计算时间。但它要求一张额外的表来存储关系，是一个空间换取时间的方案。</p>
<h4 id="MySQL中派生表、临时表、公共表、子查询的区别"><a href="#MySQL中派生表、临时表、公共表、子查询的区别" class="headerlink" title="MySQL中派生表、临时表、公共表、子查询的区别"></a>MySQL中派生表、临时表、公共表、子查询的区别</h4><ol>
<li><p>公用表表达式CTE(Common Table Expression)是一个命名的临时结果集，仅在单个SQL语句(例如SELECT，INSERT，UPDATE或DELETE)的执行范围内存在。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> customers_in_usa <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        customerName, state</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        customers</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        country = <span class="string">'USA'</span></span><br><span class="line">) <span class="keyword">SELECT</span> </span><br><span class="line">    customerName</span><br><span class="line"> <span class="keyword">FROM</span></span><br><span class="line">    customers_in_usa</span><br><span class="line"> <span class="keyword">WHERE</span></span><br><span class="line">    state = <span class="string">'CA'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生表是从SELECT语句返回的虚拟表。与子查询不同，派生表必须具有别名，以便稍后在查询中引用其名称。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    customerName</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        customerName, state</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        <span class="keyword">user</span></span><br><span class="line">	<span class="keyword">WHERE</span> country = <span class="string">'USA'</span>) customers_in_usa</span><br><span class="line"><span class="keyword">WHERE</span> state = <span class="string">'CA'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>临时表是一种特殊类型的表，它允许您存储一个临时结果集，可以在单个会话中多次重用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> customers_in_usa</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	customerName, state</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	<span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> country = <span class="string">'USA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> customers_in_usa;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子查询是嵌套在另一个查询(如SELECT，INSERT，UPDATE或DELETE)中的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    customerName</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	customers</span><br><span class="line"><span class="keyword">WHERE</span> state = <span class="string">'CA'</span> <span class="keyword">AND</span> <span class="keyword">id</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	customers</span><br><span class="line"><span class="keyword">WHERE</span> country = <span class="string">'USA'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><h4 id="什么是数据库执行计划"><a href="#什么是数据库执行计划" class="headerlink" title="什么是数据库执行计划"></a>什么是数据库执行计划</h4><p>执行计划，简单的来说，是SQL语句在数据库中执行时的表现情况，即数据库是如何执行SQL语句的。通常用于SQL性能分析、优化等场景。在MySQL使用 explain 关键字来查看SQL的执行计划。</p>
<h4 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h4><p><strong>Table 8.1 EXPLAIN Output Columns</strong></p>
<table>
<thead>
<tr>
<th>Column</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id" target="_blank" rel="noopener"><code>id</code></a></td>
<td>查询顺序</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type" target="_blank" rel="noopener"><code>select_type</code></a></td>
<td>查询类型，用于区分普通查询、联合查询、子查询等复杂的查询</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table" target="_blank" rel="noopener"><code>table</code></a></td>
<td>查询的表</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions" target="_blank" rel="noopener"><code>partitions</code></a></td>
<td>使用的哪个分区,需要结合表分区才能看到</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type" target="_blank" rel="noopener"><code>type</code></a></td>
<td>访问类型</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys" target="_blank" rel="noopener"><code>possible_keys</code></a></td>
<td>可能用到的索引,如果是多个索引以逗号隔开</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key" target="_blank" rel="noopener"><code>key</code></a></td>
<td>实际用到的索引,保存的是索引的名称,如果是多个索引以逗号隔开</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len" target="_blank" rel="noopener"><code>key_len</code></a></td>
<td>索引长度，表示索引所使用的字节数</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref" target="_blank" rel="noopener"><code>ref</code></a></td>
<td>和索引做比较的列，全表扫描的话，值为null</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows" target="_blank" rel="noopener"><code>rows</code></a></td>
<td>扫描行数</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered" target="_blank" rel="noopener"><code>filtered</code></a></td>
<td>满足条件的记录数占总记录数的百分比。</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra" target="_blank" rel="noopener"><code>Extra</code></a></td>
<td>额外信息</td>
</tr>
</tbody></table>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id越大优先级越高，越先被执行。id相同时，从上至下顺序执行。</p>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><table>
<thead>
<tr>
<th></th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>简单查询，不使用union或子查询等</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含任何复杂的子部分时，最外层查询就显示为 <code>PRIMARY</code></td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在<code>select</code>或 <code>where</code>字句中包含的子查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td><code>from</code>字句中包含的查询，derived：衍生，派生</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION；<br />若UNION包含在 FROM子句的子查询中，外层SELECT将被标记为：DERIVED</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT被标记为：UNION RESULT</td>
</tr>
</tbody></table>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>访问类型，SQL查询优化中一个很重要的指标，结果值从好到坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<table>
<thead>
<tr>
<th></th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ALL</td>
<td>全表扫描</td>
</tr>
<tr>
<td>2</td>
<td>index</td>
<td>使用扫描，index与ALL区别为index类型只遍历索引树</td>
</tr>
<tr>
<td>3</td>
<td>range</td>
<td>索引范围扫描<br />常见于between、&lt;、&gt;，IN等的查询</td>
</tr>
<tr>
<td>4</td>
<td>ref</td>
<td>非唯一索引扫描</td>
</tr>
<tr>
<td>5</td>
<td>eq_ref</td>
<td>唯一索引扫描<br />通常出现在多表的 join 查询<br />表示对于前表的每一个结果, 都只能匹配到后表的一行结果</td>
</tr>
<tr>
<td>6</td>
<td>const</td>
<td>使用主键或者唯一索引，匹配的结果只有一条记录。</td>
</tr>
<tr>
<td>7</td>
<td>system</td>
<td>表中只有一行记录（等于系统表），这是const类型的特例</td>
</tr>
<tr>
<td>8</td>
<td>NULL</td>
<td>不用访问表或者索引就可以直接得到结果</td>
</tr>
</tbody></table>
<h6 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h6><p>此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t3,t4 where t3.id&#x3D;t4.accountid;</span><br></pre></td></tr></table></figure>

<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>这个列可以显示的信息非常多，有几十种，常用的有：</p>
<ol>
<li>Using index 使用覆盖索引 </li>
<li>Using where 使用了where子句来过滤结果集 </li>
<li>Using filesort 使用文件排序，排序时无法使用到索引时，就会出现这个。MySQL无法利用索引完成的顺序操作称为“文件排序”。常见于order by和group by语句中 。</li>
<li>Using temporary 使用了临时表，一般出现于排序, 分组和多表join的情况, 查询效率不高, 建议优化.</li>
</ol>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>对查询性能影响最大的几个列是：</p>
<ul>
<li>select_type：查询类型</li>
<li>type：连接使用了何种类型</li>
<li>rows：查询数据需要查询的行</li>
<li>key：查询真正使用到的索引</li>
<li>extra：额外的信息</li>
</ul>
<p>尽量让自己的SQL用上索引，避免让extra里面出现file sort(文件排序),using temporary(使用临时表)。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ol>
<li><p>对索引列进行了运算，无法使用索引。由于MySQL不像Oracle那样支持函数索引，即使函数内字段有索引，也会直接全表扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ID FROM SENDLOG WHERE TO_DAYS(NOW())-TO_DAYS(GMT_CREATE) &gt; 7;</span><br><span class="line">-- 优化后sql：</span><br><span class="line">select id from sendlog where gmt_create &lt; now() - 7;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据类型不一致，导致没法用索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM SENDLOG where result &#x3D; 1;</span><br><span class="line">-- 优化后sql：</span><br><span class="line">SELECT * FROM SENDLOG where result &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h4><ol>
<li><p>最左匹配原则</p>
<p>在组合索引中，b+树的数据项是复合的数据结构，比如(name,age,sex)，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了。</p>
</li>
<li><p>经常需要排序、分组和联合操作的字段需要建立索引</p>
<p>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，需要建立索引。</p>
</li>
<li><p>选择区分度高的列作为索引</p>
<p>区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少</p>
</li>
</ol>
<h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><ol>
<li><p>为什么加索引能够优化查询速度？</p>
<p>因为索引的本质就是一种优化查询速度的数据结构，MySQL中使用B+树实现。</p>
</li>
<li><p>MySQL为什么使用B+树来实现索引？</p>
<p>常见的能够提高查询速度的数据结构有：哈希表，完全平衡二叉树，B树，B+树。</p>
<p>哈希表对于范围查找的情况不理想，而对于树的情况，由于树的高度越低，所需要的磁盘IO次数就越少，故B+树性能更好，而且对于范围查找也适用。</p>
<p>对于B+树，一个节点所含元素的个数一般是操作系统中一页的大小的倍数。一般一页的大小为4kb，MySQL InnoDB的页大小为16kb</p>
</li>
<li><p>为什么不建议写 select *，结合索引给出优化案例</p>
<p>B+树非叶子节点只存索引值，叶子节点既存索引值也存数据值。当需要查找的字段添加了索引后，查找到索引后即可得到其数据值，不用再查找对应的记录来获取数据值了。</p>
<p>第一，如果仅仅需要获取一个字段值，并且这个值有索引，比如用户的Id主键索引，就不需要查询两次表，直接获取就行了。</p>
<p>第二，对于不必要的字段，比如文章内容这种占用空间比较大的字段会占用较大的网络带宽。</p>
</li>
<li><p>如何清空一张一百万级数据表里的一个字段？</p>
<p>使用主键索引分批执行。</p>
</li>
<li><p>如何对一张一百万级数据表进行快速分页查询？</p>
<p>利用覆盖索引，查询的语句中只包含索引列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM product WHERE id &gt;&#x3D; (select id from product limit 866613, 1) limit 20</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ol>
<li><p>什么是事务</p>
<p><strong>事务是</strong>数据库中的<strong>一个</strong>单独的<strong>执行单元</strong>。是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p>
</li>
<li><p>事务的四大特性 ACID</p>
<ul>
<li><p><strong>原子性（Atomicity）</strong></p>
<p>原子性是指<strong>事务是一个不可分割的工作单位</strong>，事务中的操作要么都发生，要么都不发生。</p>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_37997523/article/details/83188003" target="_blank" rel="noopener">怎么理解数据库事务的一致性</a></p>
</blockquote>
<p>事务执行前后，数据库系统保持一致性状态。即系统从一个一致的状态转换到另一个一致状态。</p>
<p>一致性是指<strong>数据处于一种语义上的有意义且正确的状态</strong>。一致性是对数据<strong>可见性</strong>的约束，保证在一个事务中的多次操作的数据中间状态对其他事务是不可见的。</p>
<p>原子性和一致性的的侧重点不同：<strong>原子性关注状态</strong>，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性<strong>关注数据的可见性</strong>，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。</p>
<p>在未提交读的隔离级别下，会造成脏读，这就是因为一个事务读到了另一个事务操作内部的数据。ACID中的一致性描述的是一个最理想的事务应该是怎样的，是一个强一致性状态，如果要做到这点，需要使用排它锁把事务排成一队，即 Serializable 的隔离级别，这样性能就大大降低了。现实是骨感的，所以使用不同隔离级别来破坏一致性，以获取更好的性能。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不影响其它事务的执行。</p>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<p>事务一旦提交，对数据库数据的修改便是永久性的。即使系统或介质发生故障时，其修改也将持久化保存在数据库中。</p>
</li>
</ul>
</li>
<li><p>事务的并发问题</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000012626590" target="_blank" rel="noopener">MySQL高并发事务问题及解决方案</a></p>
</blockquote>
<ol>
<li><p><strong>赃读</strong>（Dirty Read）</p>
<p>一个事务读取到了另外一个事务没有提交的数据。</p>
</li>
<li><p><strong>不可重复读</strong>（Nonrepeatable Read）</p>
<p>在同一事务中，两次读取同一数据，得到不同内容。</p>
</li>
<li><p><strong>幻读</strong>（Phantom Read）</p>
<p>同一事务中，用同样的操作读取两次，得到的记录数不相同。</p>
</li>
<li><p><strong>丢失更新</strong>（Lost Update）</p>
<ol>
<li>第一类丢失更新: A事务撤销时, 把已经提交的B事务的更新数据覆盖了。</li>
<li>第二类丢失更新: A事务覆盖B事务已经提交的数据，造成B事务所做跟新丢失。</li>
</ol>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000012669504" target="_blank" rel="noopener">不可重复读与幻读的区别</a>：</p>
<ul>
<li><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
</li>
<li><p>不可重复读主要是说多次读取一条记录, 发现该记录中某些列值被修改过。</p>
</li>
<li><p>幻读主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。(可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="noopener">MySQL官方文档对 Phantom Rows 的介绍</a>)</p>
</li>
</ul>
</li>
<li><p>事务的隔离级别</p>
<blockquote>
<p><a href="https://blog.csdn.net/u012739535/article/details/76855728" target="_blank" rel="noopener">数据库并发事务中的问题与解决方案</a></p>
<p><a href="https://blog.csdn.net/qq_21993785/article/details/81077318" target="_blank" rel="noopener">数据库并发事务详解</a></p>
</blockquote>
<ol>
<li><p>READ_UNCOMMITTED<strong>（读未提交）</strong></p>
<ul>
<li><p>读事务不阻塞其他读事务和写事务，未提交的写事务阻塞其他写事务但不阻塞读事务。</p>
</li>
<li><p>可以防止更新丢失，但不能防止脏读、不可重复读、幻读。</p>
</li>
<li><p>可以通过“排他写锁”实现。</p>
</li>
</ul>
</li>
<li><p>READ_COMMITTED <strong>（读已提交）</strong></p>
<ul>
<li>读事务不阻塞其他读事务和写事务，未提交的写事务阻塞其他读事务和写事务。</li>
<li>可以防止更新丢失、脏读，但不能防止不可重复读、幻读。</li>
<li>可以通过“瞬间共享读锁”和“排他写锁”实现。</li>
</ul>
</li>
<li><p>REPEATABLE_READ<strong>（可重复读）</strong></p>
<ul>
<li>以操作同一行数据为前提，读事务阻塞其他写事务但不阻塞读事务，未提交的写事务阻塞其他读事务和写事务。</li>
<li>可以防止更新丢失、脏读、不可重复读，但不能防止幻读。</li>
<li>可以通过“共享读锁”和“排他写锁”实现。</li>
</ul>
</li>
<li><p>SERIALIZABLE<strong>（可序列化）</strong></p>
<ul>
<li>事务序列化执行，只能一个接着一个地执行，不能并发执行。</li>
<li>可以防止更新丢失、脏读、不可重复读、幻读。</li>
<li>如果仅仅通过“行级锁”是无法实现事务序列化的，需使用“表级锁”。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>回滚覆盖</th>
<th>脏读</th>
<th>不可重复读</th>
<th>提交覆盖</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>x</td>
<td>可能发生</td>
<td>可能发生</td>
<td>可能发生</td>
<td>可能发生</td>
</tr>
<tr>
<td>读已提交</td>
<td>x</td>
<td>x</td>
<td>可能发生</td>
<td>可能发生</td>
<td>可能发生</td>
</tr>
<tr>
<td>可重复读</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>可能发生</td>
</tr>
<tr>
<td>串行化</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
<p>大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。</p>
<p>MySQL 默认的事务隔离级别为 REPEATABLE_READ</p>
</li>
</ol>
<h3 id="Spring声明式事务管理"><a href="#Spring声明式事务管理" class="headerlink" title="Spring声明式事务管理"></a>Spring声明式事务管理</h3><blockquote>
<p><a href="https://segmentfault.com/a/1190000011743233" target="_blank" rel="noopener">Spring声明式事务管理之一：五大属性分析</a></p>
<p><a href="https://segmentfault.com/a/1190000014957011" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a></p>
</blockquote>
<h4 id="Spring五个事务隔离级别"><a href="#Spring五个事务隔离级别" class="headerlink" title="Spring五个事务隔离级别"></a>Spring五个事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>使用数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>读未提交</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>读已提交</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>可重复度</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>序列化</td>
</tr>
</tbody></table>
<h4 id="Spring七个事务传播行为"><a href="#Spring七个事务传播行为" class="headerlink" title="Spring七个事务传播行为"></a>Spring七个事务传播行为</h4><blockquote>
<p><a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">Spring事务传播行为详解</a></p>
<p><a href="https://blog.csdn.net/pml18710973036/article/details/58607148" target="_blank" rel="noopener">spring 事务传播行为实例分析</a></p>
<p><a href="https://blog.csdn.net/soonfly/article/details/70305683" target="_blank" rel="noopener">【Spring学习34】Spring事务(4)：事务属性之7种传播行为</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>事务传播行为类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>事务传播行为定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。</p>
<h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p>TransactionDefinition 接口中定义了1个表示超时时间的常量TIMEOUT_DEFAULT 默认是30秒，使用getTimeout()方法可以获取到超时时间，单位是秒。Spring事务超时时间，是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<h4 id="是否只读"><a href="#是否只读" class="headerlink" title="是否只读"></a>是否只读</h4><p>事务管理的只读属性是指对事务性资源进行只读操作或者是可读写操作。所谓事务性资源就是指那些被事务管理的资源，如数据源、JMS 资源，以及自定义的事务性资源等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在TransactionDefinition 中以 boolean 类型来表示该事务是否只读，使用方法isReadOnly()来判断事务是否是只读的。</p>
<h4 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h4><p>通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则正常提交事务。我们可以根据需要人为控制事务在抛出某些未检查异常时仍然提交事务，或者在抛出某些已检查异常时回滚事务。<br>Transactional注解中有4个属性通过设置系统异常类和自定义异常类来自定义回滚规则。</p>
<ul>
<li><strong>@Transactional(rollbackFor=RuntimeException.class)</strong><br>用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则事务回滚。</li>
<li><strong>@Transactional(rollbackForClassName=”RuntimeException”)</strong><br>用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚</li>
<li><strong>@Transactional(noRollbackFor=RuntimeException.class)</strong><br>用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚</li>
<li><strong>@Transactional(noRollbackForClassName=RuntimeException.class)</strong><br>用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><p>@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能</p>
</li>
<li><p>可以在接口上使用 @Transactional  注解，但是只有当你设置了基于接口的代理时它才生效。因为<strong>注解是不能继承的</strong>。</p>
</li>
<li><p>当你在Spring中配置了 <code>&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code> 时，那么代理类就是基于接口的代理。 </p>
<p>当你在Spring中配置了 <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code> 时，那么代理类就是基于类的代理。</p>
</li>
<li><p>事务传播机制只适用于不同bean之间方法的调用，如果一个bean中的两个方法互相调用并不会使用到事务传播。</p>
<p>原因解释：spring的事物管理通过AOP代理来实现， 根据aop的思想，不可能在具体类上直接处理事务，而是通过代理类来处理，代理类在调用具体类的方法来实现，methodA通过this调用methodB，那么此时相当于调用methodB时是没有经过代理类的调用，因此spring无法对事物的传播行为做处理。</p>
</li>
</ul>
<h4 id="Transactional-失效的情况"><a href="#Transactional-失效的情况" class="headerlink" title="@Transactional 失效的情况"></a>@Transactional 失效的情况</h4><ol>
<li><p>@Transactional 只能应用到 public 方法才有效</p>
</li>
<li><p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题：</p>
<p>若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略。</p>
</li>
</ol>
<h3 id="数据库的锁机制"><a href="#数据库的锁机制" class="headerlink" title="数据库的锁机制"></a>数据库的锁机制</h3><blockquote>
<p><a href="https://blog.csdn.net/canot/article/details/53815294" target="_blank" rel="noopener">MySqL 事务与锁的深入学习笔记</a></p>
</blockquote>
<p><strong>分类</strong></p>
<p>按锁类型划分，可分为共享锁、排他锁<br>按锁的粒度划分，可分为表级锁、行级锁、页级锁<br>按使用机制划分，可分为乐观锁、悲观锁</p>
<p><strong>共享锁与排他锁</strong></p>
<p>共享锁（Shared locks, S-locks）<br>也叫读锁、S锁。在没有检测到排他锁时才可以加共享锁，其他事务可以并发读取该数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。<br>用法：<code>SELECT ... LOCK IN SHARE MODE;</code></p>
<p>排他锁（Exclusive locks, X-locks）<br>也叫写锁、X锁。在没有加任何锁时才可以加排他锁，加上排他锁后，其他事务不能再加任何类型的锁，直到已释放该排他锁。<br>用法：<code>SELECT ... FOR UPDATE;</code></p>
<p>InnoDB还有两个表锁：<br>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁。<br>意向排他锁（IX）：表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。<br>意向锁是InnoDB自动加的，不需要用户干预。</p>
<p><strong>级锁、行级锁、页级锁</strong>   </p>
<p>表级锁：直接锁定整张表，在锁定期间，其他进程无法对该表进行写操作。如果你是写锁，则其他进程读也不允许。特点是：开销小、加锁快，不会出现死锁。锁定粒度最大，发生锁冲突的概率最高，并发度最低。<br>MYISAM存储引擎采用的就是表级锁。</p>
<p>行级锁：仅对指定的记录进行加锁，这样其他进程还是可以对同一个表中的其他记录进行操作。特点：开销大，加锁慢，会出现死锁。锁定的粒度最小，发生锁冲突的概率最低，并发度也最高。<br>InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。</p>
<p>页级锁：一次锁定相邻的一组记录。开销和加锁时间介于表级锁和行级锁之间；会出现死锁；锁定粒度也介于表级锁和行级锁之间，并发度一般。</p>
<p><strong>乐观锁、悲观锁</strong></p>
<p>无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p>
<p>悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。锁如其名，它指的是对数据被外界修改持悲观态度，即假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源。因此，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。</p>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还会降低了并行性。</p>
<p>乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它对数据被外界修改持乐观态度，即假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上锁定，乐观锁使用由程序逻辑控制的技术来避免可能出现的并发问题。</p>
<p>乐观锁的实现方式有两种，第一种是使用版本号，第二种是使用时间戳。</p>
<p>基于<strong>数据版本记录机制</strong>的实现：即每行数据多一个版本字段，当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，将数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 </p>
<p>使用时间戳的实现：依然是为每条数据增加一个时间戳字段，在更新提交的时候，将当前数据库中数据的时间戳与第一次读取的时间戳进行比对，如果一致则更新，否则认为是过期数据。</p>
<p>乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MySQL InnoDB存储引擎，实现的是基于<strong>多版本的并发控制协议</strong>——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p>
<p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p>
<p>快照读：简单的select操作，属于快照读，不加锁。</p>
<p><code>select * from table where ?;</code></p>
<p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert into table values (…);</span><br><span class="line">update table set ? where ?;</span><br><span class="line">delete from table where ?;</span><br></pre></td></tr></table></figure>

<p>除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p>
<h4 id="三级加锁协议、两段锁协议"><a href="#三级加锁协议、两段锁协议" class="headerlink" title="三级加锁协议、两段锁协议"></a>三级加锁协议、两段锁协议</h4><blockquote>
<p><a href="https://blog.csdn.net/u012739535/article/details/76855728" target="_blank" rel="noopener">数据库并发事务中的问题与解决方案</a></p>
</blockquote>
<p>三级加锁协议也称为三级封锁协议，是为了保证正确的调度事务的并发操作，事务在对数据库对象加锁、解锁时必须遵守的一种规则。在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p>
<p><strong>一级封锁协议</strong><br>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。<br>一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。<br>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。</p>
<p><strong>二级封锁协议</strong><br>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。<br>二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p>
<p><strong>三级封锁协议</strong><br>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。<br>三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。</p>
<p>上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。</p>
<p><strong>两段锁协议</strong></p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>两段锁协议规定在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁；而且在释放一个封锁之后，事务不再获得任何其他封锁。就是说加锁和解锁分为两个阶段进行。</p>
<blockquote>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。<br>Xlock(A)…Slock(B)…Slock(C)…unlock(A)…unlock(C)…unlock(B)<br>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度:<br>Xlock(A)…unlock(A)…Slock(B)…unlock(B)…Slock(C)…unlock(C)</p>
</blockquote>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>加锁协议</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>一级加锁协议</td>
</tr>
<tr>
<td>读已提交</td>
<td>二级加锁协议</td>
</tr>
<tr>
<td>可重复读</td>
<td>三级加锁协议</td>
</tr>
<tr>
<td>串行化</td>
<td>两段锁协议</td>
</tr>
</tbody></table>
<p>注：封锁协议和隔离级别并不是严格对应的。</p>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><strong>产生死锁的四个必要条件：</strong></p>
<p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p><strong>避免死锁</strong></p>
<p>（1） 按同一顺序访问对象。(注：避免出现循环)<br>（2） 避免事务中的用户交互。(注：减少持有资源的时间，较少锁竞争)<br>（3） 保持事务简短并处于一个批处理中。(注：减少持有资源的时间)<br>（4） 使用较低的隔离级别。(注：使用较低的隔离级别比使用较高的隔离级别持有共享锁的时间更短)<br>（5） 使用基于行版本控制的隔离级别。<br>（6） 使用绑定连接。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote>
<p><a href="https://blog.csdn.net/evankaka/article/details/44153709" target="_blank" rel="noopener">Java多线程学习（吐血超详细总结） - Evankaka的专栏- CSDN博客</a></p>
<p><a href="https://segmentfault.com/a/1190000015744840" target="_blank" rel="noopener">高并发下Java多线程编程基础</a></p>
</blockquote>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>线程和进程一样分为五个阶段（状态）：创建、就绪、运行、阻塞、终止。</p>
<p>多进程是指操作系统能同时运行多个任务（程序）。</p>
<p>多线程是指在同一程序中有多个顺序流在执行。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li>主线程：JVM调用程序main()所产生的线程。</li>
<li>当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。</li>
<li>后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</li>
<li>前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</li>
</ul>
<h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>在 java 中要想实现多线程，一般有 3 种手段：继承 Thread 类、实现 Runnable 接口和实现 Callable 接口。</p>
<p>推荐使用 Runnable 方式的原因：</p>
<ul>
<li>可以避免 java 单继承的限制</li>
<li>线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承 Thread 的类</li>
</ul>
<p>注意：</p>
<ul>
<li><p>start() 方法调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p>
</li>
<li><p>start 方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。</p>
</li>
<li><p>启动线程的唯一方法就是通过 Thread 类的 start() 方法，所有的多线程代码都是通过运行Thread的start()方法来运行的。</p>
</li>
<li><p>Thread 类实际上也是实现了 Runnable 接口的类。</p>
</li>
<li><p>main 方法其实也是一个线程，是程序的主线程。</p>
</li>
<li><p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。</p>
</li>
</ul>
<h3 id="多线程同步的实现方式"><a href="#多线程同步的实现方式" class="headerlink" title="多线程同步的实现方式"></a>多线程同步的实现方式</h3><p>Java 中提供了 3 中实现同步机制的方法：</p>
<ol>
<li><p>synchronized 关键字</p>
<p>Java 中每个对象都有一个对象锁与之相关联。</p>
<p>synchronized 关键字主要有两种用法：同步方法和同步代码块。此外，该关键字还可以作用于静态方法，类或者某个实例</p>
</li>
<li><p>wait 与 notify 方法</p>
<p>在 synchronized 代码被执行期间，线程可以调用对象的 wait 方法，释放对象锁，进入等待状态，并且可以调用 notify 方法或者 notifyAll 方法通知正在等待的其他线程。</p>
</li>
<li><p>Lock 接口</p>
<p>JDK 5 增加了 Lock 接口以及它的一个实现类 ReentrantLock（重入锁），提供了一系列方法来实现多线程的同步。</p>
<ol>
<li><p>lock()</p>
<p>以阻塞的方式获取锁，也就是说，如果获取到了锁，立即放回；如果别的线程持有锁，当前线程等待，知道获取锁后返回。</p>
</li>
<li><p>unlock()</p>
<p>释放锁。</p>
</li>
<li><p>tryLock()</p>
<p>以非阻塞的方式获取锁。只是尝试性地去获取一下锁，如果获取到锁，立即返回 true，否则，立即返回 false。</p>
</li>
<li><p>tryLock(long tieout, TimeUnit unit)</p>
<p>如果获取了锁，立即返回 true，否则会等待参数给定的时间单元，在等待的过程中，如果获取了锁，就返回 true，如果等待超时，返回 false。</p>
</li>
<li><p>lockInterruptibly()</p>
<p>如果获取了锁，立即返回；如果没有获取到锁，当前线程处于休眠状态，知道获取锁，或者当前线程被别的线程中断（会收到 InterruptedException 异常）。它与 lock() 方法最大的区别在于如果 lock() 方法获取不到锁，会一直处于阻塞状态，且会忽略 interrupt() 方法。</p>
</li>
</ol>
</li>
</ol>
<p><strong>synchronized 与 Lock 的区别</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>存在层次</td>
<td>Java的关键字<br />托管给JVM执行，故为隐士锁</td>
<td>是一个接口<br />代码控制，故为显示锁</td>
</tr>
<tr>
<td>锁的获取</td>
<td>阻塞式获取<br />假设A线程获得锁，B线程等待。<br />如果A线程阻塞，B线程会一直等待</td>
<td>可非阻塞式获取<br />Lock有多个锁获取的方式<br />可以尝试获得锁，线程可以不用一直等待</td>
</tr>
<tr>
<td>锁的释放</td>
<td>1、以获取锁的线程执行完同步代码，释放锁 <br />2、线程执行发生异常时，jvm会让线程释放锁</td>
<td>在finally中必须释放锁，不然容易造成线程死锁</td>
</tr>
<tr>
<td>锁状态</td>
<td>无法判断</td>
<td>可以判断</td>
</tr>
<tr>
<td>锁类型</td>
<td>可重入<br />不可中断<br />非公平</td>
<td>可重入<br />可中断<br />可公平可非公平</td>
</tr>
<tr>
<td>性能</td>
<td>少量同步时性能较高</td>
<td>大量同步时性能高</td>
</tr>
</tbody></table>
<p><strong>锁类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>可重入锁</td>
<td>广义上的可重入锁指的是可重复可递归调用的锁，<br />在外层使用锁之后，在内层仍然可以使用，并且不发生死锁<br />（前提得是同一个对象或者class），这样的锁就叫做可重入锁。<br /><a href="https://blog.csdn.net/rickiyeat/article/details/78314451" target="_blank" rel="noopener">究竟什么是可重入锁？</a></td>
</tr>
<tr>
<td>可中断锁</td>
<td>在等待获取锁过程中可中断</td>
</tr>
<tr>
<td>公平锁</td>
<td>按等待获取锁的线程的等待时间进行获取，<br />等待时间长的具有优先获取锁权利</td>
</tr>
<tr>
<td>读写锁</td>
<td>对资源读取和写入的时候拆分为2部分处理，<br />读的时候可以多线程一起读，写的时候必须同步地写</td>
</tr>
</tbody></table>
<p>synchronized 在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p>
<p>当竞争不是很激烈的时候Synchronized使用的是轻量级锁或者偏向锁，这两种锁都能有效减少轮询或者阻塞的发生，相比与Lock仍旧要将未获得锁的线程放入等待队列阻塞带来的上下文切换的开销，此时Synchronized效率会高些，当竞争激烈的时候Synchronized会升级为重量级锁，由于Synchronized的出队速度相比Lock要慢，所以Lock的效率会更高些。一般对于数据结构设计或者框架的设计都倾向于使用Lock而非Synchronized。</p>
<p>Lock是基于AQS（AbstractQueuedSynchronizer）实现的，AQS的基础又是CAS。</p>
<ul>
<li><p>AQS</p>
<p>AQS(AbstractQueuedSynchronizer 队列同步器)，AQS是JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架。它使用了一个int成员变量表示同步状态，使用 CAS 设置当前状态。CountDownLatch、FutureTask、Semaphore、ReentrantLock等都有一个内部类是这个抽象类的子类。AQS是JUC同步器的基石。</p>
</li>
<li><p>CAS<br>CAS（Compare And Swap 比较并交换）指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。</p>
<p>简单介绍一下这个指令的操作过程：CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。（这段描述引自《Java并发编程实践》）</p>
<p>CAS的目的：利用CPU的CAS指令，同时借助JNI（Java Native Interface）来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C（java.util.concurrent）都是建立在CAS之上的，因此相对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>
<p>要实现无锁（lock-free）的非阻塞算法有多种实现方法，其中CAS（比较与交换，Compare and swap）是一种有名的无锁算法。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>接下来通过<strong>源代码来看 AtomicInteger 具体是如何实现</strong>的原子操作。</p>
<p>　　首先看 value 的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>　　volatile 修饰的 value 变量，保证了变量的可见性。</p>
<p>　　incrementAndGet() 方法，下面是具体的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>　　通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做 compareAndSet 操作，直到成功为止，也就是修改的根本在 compareAndSet 方法里面，compareAndSet()方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　compareAndSet()方法调用的compareAndSwapInt()方法的声明如下，是一个native方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, intvar5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>　　compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet 所做的为调用 Sun 的 UnSafe 的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是 CPU 的 CAS 指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。</p>
<p>　　类似的，还有 decrementAndGet() 方法。它和 incrementAndGet() 的区别是将 value 减 1，赋值给next 变量。</p>
<p>​      AtomicInteger 中还有 getAndIncrement() 和 getAndDecrement() 方法，他们的实现原理和上面的两个方法完全相同，区别是返回值不同，前两个方法返回的是改变之后的值，即 next。而这两个方法返回的是改变之前的值，即 current。还有很多的其他方法，就不列举了。</p>
</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img data-src="https://img-blog.csdn.net/20150309140927553" alt=""></p>
<ol>
<li>新建状态（New）：新创建了一个线程对象。</li>
<li>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待 OS 调度以获取CPU的使用权。</li>
<li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li>
<li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ol>
<li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li>
</ol>
</li>
<li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol>
<li><p>调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。</p>
<p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。<br>每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。<br>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。<br>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类中的三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p>
</li>
<li><p>线程睡眠：<code>Thread.sleep(long millis)</code>方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep() 平台移植性好。</p>
</li>
<li><p>线程等待：Object 类中的 wait() 方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是 Object 类中的方法，行为等价于调用 wait(0) 。</p>
</li>
<li><p>线程让步：<code>Thread.yield()</code> 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>
</li>
<li><p>线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的 join() 方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
</li>
<li><p>线程唤醒：Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个 notifyAll()，唤醒在此对象监视器上等待的所有线程。</p>
</li>
</ol>
<h3 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h3><ol>
<li><p>stop() 方法</p>
<p>使用 Thread.stop() 方法（已废弃）来终止线程时，它会释放已经锁定的所有监视资源。这可能会导致程序执行的不确定性，并且这种问题很难定位。</p>
</li>
<li><p>使用退出标志终止线程</p>
<p>设一个boolean类型的推出标志 exit，并通过设置这个标志为true或false来控制while循环是否退出，并使用 volatile，这个关键字的目的是使exit同步，也就是说在同一时刻只能由一个线程来修改exit的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean exit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        exit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!exit)&#123;</span><br><span class="line">			……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：虽然通过调用上例中的 stop 方法可以终止线程，但当线程处于非运行状态时，这种方式就不可用了。</p>
</li>
<li><p>使用 interrupt() 方法</p>
<p>当 interrupt 方法被调用时，会抛出 InterruptedException 异常，可以通过在 run() 方法中捕获这个异常来让线程安全退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			……</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote>
<p><a href="https://blog.csdn.net/u011974987/article/details/51027795" target="_blank" rel="noopener">Java 四种线程池的用法分析</a></p>
<p><a href="https://www.hollischuang.com/archives/2888" target="_blank" rel="noopener">Java中线程池，你真的会用吗？</a></p>
<p><a href="https://mp.weixin.qq.com/s/-89-CcDnSLBYy3THmcLEdQ" target="_blank" rel="noopener">深入源码分析Java线程池的实现原理</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1109643" target="_blank" rel="noopener">Java 线程池原理分析</a></p>
<p><a href="https://segmentfault.com/a/1190000015808897" target="_blank" rel="noopener">如何优雅的使用和理解线程池</a></p>
</blockquote>
<p>Java通过Executors提供四种线程池，分别为：</p>
<ol>
<li><p>newCachedThreadPool</p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p>newFixedThreadPool </p>
<p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
</li>
<li><p>newScheduledThreadPool</p>
<p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
<li><p>newSingleThreadExecutor</p>
<p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
</li>
</ol>
<p>阿里巴巴Java开发手册中不允许通过Executors静态工厂构建，使用Executors创建线程池，由于底层使用的是阻塞队列 LinkedBlockingQueue，当创建的线程过多时，会导致OOM(OutOfMemory ,内存溢出)，所以一般直接调用ThreadPoolExecutor构造一个就可以了。<a href="https://www.hollischuang.com/archives/2888" target="_blank" rel="noopener">Java中线程池，你真的会用吗？</a></p>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p><img data-src="https://ask.qcloudimg.com/http-save/yehe-1679307/y2d8zjqe0h.jpeg?imageView2/2/w/1620" alt=""></p>
<p>如上图，最顶层的接口 Executor 仅声明了一个方法execute。ExecutorService 接口在其父类接口基础上，声明了包含但不限于shutdown、submit、invokeAll、invokeAny 等方法。至于 ScheduledExecutorService 接口，则是声明了一些和定时任务相关的方法，比如 schedule和scheduleAtFixedRate。线程池的核心实现是在 ThreadPoolExecutor 类中，我们使用 Executors 调用newFixedThreadPool、newSingleThreadExecutor和newCachedThreadPool等方法创建线程池均是 ThreadPoolExecutor 类型。</p>
<p>比较重要的几个类：</p>
<ol>
<li><p>ExecutorService： </p>
<p>真正的线程池接口。</p>
</li>
<li><p>ScheduledExecutorService： </p>
<p>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</p>
</li>
<li><p>ThreadPoolExecutor： </p>
<p>ExecutorService的默认实现。</p>
</li>
<li><p>ScheduledThreadPoolExecutor： </p>
<p>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的实现类。</p>
</li>
</ol>
<h4 id="核心类-ThreadPoolExecutor"><a href="#核心类-ThreadPoolExecutor" class="headerlink" title="核心类 ThreadPoolExecutor"></a>核心类 ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>如上所示，核心构造方法的参数即核心参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>线程池所能维护的最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>空闲线程的存活时间</td>
</tr>
<tr>
<td>unit</td>
<td>参数keepAliveTime的时间单位，有7种取值，对应在TimeUnit类中有7种静态属性<br />天、小时、分钟、秒、毫秒、微妙、纳秒</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列，用于缓存未执行的任务</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂。可通过工厂为新建的线程设置更有意义的名字</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常</td>
</tr>
</tbody></table>
<p><strong>线程创建规则</strong></p>
<p>在 Java 线程池实现中，线程池所能创建的线程数量受限于 corePoolSize 和 maximumPoolSize 两个参数值。线程的创建时机则和 corePoolSize 以及 workQueue 两个参数有关。下面列举一下线程创建的4个规则（线程池中无空闲线程），如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>条件</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>线程数 &lt; corePoolSize</td>
<td>创建新线程</td>
</tr>
<tr>
<td>2</td>
<td>线程数 ≥ corePoolSize，且 workQueue 未满</td>
<td>缓存新任务</td>
</tr>
<tr>
<td>3</td>
<td>corePoolSize ≤ 线程数 ＜ maximumPoolSize，且 workQueue 已满</td>
<td>创建新线程</td>
</tr>
<tr>
<td>4</td>
<td>线程数 ≥ maximumPoolSize，且 workQueue 已满</td>
<td>使用拒绝策略处理</td>
</tr>
</tbody></table>
<p><strong>资源回收</strong></p>
<p>考虑到系统资源是有限的，对于线程池超出 corePoolSize 数量的空闲线程应进行回收操作。进行此操作存在一个问题，即回收时机。目前的实现方式是当线程空闲时间超过 keepAliveTime 后，进行回收。除了核心线程数之外的线程可以进行回收，核心线程内的空闲线程也可以进行回收。回收的前提是 allowCoreThreadTimeOut 属性被设置为 true，通过<code>public void allowCoreThreadTimeOut(boolean)</code> 方法来设置该属性。</p>
<p><strong>排队策略</strong></p>
<p>如线程创建规则2所说，当线程数量大于等于 corePoolSize，workQueue 未满时，则缓存新任务。这里要考虑使用什么类型的容器缓存新任务，通过 JDK 文档介绍，我们可知道有3中类型的容器可供使用，分别是<code>同步队列</code>，<code>有界队列</code>和<code>无界队列</code>。对于有优先级的任务，这里还可以增加<code>优先级队列</code>。以上所介绍的4中类型的队列，对应的实现类如下：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SynchronousQueue</td>
<td>同步队列</td>
<td>该队列不存储元素<br />每个插入操作必须等待另一个线程调用移除操作<br />否则插入操作会一直阻塞</td>
</tr>
<tr>
<td>ArrayBlockingQueue</td>
<td>有界队列</td>
<td>基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>无界队列</td>
<td>基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>优先级队列</td>
<td>具有优先级的阻塞队列</td>
</tr>
</tbody></table>
<p><strong>拒绝策略</strong></p>
<p>当线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。Java 线程池提供了4 种拒绝策略实现类，如下：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>丢弃新任务，并抛出 RejectedExecutionException</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>不做任何操作，直接丢弃新任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列队首的元素，并执行新任务</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>由调用线程执行新任务</td>
</tr>
</tbody></table>
<p>以上4个拒绝策略中，AbortPolicy 是线程池实现类 ThreadPoolExecutor 所使用的策略。我们也可以通过方法<code>public void setRejectedExecutionHandler(RejectedExecutionHandler)</code>修改线程池拒绝策略。</p>
<p><strong>线程的创建与复用</strong></p>
<p>在线程池的实现上，线程的创建是通过线程工厂接口<code>ThreadFactory</code>的实现类来完成的。默认情况下，线程池使用<code>Executors.defaultThreadFactory()</code>方法返回的线程工厂实现类。当然，我们也可以通过</p>
<p> <code>public void setThreadFactory(ThreadFactory)</code>方法进行动态修改。具体细节这里就不多说了，并不复杂，大家可以自己去看下源码。</p>
<p>在线程池中，线程的复用是线程池的关键所在。这就要求线程在执行完一个任务后，不能立即退出。对应到具体实现上，工作线程在执行完一个任务后，会再次到任务队列获取新的任务。如果任务队列中没有任务，且 keepAliveTime 也未被设置，工作线程则会被一致阻塞下去。通过这种方式即可实现线程复用。</p>
<p>说完原理，再来看看线程的创建和复用的相关代码（基于 JDK 1.8），如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+----ThreadPoolExecutor.Worker.java</span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="comment">// 调用线程工厂创建线程</span></span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 实现了 Runnable 接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+----ThreadPoolExecutor.java</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环从任务队列中获取新任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行新任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程退出后，进行后续处理</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提交任务</strong></p>
<p>通常情况下，我们可以通过线程池的<code>submit</code>方法提交任务。被提交的任务可能会立即执行，也可能会被缓存或者被拒绝。任务的处理流程如下图所示：</p>
<p><img data-src="https://ask.qcloudimg.com/http-save/yehe-1679307/qk4c5bbfs0.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>上面的流程图不是很复杂，下面再来看看流程图对应的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+---- AbstractExecutorService.java</span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+---- ThreadPoolExecutor.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果工作线程数量 &lt; 核心线程数，则创建新线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加工作者对象</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存任务，如果队列已满，则 offer 方法返回 false。否则，offer 返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加工作者对象，并在 addWorker 方法中检测线程数是否小于最大线程数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 线程数 &gt;= 最大线程数，使用拒绝策略处理任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:  <span class="comment">//java中的goto语法。只能运用在break和continue后面。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 检测工作线程数与核心线程数或最大线程数的关系</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建工作者对象，细节参考上一节所贴代码</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 将 worker 对象添加到 workers 集合中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// 更新 largestPoolSize 属性</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 开始执行任务</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池的状态</strong></p>
<p>这些状态都和线程的执行密切相关：</p>
<p><img data-src="https://segmentfault.com/img/remote/1460000015808902?w=707&h=126" alt="img"></p>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p><img data-src="https://segmentfault.com/img/remote/1460000015808903?w=1033&h=406" alt=""></p>
<p><strong><code>execute()</code> 方法的处理流程：</strong></p>
<p><img data-src="https://segmentfault.com/img/remote/1460000015808904?w=754&h=310" alt="img"></p>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
<p>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<p><img data-src="https://segmentfault.com/img/remote/1460000015808905?w=500&h=293" alt="img"></p>
<p><strong>关闭线程池</strong></p>
<p>我们可以通过<code>shutdown</code>和<code>shutdownNow</code>两个方法关闭线程池。两个方法的区别在于，shutdown 会将线程池的状态设置为<code>SHUTDOWN</code>，同时该方法还会中断空闲线程。shutdownNow 则会将线程池状态设置为<code>STOP</code>，并尝试中断所有的线程。中断线程使用的是<code>Thread.interrupt</code>方法，未响应中断方法的任务是无法被中断的。最后，shutdownNow 方法会将未执行的任务全部返回。</p>
<p>调用 shutdown 和 shutdownNow 方法关闭线程池后，就不能再向线程池提交新任务了。对于处于关闭状态的线程池，会使用拒绝策略处理新提交的任务。</p>
<p><strong>Spring Boot 中使用线程池</strong></p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000015808897#articleHeader4" target="_blank" rel="noopener">SpringBoot 使用线程池</a></p>
</blockquote>
<p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费队列线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(value = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildConsumerQueueThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">"consumer-queue-thread-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),namedThreadFactory,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line"><span class="keyword">private</span> ExecutorService consumerQueueThreadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        consumerQueueThreadPool.execute(<span class="keyword">new</span> ConsumerQueueThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>
<p><strong>其他</strong></p>
<ul>
<li>线程池本质是一个hashSet。多余的任务会放在阻塞队列中。</li>
</ul>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><ul>
<li><p>interrupt()：不要以为它是中断某个线程！它只是线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出异常，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！</p>
<p>需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 </p>
</li>
<li><p>wait()</p>
<p>Object.wait()，与 Object.notify() 必须要与 synchronized(Obj) 一起使用，也就是wait与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内，否则会在运行时抛出”java.lang.IllegalMonitorStateException“异常。。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p>
</li>
</ul>
<h3 id="常见业务场景"><a href="#常见业务场景" class="headerlink" title="常见业务场景"></a>常见业务场景</h3><ol>
<li><p>应用世界自动跳转的实现</p>
</li>
<li><p>一个业务逻辑有很多次的循环，每次循环之间没有影响，比如验证1万条url路径是否存在，正常情况要循环1万次，逐个去验证每一条URL，这样效率会很低，假设验证一条需要1分钟，总共就需要1万分钟，有点恐怖。这时可以用多线程，将1万条URL分成50等份，开50个线程，没个线程只需验证200条，这样所有的线程执行完是远小于1万分钟的。</p>
</li>
<li><p>需要知道一个任务的执行进度，比如我们常看到的进度条，实现方式可以是在任务中加入一个整型属性变量(这样不同方法可以共享)，任务执行一定程度就给变量值加1，另外开一个线程按时间间隔不断去访问这个变量，并反馈给用户。</p>
</li>
</ol>
<h3 id="面试常见问题-1"><a href="#面试常见问题-1" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><ol>
<li><p>进程和线程的区别</p>
<p>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含多个线程。（进程是资源分配的最小单位）</p>
<p>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</p>
</li>
<li><p><strong>同步和异步的区别</strong></p>
<p>同步是阻塞模式，异步是非阻塞模式。</p>
<p>同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；</p>
<p>异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。这就是同步和异步。</p>
<p>事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。</p>
<p>同步和异步可以表现在很多方面，但是记住其关键在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。一般来说，可以通过多线程的方式来实现异步，但是千万记住不要将多线程和异步画上等号，异步只是宏观上的一个模式，采用多线程来实现异步只是一种手段，并且通过多进程的方式也可以实现异步。</p>
</li>
<li><p><strong>什么是阻塞？什么是非阻塞？</strong></p>
<p>阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p>
<p>非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。</p>
<p>这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。</p>
<p>同步和异步分别与阻塞和非阻塞是两组完全不同的概念。同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。</p>
</li>
<li><p><strong>什么是同步IO？什么是异步IO？</strong></p>
<blockquote>
<p>在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的：</p>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</p>
<p>An asynchronous I/O operation does not cause the requesting process to be blocked.</p>
</blockquote>
<p>从字面的意思可以看出，同步IO：即如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为：如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。</p>
<p>事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：</p>
<p>对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；</p>
<p>而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。</p>
<p>同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。</p>
<p>注意同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。而同步IO和异步IO模型是针对用户线程和内核的交互来说的。</p>
</li>
<li><p>wait和sleep的区别</p>
<ol>
<li>sleep() 是 Thread 类的方法，而 wait() 是 Object 的方法。</li>
<li>sleep方法没有释放锁，而wait方法释放了锁。</li>
<li>wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 </li>
</ol>
</li>
<li><p>sleep() 和 yield() 的区别</p>
<ol>
<li><p>sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>
</li>
<li><p>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。</p>
<p>另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 </p>
</li>
<li><p>sleep 方法声明抛出 InterruptedException，而 yield 方法没有声明任何异常。</p>
</li>
</ol>
</li>
<li><p>Thread.sleep() 与 Object.wait() 的区别</p>
<ol>
<li><p>原理不同</p>
<p>sleep 方法是 Thread 类的静态方法，是线程用来控制自身流程的。它会使此线程暂停执行一段时间，等到计时时间一到，此线程会自动“苏醒”。</p>
<p>wait 方法是 Object 类的方法，用于线程间的通信，它会使拥有该对象锁的进程等待，知道其他进程调用 notify 方法是才“醒来”。</p>
</li>
<li><p>对锁的处理机制不同</p>
<p>二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制；而sleep方法只是释放了对 CPU 的控制器，并不会释放锁。</p>
</li>
<li><p>使用区域不同</p>
<p>wait、notify 等方法必须在同步控制方法或者同步代码块中使用，而 sleep 可以在任何地方使用。</p>
</li>
</ol>
</li>
<li><p>三线程打印ABC</p>
<p>题目：建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。</p>
<p>思路：这个问题用Object的wait()，notify()就可以很方便的解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.multithread.wait;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPrinter2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">	  </span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line">    <span class="keyword">private</span> Object prev;   </span><br><span class="line">    <span class="keyword">private</span> Object self;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadPrinter2</span><span class="params">(String name, Object prev, Object self)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">        <span class="keyword">this</span>.prev = prev;   </span><br><span class="line">        <span class="keyword">this</span>.self = self;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;   </span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123;   </span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;   </span><br><span class="line">                    System.out.print(name);   </span><br><span class="line">                    count--;  </span><br><span class="line">                    </span><br><span class="line">                    self.notify();   </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">try</span> &#123;   </span><br><span class="line">                    prev.wait();   </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">        Object a = <span class="keyword">new</span> Object();   </span><br><span class="line">        Object b = <span class="keyword">new</span> Object();   </span><br><span class="line">        Object c = <span class="keyword">new</span> Object();   </span><br><span class="line">        MyThreadPrinter2 pa = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"A"</span>, c, a);   </span><br><span class="line">        MyThreadPrinter2 pb = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"B"</span>, a, b);   </span><br><span class="line">        MyThreadPrinter2 pc = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"C"</span>, b, c);   </span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">new</span> Thread(pa).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  <span class="comment">//确保按顺序A、B、C执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(pb).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        <span class="keyword">new</span> Thread(pc).start();   </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。</p>
</li>
<li><p>两个线程交替打印出100以内的奇数和偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dubbo.worldCup.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + cnt++);</span><br><span class="line">                        <span class="keyword">this</span>.notify();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">5</span></span><br><span class="line">…………………………</span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">96</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">97</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">98</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">99</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">100</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p><a href="https://www.cnblogs.com/pony1223/p/7608955.html" target="_blank" rel="noopener">JAVA设计模式总结之23种设计模式</a></p>
</blockquote>
<p><img data-src="https://images2017.cnblogs.com/blog/401339/201709/401339-20170928225241215-295252070.png" alt=""></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一般有 8 种：饿汉式（静态常量）、饿汉式（静态代码块）、懒汉式(线程不安全)、懒汉式(线程安全，同步方法)、懒汉式(线程安全，同步代码块)、双重校验锁、静态内部类、枚举</p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>线程安全</th>
<th>延迟加载</th>
<th>抵御反射攻击</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式（静态常量）</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>饿汉式（静态代码块）</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>懒汉式(线程不安全)</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>懒汉式(线程安全，同步方法)</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>懒汉式(线程安全，同步代码块)</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>双重校验锁</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>静态内部类</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>枚举</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<h4 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：基于 classloader 机制避免了多线程的同步问题。没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。</p>
<h4 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：基于 classloader 机制避免了多线程的同步问题。没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。</p>
<h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：懒加载。<br>缺点：线程不安全。</p>
<h4 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：懒加载， 线程安全。<br>缺点：加锁影响效率。</p>
<h4 id="懒汉式-线程安全，同步代码块"><a href="#懒汉式-线程安全，同步代码块" class="headerlink" title="懒汉式(线程安全，同步代码块)"></a>懒汉式(线程安全，同步代码块)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">               singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：懒加载， 解决效率问题。<br>缺点：存在线程安全问题。</p>
<h4 id="双重校验锁（DCL，即-double-checked-locking）"><a href="#双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双重校验锁（DCL，即 double-checked locking）"></a>双重校验锁（DCL，即 double-checked locking）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全且在多线程情况下能保持高性能。</p>
<p>缺点：由于JVM编译器的<a href="https://mp.weixin.qq.com/s?src=11&timestamp=1552554141&ver=1483&signature=JmbsFEDRnIJQwueG2QuOMFjXqS20v5f46WEEXm-ihMO4T8xymNheoGhBuO*qCN67WlFP9SoQIntPMnWzrwtT6aEi*mYtz8XB6a*W4GrFa5Er6LF6RVjJnsAam3TQta6D&new=1" target="_blank" rel="noopener"><strong>指令重排</strong>可能会导致线程不安全</a>。使用 volatile 修饰 singleton 可避免此问题。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：利用类加载机制避免了线程不安全，相对饿汉式增加了延迟加载能力，效率高。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：利用 enum 语法糖，JVM 会阻止获取枚举类的私有构造方法。使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被<strong>反序列化</strong>的时候，保证反序列的返回结果是同一对象</p>
<p>缺点：非懒加载。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a></p>
</blockquote>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p><strong>定义</strong></p>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p><strong>实例</strong></p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000015050674#articleHeader9" target="_blank" rel="noopener">简单工厂实例</a></p>
</blockquote>
<p><strong>应用</strong></p>
<ol>
<li><p>JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale</span></span></span><br><span class="line"><span class="function"><span class="params">locale)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java加密技术</p>
<p> 获取不同加密算法的密钥生成器:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGen=KeyGenerator.getInstance(<span class="string">"DESede"</span>);</span><br></pre></td></tr></table></figure>

<p> 创建密码器:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cipher cp=Cipher.getInstance(<span class="string">"DESede"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>优点：</p>
<p>1、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>2、实现简单</p>
<p>缺点：</p>
<p>1、增加产品，需要修改工厂类，不符合开放-封闭原则</p>
<p>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p><strong>定义</strong><br>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p>
<p><strong>实例</strong></p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000015050674#articleHeader15" target="_blank" rel="noopener">工厂方法模式实例</a></p>
</blockquote>
<p><strong>应用</strong></p>
<blockquote>
<p><a href="https://www.hollischuang.com/archives/1408" target="_blank" rel="noopener">设计模式（六）——JDK中的那些工厂方法</a></p>
</blockquote>
<ol>
<li><p>Collection中的iterator方法</p>
<p><code>java.util.Collection</code>接口中定义了一个抽象的<code>iterator()</code>方法，该方法就是一个工厂方法。</p>
<p>对于<code>iterator()</code>方法来说<code>Collection</code>就是一个根抽象工厂，下面还有<code>List</code>等接口作为抽象工厂，再往下有<code>ArrayList</code>等具体工厂。</p>
<p><code>java.util.Iterator</code>接口是根抽象产品，下面有<code>ListIterator</code>等抽象产品，还有<code>ArrayListIterator</code>等作为具体产品。</p>
<p>使用不同的具体工厂类中的<code>iterator</code>方法能得到不同的具体产品的实例。</p>
</li>
</ol>
<p>优点：</p>
<p>1、继承了简单工厂模式的优点</p>
<p>2、符合开放-封闭原则</p>
<p>缺点：</p>
<p>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p><strong>定义</strong><br>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。</p>
<p><strong>实例</strong></p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000015050674#articleHeader21" target="_blank" rel="noopener">抽象工厂模式实例</a></p>
</blockquote>
<p><strong>应用</strong></p>
<ol>
<li><p>jdk 中的数据库链接</p>
<p><img data-src="http://hi.csdn.net/attachment/201101/3/0_1294058833piFB.gif" alt=""></p>
<p>抽象工厂：Connection</p>
<p>具体工厂：MysqlCollectionImpl</p>
<p>抽象产品：Statement、PreparedStatement、CallableStatement、ResultSet</p>
<p>具体产品：MysqlStatement、MysqlPreparedStatement、MysqlCallableStatement、MysqlResultSet</p>
</li>
<li><p>在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。例如<strong>UIManager（swing外观）</strong></p>
</li>
</ol>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>定义</strong></p>
<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<p><strong>结构</strong><br>适配器模式包含如下角色：</p>
<ul>
<li>Target：目标抽象类</li>
<li>Adapter：适配器类</li>
<li>Adaptee：适配者类</li>
<li>Client：客户类</li>
</ul>
<p>适配器模式有对象适配器和类适配器两种实现：</p>
<p><strong>实例</strong></p>
<blockquote>
<p><a href="http://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">适配器模式| 菜鸟教程</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/54910430#t3" target="_blank" rel="noopener">模式原理</a></p>
</blockquote>
<p><strong>类的适配器模式</strong></p>
<ol>
<li><p>创建Target接口（目标抽象类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>创建源类 Adaptee（适配者类）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>创建适配器类 Adapter（适配器类）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标（客户类）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Target mAdapter = <span class="keyword">new</span> Adapter()；</span><br><span class="line">        mAdapter.Request（）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>背景：小成买了一个进口的电视机</li>
<li>冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容</li>
<li>解决方案：设置一个适配器，将插头输出的220V转变成110V</li>
</ul>
<ol>
<li><p>创建<strong>Target接口，期待得到的插头</strong>能将 220V 转换成 110V（目标抽象类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将220V转换成110V（原有插头（Adaptee）没有的）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建源类，原有的插头（适配者类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerPort220V</span></span>&#123;</span><br><span class="line">	<span class="comment">//原有插头只能接收220V</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive_220v</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建适配器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter220V</span> <span class="keyword">extends</span> <span class="title">PowerPort220V</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">//期待的插头要求调用 Convert_110v()，但原有插头没有</span></span><br><span class="line">    <span class="comment">//因此适配器补充上这个方法名</span></span><br><span class="line">    <span class="comment">//但实际上Convert_110v()只是调用原有插头的Receive_220v()方法的内容</span></span><br><span class="line">    <span class="comment">//所以适配器只是将Receive_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110v</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.Receive_220v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标（客户类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进口机器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImportedMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进口机器正常运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Adapter类调用所需要的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Target mAdapter220V = <span class="keyword">new</span> Adapter220V();</span><br><span class="line">        ImportedMachine mImportedMachine = <span class="keyword">new</span> ImportedMachine();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用户拿着进口机器插上适配器（调用Convert_110v()方法）</span></span><br><span class="line">        <span class="comment">//再将适配器插上原有插头（Convert_110v()方法内部调用Receive_220v()方法接收220V）</span></span><br><span class="line">        <span class="comment">//适配器只是个外壳，对外提供110V，但本质还是220V进行供电</span></span><br><span class="line">        mAdapter220V.Convert_110v();</span><br><span class="line">        mImportedMachine.Work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>对象的适配器模式</strong></p>
<p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。</p>
<ol>
<li><p>创建Target接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建源类（Adaptee）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建适配器类（Adapter）（不用继承而是委派）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 直接关联被适配类  </span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的适配者对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 这里是使用委托的方式完成特殊功能  </span></span><br><span class="line">        <span class="keyword">this</span>.adaptee.SpecificRequest();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要先创建一个适配者的对象作为参数  </span></span><br><span class="line">        Target mAdapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee())；</span><br><span class="line">        mAdapter.Request();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>应用</strong></p>
<p>Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><blockquote>
<p><a href="https://blog.csdn.net/zhshulin/article/details/38665187" target="_blank" rel="noopener">设计模式——装饰模式（Decorator）</a><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener">《JAVA与模式》之装饰模式</a></p>
</blockquote>
<p><strong>定义</strong></p>
<p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p>
<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述装饰（Decorator）模式的：<br>装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p>
<p><strong>结构</strong></p>
<p>装饰模式包含如下角色：</p>
<ul>
<li>Component: 抽象构件</li>
<li>ConcreteComponent: 具体构件</li>
<li>Decorator: 抽象装饰类</li>
<li>ConcreteDecorator: 具体装饰类</li>
</ul>
<p><strong>实例</strong></p>
<p>齐天大圣的例子：孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。</p>
<p>本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化。</p>
<p><img data-src="data:image/png;base64,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" alt="img"></p>
<ol>
<li><p>抽象构件角色“齐天大圣”接口定义了一个move()方法，这是所有的具体构件类和装饰类必须实现的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大圣的尊号</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TheGreatestSage</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体构件角色“大圣本尊”猢狲类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">TheGreatestSage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        System.out.println(<span class="string">"Monkey Move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象装饰角色“七十二变”</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">TheGreatestSage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TheGreatestSage sage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Change</span><span class="params">(TheGreatestSage sage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sage = sage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码</span></span><br><span class="line">        sage.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体装饰角色“鱼儿”</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">(TheGreatestSage sage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码</span></span><br><span class="line">        System.out.println(<span class="string">"Fish Move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>具体装饰角色“鸟儿”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(TheGreatestSage sage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码</span></span><br><span class="line">        System.out.println(<span class="string">"Bird Move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TheGreatestSage sage = <span class="keyword">new</span> Monkey();</span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        TheGreatestSage bird = <span class="keyword">new</span> Bird(sage);</span><br><span class="line">        TheGreatestSage fish = <span class="keyword">new</span> Fish(bird);</span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        <span class="comment">//TheGreatestSage fish = new Fish(new Bird(sage));</span></span><br><span class="line">        fish.move(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>“大圣本尊”是ConcreteComponent类，而“鸟儿”、“鱼儿”是装饰类。要装饰的是“大圣本尊”，也即“猢狲”实例。</p>
<p>上面的例子中，系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。</p>
<p>　　<img data-src="data:image/png;base64,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" alt="img"></p>
<p>如上图所示，大圣的变化首先将鸟儿的功能附加到了猢狲身上，然后又将鱼儿的功能附加到猢狲+鸟儿身上。　　</p>
<p><strong>透明性的要求</strong></p>
<p>装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。</p>
<p>用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿，而不是老孙，那就被老孙骗了，而这是不应当发生的。</p>
<p>下面的做法是对的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TheGreatestSage sage = <span class="keyword">new</span> Monkey();</span><br><span class="line">TheGreatestSage bird = <span class="keyword">new</span> Bird(sage);</span><br></pre></td></tr></table></figure>

<p>而下面的做法是不对的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Monkey sage = <span class="keyword">new</span> Monkey();</span><br><span class="line">Bird bird = <span class="keyword">new</span> Bird(sage);</span><br></pre></td></tr></table></figure>

<p><strong>半透明的装饰模式</strong></p>
<p>然而，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。</p>
<p>这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TheGreatestSage sage = <span class="keyword">new</span> Monkey();</span><br><span class="line">Bird bird = <span class="keyword">new</span> Bird(sage);</span><br><span class="line">bird.fly();</span><br></pre></td></tr></table></figure>

<p>半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。</p>
<p>装饰模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。</p>
<p>理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。</p>
<p>装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。</p>
<p><img data-src="data:image/png;base64,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" alt="img"></p>
<p>在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。</p>
<p>显然，半透明的装饰模式实际上就是处于适配器模式与装饰模式之间的灰色地带。如果将装饰模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰模式倒可以成为这种合并后的“包装模式”的代表。</p>
<p><strong>InputStream类型中的装饰模式</strong></p>
<p>InputStream类型中的装饰模式是半透明的。为了说明这一点，不妨看一看作装饰模式的抽象构件角色的InputStream的源代码。这个抽象类声明了九个方法，并给出了其中八个的实现，另外一个是抽象方法，需要由子类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是作为装饰模式的抽象装饰角色FilterInputStream类的源代码。可以看出，FilterInputStream的接口与InputStream的接口是完全一致的。也就是说，直到这一步，还是与装饰模式相符合的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是具体装饰角色PushbackInputStream的源代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看源码，你会发现，这个装饰类提供了额外的方法unread()，这就意味着PushbackInputStream是一个半透明的装饰类。换言之，它破坏了理想的装饰模式的要求。如果客户端持有一个类型为InputStream对象的引用in的话，那么如果in的真实类型是 PushbackInputStream 的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。但是如果客户端必须使用这个方法，就必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。但是，这个类型转换意味着客户端必须知道它拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰模式的原始用意。</p>
<p>现实世界与理论总归是有一段差距的。纯粹的装饰模式在真实的系统中很难找到。一般所遇到的，都是这种半透明的装饰模式。</p>
<p>下面是使用I/O流读取文件内容的简单操作示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 流式读取文件</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>)</span><br><span class="line">                    )</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//读取文件内容</span></span><br><span class="line">            <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[dis.available()];</span><br><span class="line">            dis.read(bs);</span><br><span class="line">            String content = <span class="keyword">new</span> String(bs);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。</p>
<p><strong>应用</strong></p>
<p><strong>设计模式在JAVA I/O库中的应用</strong></p>
<p>装饰模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。</p>
<p>由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I/O库的基本模式。</p>
<p>Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。</p>
<p><img data-src="data:image/png;base64,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" alt="img"></p>
<p>根据上图可以看出：</p>
<ul>
<li><p><strong>抽象构件(Component)角色：</strong>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p>
</li>
<li><p><strong>具体构件(ConcreteComponent)角色：</strong>由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</p>
</li>
<li><p><strong>抽象装饰(Decorator)角色：</strong>由FilterInputStream扮演。它实现了InputStream所规定的接口。</p>
</li>
<li><p><strong>具体装饰(ConcreteDecorator)角色：</strong>由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</p>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html#proxy" target="_blank" rel="noopener">代理模式</a></p>
</blockquote>
<p><strong>定义</strong><br>代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象<strong>控制</strong>对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p>
<p><strong>结构</strong><br>代理模式包含如下角色：</p>
<ul>
<li>Subject: 抽象主题角色</li>
<li>Proxy: 代理主题角色</li>
<li>RealSubject: 真实主题角色</li>
</ul>
<p><strong>实例</strong></p>
<p>代理模式分为静态代理和动态代理两种。</p>
<p>区别在于:静态代理在编译期确定代理对象，在程序运行前代理类的.class文件就已经存在了;而动态代理在运行期，通过反射机制创建代理对象。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><blockquote>
<p><a href="https://segmentfault.com/a/1190000009235245#articleHeader4" target="_blank" rel="noopener">静态代理</a></p>
<p><a href="https://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener">代理模式</a></p>
</blockquote>
<p>我们将创建一个 <em>Image</em> 接口和实现了 <em>Image</em> 接口的实体类。<em>ProxyImage</em> 是一个代理类，减少 <em>RealImage</em> 对象加载的内存占用。</p>
<p><em>ProxyPatternDemo*，我们的演示类使用 *ProxyImage</em> 来获取要加载的 <em>Image</em> 对象，并按照需求进行显示。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/proxy_pattern_uml_diagram.jpg" alt=""></p>
<ol>
<li><p>创建一个接口（抽象主题角色）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实现接口的实体类（真实主题角色）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实现接口的实体类（代理主题角色）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <em>ProxyImage</em> 来获取 <em>RealImage</em> 类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test_10mb.jpg"</span>);</span><br><span class="line">        <span class="comment">// 图像将从磁盘加载       </span></span><br><span class="line">        image.display();</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 图像不需要从磁盘加载       </span></span><br><span class="line">        image.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行程序，输出结果：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loading test_10mb.jpg</span><br><span class="line">Displaying test_10mb.jpg</span><br><span class="line"></span><br><span class="line">Displaying test_10mb.jpg</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>优点：可以做到在不修改目标对象的功能前提下，对目标功能扩展。</p>
<p>缺点：代理类和委托类实现相同的接口，同时要实现相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><ul>
<li>java.lang.reflect.Proxy:生成动态代理类和对象；</li>
<li>java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现对真实角色的代理访问。</li>
</ul>
<p>JDK生成代理只需要使用 Proxy 的 newProxyInstance 方法，但是该方法需要接收三个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class [] interfaces, InvocationHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>注意该方法是在Proxy类中是静态方法，每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。</p>
<ul>
<li>ClassLoader loader：指定当前目标对象使用类加载器，用null表示默认类加载器</li>
<li>Class [] interfaces：需要实现的接口数组</li>
<li>InvocationHandler handler：调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入</li>
</ul>
<p>java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法负责集中处理动态代理类上的所有方法调用。</span></span><br><span class="line"><span class="comment">// 第一个参数既是代理类实例，第二个参数是被调用的方法对象，第三个是调用参数。</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>代码示例:</strong></p>
<ol>
<li>接口：Subject.java（抽象主题角色）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sellBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>真实对象：RealSubject.java（真实主题角色）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sellBooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖书"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"张三"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理器对象：MyInvocationHandler.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为需要处理真实角色，所以要把真实角色传进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Subject realSubject ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Subject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy     代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method    正在调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args      方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用代理类"</span>);</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"sellBooks"</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> invoke = (<span class="keyword">int</span>)method.invoke(realSubject, args);</span><br><span class="line">            System.out.println(<span class="string">"调用的是卖书的方法"</span>);</span><br><span class="line">            <span class="keyword">return</span> invoke ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            String string = (String) method.invoke(realSubject,args) ;</span><br><span class="line">            System.out.println(<span class="string">"调用的是说话的方法"</span>);</span><br><span class="line">            <span class="keyword">return</span>  string ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用端：Client.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实对象</span></span><br><span class="line">        Subject realSubject =  <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(realSubject);</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        Subject proxyClass = (Subject) Proxy.newProxyInstance(</span><br><span class="line">            ClassLoader.getSystemClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;Subject<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">            <span class="title">myInvocationHandler</span>)</span>;</span><br><span class="line">        <span class="comment">// Subject proxyClass = (Subject) Proxy.newProxyInstance(</span></span><br><span class="line">        <span class="comment">//         realSubject.getClass().getClassLoader(),</span></span><br><span class="line">        <span class="comment">//         realSubject.getClass().getInterfaces(), </span></span><br><span class="line">        <span class="comment">//         myInvocationHandler);</span></span><br><span class="line">        </span><br><span class="line">		proxyClass.sellBooks();</span><br><span class="line"></span><br><span class="line">        proxyClass.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用动态代理。</p>
<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>静态代理和JDK动态代理模式都是要求目标对象实现一个接口或者多个接口，但是有时候目标对象只是一个单独的对象,并没有实现任何的接口，这个时候就可以使用构建目标对象子类的方式实现代理，这种方法就叫做：Cglib代理。<br>Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p>
<p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口。它广泛的被许多AOP的框架使用,例如Spring AOP和synaop，为他们提供方法的interception(拦截)。</p>
<p>Cglib包的底层是通过使用<strong>字节码处理框架ASM</strong>来转换字节码并生成新的子类。</p>
<p><strong>代理的类不能为final，否则报错；目标对象的方法如果为 final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法。</strong></p>
<p>Cglib 动态代理是针对目标类, 动态生成一个子类, 然后子类覆盖父类中的方法, 如果是private或是final类修饰的方法,则不会被重写。</p>
<ol>
<li>需要代理的类（真实主题角色）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cpf.pattern.structure.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以被代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工程师正在吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final 方法不会被生成的字类覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工程师正在工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private 方法不会被生成的字类覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this engineer is playing game"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>CGLIB 代理类（代理主题角色）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cpf.pattern.structure.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"###   before invocation"</span>);</span><br><span class="line">        Object result = method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">"###   end invocation"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工具类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 设置代理人</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy(target));</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成 Cglib 代理类</span></span><br><span class="line">        Engineer engineerProxy = (Engineer) CglibProxy.getProxy(<span class="keyword">new</span> Engineer());</span><br><span class="line">        <span class="comment">// 调用相关方法</span></span><br><span class="line">        engineerProxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###   before invocation</span><br><span class="line">工程师正在吃饭</span><br><span class="line">###   end invocation</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<ol>
<li><p>Spring AOP的实现。</p>
</li>
<li><p>图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。</p>
<p>用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</p>
</li>
<li><p>远程代理。</p>
<p>远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。</p>
</li>
<li><p>虚拟代理。</p>
<p>当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。虚拟代理模式是一种内存节省技术，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。</p>
</li>
<li><p>Copy-on-Write 代理。 </p>
</li>
<li><p>保护（Protect or Access）代理。 </p>
</li>
<li><p>Cache代理。<br>为结果提供临时的存储空间，以便其他客户端调用 </p>
</li>
<li><p>防火墙（Firewall）代理。 </p>
<p>保护目标不让恶意用户靠近</p>
</li>
<li><p>同步化（Synchronization）代理。</p>
</li>
<li><p>智能引用（Smart Reference）代理。</p>
</li>
</ol>
<h3 id="代理模式和装饰器模式的区别"><a href="#代理模式和装饰器模式的区别" class="headerlink" title="代理模式和装饰器模式的区别"></a>代理模式和装饰器模式的区别</h3><ul>
<li>装饰器模式：能动态的新增或组合对象的行为<br><strong>在不改变接口的前提下，动态扩展对象的功能</strong></li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问<br><strong>在不改变接口的前提下，控制对象的访问</strong></li>
</ul>
<p>　　装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行为”还是“控制访问”。</p>
<ul>
<li>代理类所能代理的类完全由代理类确定，装饰类装饰的对象需要根据实际使用时客户端的组合来确定</li>
<li><strong>被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象</strong></li>
</ul>
<h3 id="代理模式和适配器模式的区别"><a href="#代理模式和适配器模式的区别" class="headerlink" title="代理模式和适配器模式的区别"></a>代理模式和适配器模式的区别</h3><p>适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 </p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>简单来说，Spring 是一个分层的 JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
<p>Spring有分层的体系结构，这意味着你能选择使用它孤立的任何部分，它的架构仍然是内在稳定的。例如，你可能选择仅仅使用Spring来简化JDBC的使用，或用来管理所有的业务对象。</p>
<p>spring 特征：</p>
<ul>
<li><p><strong>轻量</strong></p>
<p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。</p>
</li>
<li><p><strong>控制反转</strong></p>
<p>Spring通过一种称作控制反转的技术促进了低耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</p>
</li>
<li><p><strong>面向切面</strong></p>
<p>Spring提供了<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面向切面编程</a>的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">事务</a>（<a href="https://baike.baidu.com/item/transaction" target="_blank" rel="noopener">transaction</a>）管理）进行<a href="https://baike.baidu.com/item/%E5%86%85%E8%81%9A%E6%80%A7" target="_blank" rel="noopener">内聚性</a>的开发。<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">应用对象</a>只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</p>
</li>
<li><p><strong>容器</strong></p>
<p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（<a href="https://baike.baidu.com/item/prototype/14335188" target="_blank" rel="noopener">prototype</a>），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p>
</li>
<li><p><strong>框架</strong></p>
<p>Spring可以将简单的<a href="https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">组件</a>配置、组合成为复杂的应用。在Spring中，<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">应用对象</a>被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">事务管理</a>、持久化框架集成等等），将应用逻辑的开发留给了你。</p>
</li>
<li><p><strong>MVC</strong></p>
<p>Spring的作用是整合，但不仅仅限于整合，Spring 框架可以被看做是一个企业解决方案级别的框架。客户端发送请求，服务器控制器（由DispatcherServlet实现的)完成请求的转发，控制器调用一个用于映射的类HandlerMapping，该类用于将请求映射到对应的处理器来处理请求。HandlerMapping 将请求映射到对应的处理器Controller（相当于Action）在Spring 当中如果写一些处理器组件，一般实现Controller 接口，在Controller 中就可以调用一些Service 或DAO 来进行数据操作 ModelAndView 用于存放从DAO 中取出的数据，还可以存放响应视图的一些数据。 如果想将处理结果返回给用户，那么在Spring 框架中还提供一个视图组件ViewResolver，该组件根据Controller 返回的标示，找到对应的视图，将响应response 返回给用户。</p>
</li>
</ul>
<p>spring 特点</p>
<ol>
<li>方便解耦，简化开发<br>通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</li>
<li>AOP编程的支持<br>通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</li>
<li>声明式事务的支持<br>在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</li>
<li>方便程序的测试<br>可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li>
<li>方便集成各种优秀框架<br>Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。</li>
<li>降低Java EE API的使用难度<br>Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。</li>
<li>Java 源码是经典学习范例<br>Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。</li>
</ol>
<p>Spring 优点</p>
<ol>
<li>低侵入式设计，代码污染极低</li>
<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺</li>
<li>Spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦</li>
<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用</li>
<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li>
<li>Spring并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</li>
</ol>
<p>基本框架<br>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。组成Spring框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。</p>
<p><img data-src="http://www.cs.trincoll.edu/hfoss/images/4/42/Spring_framework.gif" alt=""></p>
<ol>
<li><p>核心容器：</p>
<p>核心容器提供 Spring 框架的基本功能(Spring Core)。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>
</li>
<li><p>Spring 上下文：</p>
<p>Spring 上下文是一个配置文件，向 Spring框架提供上下文信息。Spring 上下文包括企业服务，例如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
</li>
<li><p>Spring AOP：</p>
<p>通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
</li>
<li><p>Spring DAO：</p>
<p>JDBCDAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</p>
</li>
<li><p>Spring ORM：</p>
<p>Spring 框架插入了若干个ORM框架，从而提供了 ORM 的对象关系工具，其中包括JDO、Hibernate和iBatisSQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p>
</li>
<li><p>Spring Web 模块：</p>
<p>Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p>
</li>
<li><p>Spring MVC 框架：</p>
<p>MVC框架是一个全功能的构建 Web应用程序的 MVC 实现。通过策略接口，MVC框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。模型由javabean构成，存放于Map；视图是一个接口，负责显示模型；控制器表示逻辑代码，是Controller的实现。Spring框架的功能可以用在任何J2EE服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同J2EE 环境（Web 或EJB）、独立应用程序、测试环境之间重用。</p>
</li>
</ol>
<h3 id="控制反转和依赖注入"><a href="#控制反转和依赖注入" class="headerlink" title="控制反转和依赖注入"></a>控制反转和依赖注入</h3><blockquote>
<p><a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">Spring IoC有什么好处呢？ - Mingqi的回答 - 知乎</a></p>
</blockquote>
<h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p><strong>什么是IOC</strong></p>
<p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而<strong>是一种设计思想</strong>。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”。</p>
<ul>
<li><p>谁控制谁，控制什么：</p>
<p>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；</p>
<p>谁控制谁：IoC 容器控制了对象</p>
<p>控制什么：主要控制了外部资源获取（不只是对象，包括比如文件等）。</p>
</li>
<li><p>为何是反转，哪些方面反转了：</p>
<p>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；</p>
<p>为何是反转：因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转</p>
<p>哪些方面反转了：依赖对象的获取被反转了。</p>
</li>
</ul>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p><strong>什么是DI</strong></p>
<p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”。</p>
<ul>
<li><p>谁依赖于谁：当然是应用程序依赖于IoC容器；</p>
</li>
<li><p>为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p>
</li>
<li><p>谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>
</li>
<li><p>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
</li>
</ul>
<p>IoC和DI由什么关系呢？其实它们是同一个概念不同角度的描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<p><strong>依赖注入的三种实现方式</strong></p>
<ul>
<li>构造方法注入</li>
<li>Setter方式注入 </li>
<li>接口注入</li>
</ul>
<p><a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">Spring IoC有什么好处呢？ - Mingqi的回答 - 知乎</a></p>
<p>依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现“牵一发动全身”的情况。</p>
<p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg" alt=""></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>什么是AOP</strong></p>
<p>AOP，Aspect Orient Programming，即面向切面编程。是对OOP（Object Orient Programming）的一种补充。</p>
<p><strong>AOP 术语</strong></p>
<ol>
<li><p>通知（Advice）</p>
<p>通知是织入到目标类连接点上的一段程序代码，在Spring中，通知除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点。</p>
</li>
<li><p>连接点（JoinPoint）</p>
<p>即通知具体执行的地方，Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入通知。连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。</p>
</li>
<li><p>切点（Pointcut）</p>
<p>每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。其实确切地说，不能称之为查询连接点，因为连接点是方法执行前、执行后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体连接点上，还需要提供方位信息。</p>
</li>
<li><p>切面（Aspect）<br>切面是通知和切点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p>
</li>
<li><p>引入（introduction）<br>引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</p>
</li>
<li><p>目标（target）<br>增强逻辑的织入目标类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上。</p>
</li>
<li><p>代理(proxy)<br>一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。</p>
</li>
<li><p>织入(weaving)</p>
<p>织入是将增强添加到目标类具体连接点上的过程。AOP像一台织布机，将目标类、通知或引入通过AOP这台织布机天衣无缝地编织到一起。AOP有三种织入方式：</p>
<p>​    a、编译期织入，这要求使用特殊的Java编译器。</p>
<p>​    b、类装载期织入，这要求使用特殊的类装载器。</p>
<p>​    c、动态代理织入，在运行期为目标类添加增强生成子类的方式。</p>
<p>​    Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</p>
</li>
</ol>
<p><strong>五种通知类型</strong></p>
<ol>
<li>前置通知[Before advice]：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 </li>
<li>正常返回通知[After returning advice]：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 </li>
<li>异常返回通知[After throwing advice]：在连接点抛出异常后执行。 </li>
<li>返回通知[After (finally) advice]：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 </li>
<li>环绕通知[Around advice]：环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</li>
</ol>
<p><strong>切点表达式</strong></p>
<blockquote>
<p><a href="https://my.oschina.net/zhangxufeng/blog/1824275" target="_blank" rel="noopener">Spring AOP切点表达式详解</a></p>
</blockquote>
<p>标准的Aspectj Aop的pointcut的表达式类型是很丰富的，但是Spring Aop只支持其中的9种，外加Spring Aop自己扩充的一种一共是10种类型的表达式，分别如下。</p>
<ol>
<li><p>execution：一般用于指定方法的执行，用的最多。</p>
</li>
<li><p>within：指定某些类型的全部方法执行，也可用来指定一个包。</p>
</li>
<li><p>this：Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</p>
</li>
<li><p>target：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</p>
</li>
<li><p>args：当执行的方法的参数是指定类型时生效。</p>
</li>
<li><p>@target：当代理的目标对象上拥有指定的注解时生效。</p>
</li>
<li><p>@args：当执行的方法参数类型上拥有指定的注解时生效。</p>
</li>
<li><p>@within：与@target类似，看官方文档和网上的说法都是@within只需要目标对象的类或者父类上有指定的注解，则@within会生效，而@target则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</p>
</li>
<li><p>@annotation：当执行的方法上拥有指定的注解时生效。</p>
</li>
<li><p>bean：当调用的方法是指定的bean的方法时生效。</p>
</li>
</ol>
<p><strong>execution</strong></p>
<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的部件，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。如下是execution表达式的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span><br><span class="line"></span><br><span class="line">execution([可见性] 返回类型 [声明类型].方法名(参数) [异常])</span><br></pre></td></tr></table></figure>

<p>​       这里问号表示当前项可以有也可以没有，其中各项的语义如下：</p>
<ul>
<li>modifiers-pattern：方法的可见性，如public，protected；</li>
<li>ret-type-pattern：方法的返回值类型，如int，void等；</li>
<li>declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；</li>
<li>name-pattern：方法名类型，如buisinessService()；</li>
<li>param-pattern：方法的参数类型，如java.lang.String；</li>
<li>throws-pattern：方法抛出的异常类型，如java.lang.Exception；</li>
</ul>
<p>​        如下是一个使用execution表达式的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(public * com.spring.service.BusinessObject.businessService(java.lang.String,..))</span><br></pre></td></tr></table></figure>

<p>​       上述切点表达式将会匹配使用public修饰，返回值为任意类型，并且是com.spring.BusinessObject类中名称为businessService的方法，方法可以有多个参数，但是第一个参数必须是java.lang.String类型的方法。上述示例中我们使用了..通配符，关于通配符的类型，主要有两种：</p>
<ul>
<li><p>* 通配符：该通配符主要用于匹配单个单词，或者是以某个词为前缀或后缀的单词。</p>
<p>如下示例表示返回值为任意类型，在com.spring.service.BusinessObject类中，并且参数个数为零的方法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(* com.spring.service.BusinessObject.*())</span><br></pre></td></tr></table></figure>

<p>​       下述示例表示返回值为任意类型，在com.spring.service包中，以Business为前缀的类，并且是类中参数个数为零方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(* com.spring.service.Business*.*())</span><br></pre></td></tr></table></figure>

<ul>
<li>.. 通配符：该通配符表示0个或多个项，主要用于declaring-type-pattern和param-pattern中，如果用于declaring-type-pattern中，则表示匹配当前包及其子包，如果用于param-pattern中，则表示匹配0个或多个参数。</li>
</ul>
<p>​       如下示例表示匹配返回值为任意类型，并且是com.spring.service包及其子包下的任意类的名称为businessService的方法，而且该方法不能有任何参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(* com.spring.service..*.businessService())</span><br></pre></td></tr></table></figure>

<p>​       这里需要说明的是，包路径service..<em>.businessService()中的..应该理解为延续前面的service路径，表示到service路径为止，或者继续延续service路径，从而包括其子包路径；后面的</em>.businessService()，这里的*表示匹配一个单词，因为是在方法名前，因而表示匹配任意的类。</p>
<p>​       如下示例是使用..表示任意个数的参数的示例，需要注意，表示参数的时候可以在括号中事先指定某些类型的参数，而其余的参数则由..进行匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(* com.spring.service.BusinessObject.businessService(java.lang.String,..))</span><br></pre></td></tr></table></figure>

<p><strong>AOP应用</strong></p>
<ul>
<li>日志记录，跟踪，优化和监控</li>
<li>事务的处理</li>
<li>持久化</li>
<li>性能的优化</li>
<li>资源池，如数据库连接池的管理</li>
<li>系统统一的认证、权限管理等</li>
<li>应用系统的异常捕捉及处理</li>
</ul>
<p><strong>AOP的实现</strong></p>
<blockquote>
<p><a href="http://listenzhangbin.com/post/2016/09/spring-aop-cglib/" target="_blank" rel="noopener">Spring AOP的实现原理</a></p>
<p><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">《Spring设计思想》AOP实现原理（基于JDK和基于CGLIB）</a></p>
</blockquote>
<p>AOP 的实现技术主要有Spring AOP和AspectJ。</p>
<ol>
<li>AspectJ</li>
</ol>
<p>AspectJ的底层技术是静态代理，即用一种AspectJ支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。</p>
<ol start="2">
<li>Spring AOP</li>
</ol>
<p>Spring AOP采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，对于动态代理技术，Spring AOP提供了对JDK动态代理的支持以及CGLib的支持。</p>
<h3 id="Spring-MVC-执行流程"><a href="#Spring-MVC-执行流程" class="headerlink" title="Spring MVC 执行流程"></a>Spring MVC 执行流程</h3><blockquote>
<p><a href="https://www.cnblogs.com/wmyskxz/p/8848461.html" target="_blank" rel="noopener">Spring MVC【入门】就这一篇！</a></p>
<p><a href=""></a></p>
</blockquote>
<p>早期的 MVC 模型<strong>（Model2）</strong>就像下图这样：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-403a273b08fec826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p>
<ul>
<li><strong>M 代表模型（Model）</strong><br>模型是什么呢？ 模型就是数据，就是 dao,bean</li>
<li><strong>V 代表视图（View）</strong><br>视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</li>
<li><strong>C 代表控制器（controller)</strong><br>控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</li>
</ul>
<h4 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h4><p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-a25782fb05f315de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><strong>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。</strong>在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。</p>
<p><strong>特点：</strong></p>
<ul>
<li>结构松散，几乎可以在 Spring MVC 中使用各类视图</li>
<li>松耦合，各个模块分离</li>
<li>与 Spring 无缝集成</li>
</ul>
<p>SpringMVC框架是一个基于请求驱动的Web框架，并且使用了‘前端控制器’模型来进行设计，再根据‘请求映射规则’分发给相应的页面控制器进行处理。</p>
<p>（一）整体流程</p>
<p> <img data-src="https://img-blog.csdn.net/20141129165225388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb2xpamluZzIwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>具体步骤：</p>
<pre><code>1、  首先用户发送请求————&gt;前端控制器，前端控制器根据请求信息（如 URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图 2-1 中的 1、2 步骤；

2、  页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在 Spring Web MVC 中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个 ModelAndView（模型数据和逻辑视图名）；图 2-1 中的 3、4、5 步骤；

3、  前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图 2-1 中的步骤 6、7；

4、  前端控制器再次收回控制权，将响应返回给用户，图 2-1 中的步骤 8；至此整个结束。</code></pre><p>（二）核心流程</p>
<p><img data-src="https://img-blog.csdn.net/20141129165243297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb2xpamluZzIwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><a href="https://www.bilibili.com/video/av20870782/?p=3" target="_blank" rel="noopener">具体步骤</a>：</p>
<ol>
<li>用户发送请求到前端控制器（DispatcherServlet）</li>
<li>前端控制器请求处理器映射器 HandlerMapping 来查找 Handler，可以根据 xml 配置、注解来进行查找</li>
<li>处理器映射器 HandlerMapping 向前端控制器返回 Handler</li>
<li>前端控制器调用处理器适配器 HandlerAdapter 去执行 Handler</li>
<li>处理器适配器 HandlerAdapter 去执行 Handler</li>
<li>Handler 执行完给适配器返回 ModelAndView</li>
<li>处理器适配器 HandlerAdapter 向前端控制器返回 ModelAndView，ModelAndView 是 Spring MVC 框架的一个底层对象，包括了 Model 和 View</li>
<li>前端控制器请求视图解析器进行视图解析，根据逻辑视图名解析成真正的试图（JSP）</li>
<li>视图解析器向前端控制器放回 View</li>
<li>前端控制器进行试图渲染，视图渲染就是将数据（在 ModelAndView 中）填充到 request 域</li>
<li>前端控制器向用户响应结果</li>
</ol>
<p>主要组件：</p>
<ol>
<li><p>前端控制器 DispatcherServlet（不需要程序员开发）</p>
<p>作用：接收请求，相应结果。相当于转发器，中央处理器，有了 DispatcherServlet 减少了其他组件之间的耦合度。</p>
</li>
<li><p>处理器映射器 HandlerMapping（不需要程序员开发）</p>
<p>作用：根据 url 查找 Handler，可以根据 xml 配置，也可以根据注解</p>
</li>
<li><p>处理器适配器 HandlerAdapter</p>
<p>作用：按照特定的规则（HandlerAdapter 要求的规则）去执行 Handler</p>
</li>
<li><p>处理器 Handler（<strong>需要程序员开发</strong>）</p>
<p>注意：编写 Handler（即我们平时说的 Controller）时要按照 HandlerAdapter 的要求去做，这样适配器才能正确的执行 Handler</p>
</li>
<li><p>视图解析器 ViewResolver（不需要程序员开发）</p>
<p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（View）</p>
</li>
<li><p>视图 View（<strong>需要程序员开发 jsp</strong>）</p>
<p>View 是一个接口，实现类支持不同的 View 类型（jsp，freemaker，pdf…）</p>
<p>（三）总结核心开发步骤</p>
</li>
</ol>
<p>1、  DispatcherServlet 在 web.xml 中的部署描述，从而拦截请求到 Spring Web MVC</p>
<p>2、  HandlerMapping 的配置，从而将请求映射到处理器</p>
<p>3、  HandlerAdapter 的配置，从而支持多种类型的处理器</p>
<p>4、  ViewResolver 的配置，从而将逻辑视图名解析为具体视图技术</p>
<p>5、  处理器（页面控制器）的配置，从而进行功能处理 </p>
<h4 id="SpringMVC与Struts2区别与比较总结"><a href="#SpringMVC与Struts2区别与比较总结" class="headerlink" title="SpringMVC与Struts2区别与比较总结"></a>SpringMVC与Struts2区别与比较总结</h4><blockquote>
<p><a href="https://blog.csdn.net/chenleixing/article/details/44570681" target="_blank" rel="noopener">SpringMVC与Struts2区别与比较总结</a></p>
</blockquote>
<p>1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</p>
<p>2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。<br>3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</p>
<p>4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。</p>
<p>6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>
<p>7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。</p>
<p>8、Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。</p>
<p>9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p>
<p>10、SpringMVC开发效率和性能高于Struts2。</p>
<p>11、SpringMVC可以认为已经100%零配置。</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="Spring-Boot-的三种启动方式"><a href="#Spring-Boot-的三种启动方式" class="headerlink" title="Spring Boot 的三种启动方式"></a>Spring Boot 的三种启动方式</h3><ol>
<li><p>IDE 运行Application这个类的main方法</p>
</li>
<li><p>在Spring Boot应用的根目录下运行<code>mvn spring-boot:run</code></p>
</li>
<li><p>使用 mvn install 生成 jar后运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">先到项目根目录</span><br><span class="line">mvn install</span><br><span class="line">cd target</span><br><span class="line">java -jar xxxx.jar</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="GIT-常用命令"><a href="#GIT-常用命令" class="headerlink" title="GIT 常用命令"></a>GIT 常用命令</h3><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git 命令清单- 阮一峰的网络日志</a></p>
</blockquote>
<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h3 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h3><ul>
<li><p>mvn compile</p>
<p>编译项目</p>
</li>
<li><p>mvn package</p>
<p>打包</p>
<ul>
<li><p>mvn package -Dmaven.test.skip=ture</p>
<p>打包时跳过测试</p>
</li>
<li><p>mvn clean package -Dmaven.test.skip=true</p>
<p>清除以前的 jar 包后重新打包，跳过测试类</p>
</li>
</ul>
</li>
<li><p>mvn install </p>
<p>安装当前工程的输出文件到本地仓库</p>
</li>
<li><p>mvn clean</p>
<p>清除项目目录中的生成结果</p>
</li>
</ul>
<ol>
<li><p>package 与 install 命令的区别</p>
<p>package 是把 jar 打到本项目的 target 目录下，而 install 是把 target 下的 jar 安装到本地仓库，供其他项目使用。</p>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote>
<p><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">正则表达式 - 语法</a></p>
</blockquote>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table>
<thead>
<tr>
<th>特别字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择。要匹配 |，请使用 |。</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配。</td>
</tr>
</tbody></table>
<h3 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h3><blockquote>
<p><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">Java 正则表达式| 菜鸟教程</a></p>
</blockquote>
<p>在其他语言中，<code>\\</code> 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</p>
<p>在 Java 中，<code>\\</code> 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</p>
<p>所以，在其他的语言中（如Perl），一个反斜杠 <code>\</code> 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 <code>\\</code> 代表其他语言中的一个 <code>\</code>，这也就是为什么表示一位数字的正则表达式是 <code>\\d</code>，而表示一个普通的反斜杠是 <code>\\\\</code>。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="IP-网段黑名单过滤"><a href="#IP-网段黑名单过滤" class="headerlink" title="IP 网段黑名单过滤"></a>IP 网段黑名单过滤</h3><blockquote>
<p><a href="https://blog.csdn.net/jeffleo/article/details/72824240" target="_blank" rel="noopener">设计一个ip网段黑名单过滤（网易面试题）</a></p>
</blockquote>
<p><strong>问题：</strong>给出一个网段，该网段的地址都属于黑名单，验证其他ip地址是否属于黑名单<br><strong>思路：</strong>要想到通过二进制的位运算来实现：</p>
<p><code>ip &amp; 子网掩码 = 网段</code></p>
<p>对于一个 <a href="https://baike.baidu.com/item/%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1/240168?fr=aladdin" target="_blank" rel="noopener">CIDR</a> 的ip地址，怎么得到子网掩码？<br>先得到CIDR中的网络号位数netCount，然后：</p>
<p><code>int mask = 0xFFFFFFFF &lt;&lt; (32 - netCount);</code></p>
<p>这样就能得到子网掩码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> network 黑名单网段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maskIp 扫描ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">filt</span><span class="params">(String network, String maskIp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先将网段转换为10进制数</span></span><br><span class="line">        String[] networks = network.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">long</span> networkIp = Long.parseLong(networks[<span class="number">0</span>])  &lt;&lt; <span class="number">24</span> |</span><br><span class="line">                Long.parseLong(networks[<span class="number">1</span>])  &lt;&lt; <span class="number">16</span>|</span><br><span class="line">                Long.parseLong(networks[<span class="number">2</span>])  &lt;&lt; <span class="number">8</span>|</span><br><span class="line">                Long.parseLong(networks[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出网络位数</span></span><br><span class="line">        <span class="keyword">int</span> netCount = Integer.parseInt(maskIp.replaceAll(<span class="string">".*/"</span>, <span class="string">""</span>));</span><br><span class="line">        <span class="comment">//这里实际上通过CIDR的网络号转换为子网掩码</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0xFFFFFFFF</span> &lt;&lt; (<span class="number">32</span> - netCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再将验证的ip转换为10进制数</span></span><br><span class="line">        String testIp = maskIp.replaceAll(<span class="string">"/.*"</span>, <span class="string">""</span>);</span><br><span class="line">        String[] ips = testIp.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">long</span> ip = Long.parseLong(ips[<span class="number">0</span>]) &lt;&lt; <span class="number">24</span>|</span><br><span class="line">                Long.parseLong(ips[<span class="number">1</span>]) &lt;&lt; <span class="number">16</span>|</span><br><span class="line">                Long.parseLong(ips[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>|</span><br><span class="line">                Long.parseLong(ips[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将网段ip和验证ip分别和子网号进行&amp;运算之后，得到的是网络号，如果相同，说明是同一个网段的</span></span><br><span class="line">        <span class="keyword">return</span> (networkIp &amp; mask) == (ip &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isBlack = filt(<span class="string">"10.168.1.2"</span>, <span class="string">"10.168.0.224/23"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isBlack)&#123;</span><br><span class="line">            System.out.println(<span class="string">"是黑名单"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"不是黑名单"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>任何应用考虑到安全，绝不能明文的方式保存密码。密码应该通过哈希算法进行加密。有很多标准的算法比如SHA或者MD5，结合salt(盐)是一个不错的选择。 Spring Security提供了BCryptPasswordEncoder类,实现Spring的PasswordEncoder接口使用BCrypt强哈希方法来加密密码。</p>
<p>BCrypt强哈希方法 每次加密的结果都不一样。</p>
<p>（1）tensquare_user工程的pom引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）添加配置类 （资源/工具类中提供）</p>
<p>我们在添加了spring security依赖后，所有的地址都被spring security所控制了，我们目前只是需要用到BCrypt密码加密的部分，所以我们要添加一个配置类，配置为所有地址都可以匿名访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）修改tensquare_user工程的Application, 配置bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">bcryptPasswordEncoder</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管理员密码加密"><a href="#管理员密码加密" class="headerlink" title="管理员密码加密"></a>管理员密码加密</h4><h5 id="新增管理员密码加密"><a href="#新增管理员密码加密" class="headerlink" title="新增管理员密码加密"></a>新增管理员密码加密</h5><p>修改tensquare_user工程的AdminService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">BCryptPasswordEncoder encoder;    </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Admin admin)</span> </span>&#123;    </span><br><span class="line">	admin.setId(idWorker.nextId()+<span class="string">""</span>); <span class="comment">//主键值        </span></span><br><span class="line">    <span class="comment">//密码加密        </span></span><br><span class="line">    String newpassword = encoder.encode(admin.getPassword());<span class="comment">//加密后的密码</span></span><br><span class="line">       </span><br><span class="line">    admin.setPassword(newpassword);                  </span><br><span class="line">    adminDao.save(admin);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="管理员登陆密码校验"><a href="#管理员登陆密码校验" class="headerlink" title="管理员登陆密码校验"></a>管理员登陆密码校验</h5><p>（1）AdminDao增加方法定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">findByLoginname</span><span class="params">(String loginname)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（2）AdminService增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 根据登陆名和密码查询    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginname    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">findByLoginnameAndPassword</span><span class="params">(String loginname, String password)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Admin admin = adminDao.findByLoginname(loginname);        </span><br><span class="line">    <span class="keyword">if</span>( admin!=<span class="keyword">null</span> &amp;&amp; encoder.matches(password,admin.getPassword())) &#123;</span><br><span class="line">	    <span class="keyword">return</span> admin;            </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）AdminController增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 用户登陆    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginname    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/login"</span>,method=RequestMethod.POST)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@RequestBody Map&lt;String,String&gt; loginMap)</span></span>&#123;    </span><br><span class="line">    Admin admin =</span><br><span class="line">            adminService.findByLoginnameAndPassword(loginMap.get(<span class="string">"loginname"</span>),</span><br><span class="line">            loginMap.get(<span class="string">"password"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(admin!=<span class="keyword">null</span>)&#123;        </span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"登陆成功"</span>);            </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,StatusCode.LOGINERROR,<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用户密码加密"><a href="#用户密码加密" class="headerlink" title="用户密码加密"></a>用户密码加密</h4><h5 id="用户注册密码加密"><a href="#用户注册密码加密" class="headerlink" title="用户注册密码加密"></a>用户注册密码加密</h5><p>（4）修改tensquare_user工程的UserService 类，引入BCryptPasswordEncoder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">BCryptPasswordEncoder encoder;</span><br></pre></td></tr></table></figure>

<p>（5）修改tensquare_user工程的UserService 类的add方法，添加密码加密的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user,String code)</span> </span>&#123;    </span><br><span class="line">    ........        </span><br><span class="line">    ........        </span><br><span class="line">    ........        </span><br><span class="line">    <span class="comment">//密码加密        </span></span><br><span class="line">    String newpassword = encoder.encode(user.getPassword());<span class="comment">//加密后的密码</span></span><br><span class="line"></span><br><span class="line">    user.setPassword(newpassword);        </span><br><span class="line">    userDao.save(user);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用户登陆密码判断"><a href="#用户登陆密码判断" class="headerlink" title="用户登陆密码判断"></a>用户登陆密码判断</h5><p>（1）修改tensquare_user工程的UserDao接口，增加方法定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据手机号查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mobile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByMobile</span><span class="params">(String mobile)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（2）修改tensquare_user工程的UserService 类，增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 根据手机号和密码查询用户    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mobile    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByMobileAndPassword</span><span class="params">(String mobile,String password)</span></span>&#123;    </span><br><span class="line">    User user = userDao.findByMobile(mobile);        </span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span> &amp;&amp;  encoder.matches(password,user.getPassword()))&#123;        </span><br><span class="line">    	<span class="keyword">return</span> user;            </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）修改tensquare_user工程的UserController类，增加login方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 用户登陆    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mobile    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/login"</span>,method=RequestMethod.POST)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(String mobile,String password)</span></span>&#123;    </span><br><span class="line">    User user = userService.findByMobileAndPassword(mobile,password);        </span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;        </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"登陆成功"</span>);            </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,StatusCode.LOGINERROR,<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Boot-1"><a href="#Spring-Boot-1" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p><a href="https://mp.weixin.qq.com/s/jWLcPxTg9bH3D9_7qbYbfw" target="_blank" rel="noopener">什么是Spring Boot?</a></p>
<p><a href="https://my.oschina.net/PTOldDriver/blog/1593450#h2_18" target="_blank" rel="noopener">Spring Boot启动时的主体流程、事件解耦设计与配置加载原理</a></p>
</blockquote>
<p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li><p>独立运行</p>
<p>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p>
</li>
<li><p>简化配置</p>
<p>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+- org.springframework.boot:spring-boot-starter-web:jar:<span class="number">1.5</span><span class="number">.6</span>.RELEASE:compile</span><br><span class="line">+- org.springframework.boot:spring-boot-starter-tomcat:jar:<span class="number">1.5</span><span class="number">.6</span>.RELEASE:compile</span><br><span class="line">|  +- org.apache.tomcat.embed:tomcat-embed-core:jar:<span class="number">8.5</span><span class="number">.16</span>:compile</span><br><span class="line">|  +- org.apache.tomcat.embed:tomcat-embed-el:jar:<span class="number">8.5</span><span class="number">.16</span>:compile</span><br><span class="line">|  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:<span class="number">8.5</span><span class="number">.16</span>:compile</span><br><span class="line">+- org.hibernate:hibernate-validator:jar:<span class="number">5.3</span><span class="number">.5</span>.Final:compile</span><br><span class="line">|  +- javax.validation:validation-api:jar:<span class="number">1.1</span><span class="number">.0</span>.Final:compile</span><br><span class="line">|  +- org.jboss.logging:jboss-logging:jar:<span class="number">3.3</span><span class="number">.1</span>.Final:compile</span><br><span class="line">|  \- com.fasterxml:classmate:jar:<span class="number">1.3</span><span class="number">.3</span>:compile</span><br><span class="line">\- org.springframework:spring-webmvc:jar:<span class="number">4.3</span><span class="number">.10</span>.RELEASE:compile</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动配置</p>
<p>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。</p>
</li>
<li><p>无代码生成和XML配置</p>
<p>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。</p>
</li>
<li><p>应用监控</p>
<p>Spring Boot提供一系列端点可以监控服务及应用，做健康检测。</p>
</li>
</ul>
<p>缺点：</p>
<h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><p>SpringBoot配置文件可以放置在多种路径下，不同路径下的配置优先级有所不同。<br>可放置目录(优先级从高到低)</p>
<ul>
<li>file:./config/ (当前项目路径config目录下);</li>
<li>file:./ (当前项目路径下);</li>
<li>classpath:/config/ (类路径config目录下);</li>
<li>classpath:/ (类路径config下).</li>
</ul>
<p><img data-src="https://img-blog.csdn.net/20180530125401267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载配置文件并互补配置；我们可以从ConfigFileApplicationListener这类便可看出，其中DEFAULT_SEARCH_LOCATIONS属性设置了加载的目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SEARCH_LOCATIONS = <span class="string">"classpath:/,classpath:/config/,file:./,file:./config/"</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html" target="_blank" rel="noopener">application.propertierde 的完整的属性列表</a></p>
</blockquote>
<h4 id="读取自定义属性"><a href="#读取自定义属性" class="headerlink" title="读取自定义属性"></a>读取自定义属性</h4><blockquote>
<p><a href="https://www.jianshu.com/p/60b34464ca58" target="_blank" rel="noopener">SpringBoot 配置文件详解（告别XML）</a></p>
<p><a href="https://blog.csdn.net/m0_37739193/article/details/83352591" target="_blank" rel="noopener">SpringBoot读取配置文件总结</a></p>
</blockquote>
<ol>
<li><p>使用@Value方式（常用）</p>
</li>
<li><p>使用 @ConfigurationProperties 把相关的配置，注入到某个配置类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供Setter 和 Getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：你现在能大概猜到为什么SpringBoot 应用能够根据默认属性（<a href="https://link.jianshu.com/?t=https%3A%2F%2Fdocs.spring.io%2Fspring-boot%2Fdocs%2Fcurrent%2Freference%2Fhtml%2Fcommon-application-properties.html%23common-application-properties" target="_blank" rel="noopener">默认属性列表</a>）来自动配置数据源了吧？因为内置的数据源类<code>DataSourceProperties</code>通过<code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</code>读取到了我们在配置文件填写的数据源信息，然后通过<code>DataSourceAutoConfiguration</code> 创建了数据源Bean和进行了相关初始化配置。</p>
</li>
<li><p>使用Environment方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Environment env;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/index3"</span>) </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">index3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"方式三:"</span>+env.getProperty(<span class="string">"test.msg"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="读取自定义配置文件的属性"><a href="#读取自定义配置文件的属性" class="headerlink" title="读取自定义配置文件的属性"></a>读取自定义配置文件的属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "author",locations = "classpath:author.properties")</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"author"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/author.properties"</span>)</span><br><span class="line"><span class="comment">//多配置文件引用，若取两个配置文件中有相同属性名的值，则取值为最后一个配置文件中的值</span></span><br><span class="line"><span class="comment">//@PropertySource(&#123;"classpath:/my.properties","classpath:/author.properties"&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebConfig</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：springboot 1.5版本以后@ConfigurationProperties没有了location属性，使用@PropertySource来指定配置文件位置</p>
<h3 id="Spring-Boot-多环境配置"><a href="#Spring-Boot-多环境配置" class="headerlink" title="Spring Boot 多环境配置"></a>Spring Boot 多环境配置</h3><blockquote>
<p><a href="https://blog.csdn.net/top_code/article/details/78570047" target="_blank" rel="noopener">Spring Boot教程 - Spring Boot Profiles实现多环境下配置切换</a></p>
</blockquote>
<ol>
<li><p>使用yml文件（分为单文档和多文档两种方式）<br>首先,我们先创建一个名为 application.yml的属性文件,如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#development environment</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8160</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ricky</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#test environment</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8180</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#production environment</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8190</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<p>application.yml文件分为四部分,使用 — 来作为分隔符，第一部分通用配置部分，表示三个环境都通用的属性， 后面三段分别为：开发，测试，生产，用spring.profiles指定了一个值(开发为dev，测试为test，生产为prod)，这个值表示该段配置应该用在哪个profile里面。</p>
<p>如果我们是本地启动，在通用配置里面可以设置调用哪个环境的profil，也就是第一段的spring.profiles.active=XXX， 其中XXX是后面3段中spring.profiles对应的value,通过这个就可以控制本地启动调用哪个环境的配置文件，例如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span></span><br><span class="line">        <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>表示默认 加载的就是开发环境的配置，如果dev换成test，则会加载测试环境的属性，以此类推。</p>
<p>注意：如果spring.profiles.active没有指定值，那么只会使用没有指定spring.profiles文件的值，也就是只会加载通用的配置。</p>
<p>启动参数<br>如果是部署到服务器的话,我们正常打成jar包，启动时通过 –spring.profiles.active=xxx 来控制加载哪个环境的配置，完整命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=test 表示使用测试环境的配置</span><br><span class="line"></span><br><span class="line">java -jar xxx.jar --spring.profiles.active=prod 表示使用生产环境的配置</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用多个yml配置文件进行配置属性文件<br>我们也可以使用多个yml来配置属性，将于环境无关的属性放置到application.yml文件里面；通过与配置文件相同的命名规范，创建application-{profile}.yml文件 存放不同环境特有的配置，例如 application-test.yml 存放测试环境特有的配置属性，application-prod.yml 存放生产环境特有的配置属性。</p>
<p>通过这种形式来配置多个环境的属性文件，在application.yml文件里面spring.profiles.active=xxx来指定加载不同环境的配置,如果不指定，则默认只使用application.yml属性文件，不会加载其他的profiles的配置。</p>
</li>
<li><p>使用properties文件<br> 如果使用application.properties进行多个环境的配置，原理跟使用多个yml配置文件一致，创建application-{profile}.properties文件 存放不同环境特有的配置，将于环境无关的属性放置到application.properties文件里面，并在application.properties文件中通过spring.profiles.active=xxx 指定加载不同环境的配置。如果不指定，则默认加载application.properties的配置，不会加载带有profile的配置。</p>
</li>
<li><p>Maven Profile</p>
<p>如果我们使用的是构建工具是Maven，也可以通过Maven的profile特性来实现多环境配置打包。</p>
<p>pom.xml配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build.profile.id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">build.profile.id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build.profile.id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">build.profile.id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build.profile.id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">build.profile.id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources.$&#123;build.profile.id&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过执行 <code>mvn clean package -P ${profile}</code> 来指定使用哪个profile。</p>
</li>
</ol>
<h3 id="SpringBoot几个常用的注解"><a href="#SpringBoot几个常用的注解" class="headerlink" title="SpringBoot几个常用的注解"></a><strong>SpringBoot几个常用的注解</strong></h3><ul>
<li>@RestController和@Controller指定一个类，作为控制器的注解 </li>
<li>@RequestMapping方法级别的映射注解，这一个用过Spring MVC的小伙伴相信都很熟悉 </li>
<li>@EnableAutoConfiguration和@SpringBootApplication是类级别的注解，根据maven依赖的jar来自动配置，只要引入了spring-boot-starter-web的依赖，默认会自动配置Spring MVC和tomcat容器</li>
<li>@Configuration类级别的注解，一般这个注解，我们用来标识main方法所在的类,完成元数据bean的初始化。</li>
<li>@ComponentScan类级别的注解，自动扫描加载所有的Spring组件包括Bean注入，一般用在main方法所在的类上 </li>
<li>@ImportResource类级别注解，当我们必须使用一个xml的配置时，使用@ImportResource和@Configuration来标识这个文件资源的类。 </li>
<li>@Autowired注解，一般结合@ComponentScan注解，来自动注入一个Service或Dao级别的Bean</li>
<li>@Component类级别注解，用来标识一个组件，比如我自定了一个filter，则需要此注解标识之后，Spring Boot才会正确识别。</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器<code>Filter</code>，是<code>Servlet</code>的的一个实用技术了。可通过过滤器，对请求进行拦截，比如读取<strong>session判断用户是否登录</strong>、判断访问的<strong>请求URL是否有访问权限(黑白名单)</strong>等。主要还是可对请求进行预处理。</p>
<p>在<code>springboot</code>有两种实现过滤器功能：</p>
<ol>
<li><p><a href="https://blog.lqdev.cn/2018/07/19/springboot/chapter-seven/#%E5%88%A9%E7%94%A8WebFilter%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">利用WebFilter注解配置</a></p>
<p><code>@WebFilter</code>时<code>Servlet3.0</code>新增的注解，原先实现过滤器，需要在<code>web.xml</code>中进行配置，而现在通过此注解，启动启动时会自动扫描自动注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册器名称为customFilter,拦截的url为所有</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName=<span class="string">"customFilter"</span>,urlPatterns=&#123;<span class="string">"/*"</span>&#125;)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"filter 初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        log.info(<span class="string">"doFilter 请求处理"</span>);</span><br><span class="line">        <span class="comment">//对request、response进行一些预处理</span></span><br><span class="line">        <span class="comment">// 比如设置请求编码</span></span><br><span class="line">        <span class="comment">// request.setCharacterEncoding("UTF-8");</span></span><br><span class="line">        <span class="comment">// response.setCharacterEncoding("UTF-8");</span></span><br><span class="line">        <span class="comment">//TODO 进行业务逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//链路 直接传给下一个过滤器</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"filter 销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><a href="https://blog.lqdev.cn/2018/07/19/springboot/chapter-seven/#FilterRegistrationBean%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">FilterRegistrationBean方式</a></p>
<p><code>FilterRegistrationBean</code>是<code>springboot</code>提供的，此类提供setOrder方法，可以为filter设置排序值，让spring在注册web filter之前排序后再依次注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean  <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    <span class="comment">//当过滤器有注入其他bean类时，可直接通过@bean的方式进行实体类过滤器，这样不可自动注入过滤器使用的其他bean类。</span></span><br><span class="line">    <span class="comment">//当然，若无其他bean需要获取时，可直接new CustomFilter()，也可使用getBean的方式。</span></span><br><span class="line">    registration.setFilter(customFilter());</span><br><span class="line">    <span class="comment">//过滤器名称</span></span><br><span class="line">    registration.setName(<span class="string">"customFilter"</span>);</span><br><span class="line">    <span class="comment">//拦截路径</span></span><br><span class="line">    registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">    <span class="comment">//设置顺序</span></span><br><span class="line">    registration.setOrder(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">customFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">"preHandle:请求前调用"</span>);</span><br><span class="line">		<span class="comment">//返回 false 则请求中断</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">"postHandle:请求后调用"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">"afterCompletion:请求调用完成后回调方法，即在视图渲染完成后回调"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		 <span class="comment">//注册拦截器 拦截规则</span></span><br><span class="line">		<span class="comment">//多个拦截器时 以此添加 执行顺序按添加顺序</span></span><br><span class="line">		registry.addInterceptor(getHandlerInterceptor()).addPathPatterns(<span class="string">"/*"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HandlerInterceptor <span class="title">getHandlerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CustomHandlerInterceptor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>Listeeshi是servlet规范中定义的一种特殊类。用于监听servletContext、HttpSession和servletRequest等域对象的创建和销毁事件。监听域对象的属性发生修改的事件。用于在事件发生前、发生后做一些必要的处理。一般是获取在线人数等业务需求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customlister</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"监听器：销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"监听器：初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公共异常处理"><a href="#公共异常处理" class="headerlink" title="公共异常处理"></a>公共异常处理</h3><p>为了使我们的代码更容易维护，我们创建一个类集中处理异常<br>在om.tensquare.user.controller包下创建公共异常处理类BaseExceptionHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一异常处理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExceptionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span> <span class="title">error</span>( <span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        e.printStackTrace();       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, StatusCode.ERROR, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试常见问题-2"><a href="#面试常见问题-2" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><ol>
<li><p><strong>什么是Spring Boot</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_31655965/article/details/71258191" target="_blank" rel="noopener">【springboot 入门篇】第0篇 spring-boot是什么</a></p>
</blockquote>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，Spring Boot 整合了所有的框架（不知道这样比喻是否合适）。</p>
<p>spring大家都知道，boot是启动的意思。所以，spring boot其实就是一个启动spring项目的一个工具而已。从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。</p>
<p>以前在写spring项目的时候，要配置各种xml文件，还记得曾经被ssh框架支配的恐惧。随着spring3，spring4的相继推出，约定大于配置逐渐成为了开发者的共识，大家也渐渐的从写xml转为写各种注解，在spring4的项目里，你甚至可以一行xml都不写。</p>
<p>虽然spring4已经可以做到无xml，但写一个大项目需要茫茫多的包，maven配置要写几百行，也是一件很可怕的事。</p>
<p>现在，快速开发一个网站的平台层出不穷，nodejs，php等虎视眈眈，并且脚本语言渐渐流行了起来（Node JS，Ruby，Groovy，Scala等），spring的开发模式越来越显得笨重。</p>
<p>在这种环境下，spring boot伴随着spring4一起出现了。</p>
</li>
<li><p><strong>Spring Boot、Spring MVC 和 Spring 有什么区别？</strong></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/42620a0a2c33" target="_blank" rel="noopener">Spring,Spring MVC及Spring Boot区别</a></p>
</blockquote>
<p>我们说到Spring，一般指代的是Spring Framework。纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案</p>
<p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易。</p>
<p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node.Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于实现自动配置，降低项目搭建的复杂度。</p>
<p><strong>Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包</strong>。说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用于开发 web 应用（ SpringMVC ）。然后又发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。</p>
</li>
<li><p><strong>Spring 、Spring Boot 和 Spring Cloud 的关系</strong></p>
<p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p>
<p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。所以说没有 Spring 强大的功能和生态，就不会有后期的 Spring Boot 火热, Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。</p>
<p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p>
<p>Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<p>根据上面的说明我们可以看出来，Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p>
<p>综上我们可以这样来理解，正是由于 Spring Ioc 和 Spring Aop 两个强大的功能才有了 Spring ，Spring 生态不断的发展才有了 Spring Boot ，使用 Spring Boot 让 Spring 更易用更有生命力，Spring Cloud 是基于 Spring Boot 开发的一套微服务架构下的服务治理方案。</p>
<p>用一组不太合理的包含关系来表达它们之间的关系。</p>
<blockquote>
<p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>
</blockquote>
</li>
<li><p><strong>Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</strong></p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/BzXNfBzq-2TOCbiHG3xcsQ" target="_blank" rel="noopener">Spring Boot 核心配置文件详解</a></p>
</blockquote>
<p> Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p>
<p> application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p>
<p> boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载</p>
<p> boostrap 里面的属性不能被覆盖</p>
<p> bootstrap 配置文件有以下几个应用场景。</p>
<ul>
<li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li>
<li>一些固定的不能被覆盖的属性；</li>
<li>一些加密/解密的场景；</li>
</ul>
</li>
<li><p><strong>Spring Boot 的配置文件有哪几种格式？它们有什么区别？</strong></p>
<p> .properties 和 .yml，它们的区别主要是书写格式不同。</p>
<p> 1).properties</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.user.name &#x3D; javastack</span><br></pre></td></tr></table></figure>

<p> 2).yml</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:</span><br><span class="line">  user:</span><br><span class="line">    name: javastack</span><br></pre></td></tr></table></figure>

<p> 另外，.yml 格式不支持 <code>@PropertySource</code> 注解导入配置。</p>
</li>
<li><p><strong>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</strong></p>
<blockquote>
<p><a href="https://juejin.im/post/59a6defb6fb9a0248e5cd3e5" target="_blank" rel="noopener">SpringBoot详解（二）-Spring Boot的核心</a></p>
</blockquote>
<p> 启动类上面的注解 @SpringBootApplication 是 Spring Boot 的核心注解，主要组合了以下 3 个注解：</p>
<ol>
<li><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
</li>
<li><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p>
</li>
<li><p>@ComponentScan：Spring组件扫描。不配置默认扫描@SpringBootApplication所在类的同级目录以及它的子目录(这很重要,后面很应用到这个特性)。当然你也可以自己指定要扫描的包目录，例如：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.lqr.demo1"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>开启 Spring Boot 特性有哪几种方式？</strong></p>
<p> 1）继承spring-boot-starter-parent项目</p>
<p> 2）导入spring-boot-dependencies项目依赖</p>
<p> 使用Spring Boot很简单，先添加基础依赖包，有以下两种方式</p>
<ol>
<li><p>继承spring-boot-starter-parent项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span></span></span><br><span class="line">    &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入spring-boot-dependencies项目依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p> <strong>Spring Boot依赖注意点</strong></p>
<ol>
<li><p>属性覆盖只对继承有效</p>
<p>Spring Boot依赖包里面的组件的版本都是和当前Spring Boot绑定的，如果要修改里面组件的版本，只需要添加如下属性覆盖即可，但这种方式只对继承有效，导入的方式无效。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.25<span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果导入的方式要实现版本的升级，达到上面的效果，这样也可以做到，把要升级的组件依赖放到Spring Boot之前。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        </span><br><span class="line">        <span class="comment">&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意，要修改Spring Boot的依赖组件版本可能会造成不兼容的问题。</p>
</li>
<li><p>资源文件过滤问题</p>
<blockquote>
<p><a href="https://blog.csdn.net/zsensei/article/details/78081000" target="_blank" rel="noopener">Maven 资源文件（Resources）的打包（package）与过滤（filter）</a></p>
<p> <a href="https://www.cnblogs.com/now-fighting/p/4888343.html" target="_blank" rel="noopener">Maven学习-处理资源文件</a></p>
</blockquote>
<p>有时候，我们的资源文件中设置的值，只能在构建项目的时候才会被指定。为了完成这个需求，在Maven中可以为这个需要在构建的时候才可以确定值的位置，放置一个占位符，来表示这个未来会被设置的值。通过使用<code>${property}</code>的方式指定。其中<code>property</code>可以是指定在<code>pom.xml</code>文件中的值，或者是在<code>setting.xml</code>文件中设置的值，或者是放在项目的filters目录（参考<a href="http://www.cnblogs.com/now-fighting/p/4858982.html" target="_blank" rel="noopener">Maven的项目目录结构</a>）下的外部的properties文件中的值，亦或是一个系统属性。这种方式在Maven中称为对资源文件的过滤。</p>
<p>使用继承Spring Boot时，如果要使用 Maven resource filter 过滤资源文件时，资源文件里面的占位符为了使${}和Spring Boot区别开来，此时要用@…@包起来，不然无效。另外，@…@占位符在yaml文件编辑器中编译报错，所以使用继承方式有诸多问题，坑要慢慢趟。</p>
</li>
</ol>
</li>
<li><p><strong>Spring Boot 自动配置原理是什么？</strong></p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/gs2zLSH6m9ijO0-pP2sr9Q" target="_blank" rel="noopener">Spring Boot自动配置原理、实战</a></p>
<p><a href="https://www.bysocket.com/archives/2001/spring-boot-2-0-%e8%87%aa%e5%8a%a8%e9%85%8d%e7%bd%ae%e5%8e%9f%e7%90%86%e6%b5%85%e6%9e%90" target="_blank" rel="noopener">Spring Boot 2.0 自动配置原理浅析</a></p>
</blockquote>
<p> Spring Boot的自动配置注解是@EnableAutoConfiguration，<code>@EnableAutoConfiguration</code> 注解核心点是 <code>@Import</code> 的<strong>自动配置导入选择器</strong>类 <code>AutoConfigurationImportSelector</code> 。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, ...</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; configurations =</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            <span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), </span><br><span class="line">            <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">        </span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>AutoConfigurationImportSelector</code> 通过 <code>SpringFactoriesLoader.loadFactoryNames()</code> 核心方法读取 ClassPath 目录下面的 META-INF/spring.factories 文件。</p>
<p> spring.factories 文件中配置了 Spring Boot 所有的自动配置类的全类名，例如常见的Jpa 自动配置类 <code>JpaRepositoriesAutoConfiguration</code>、<code>WebMvcAutoConfiguration</code> Web MVC 自动配置类和<code>ServletWebServerFactoryAutoConfiguration</code> 容器自动配置类等 。查看Spring Boot自带的自动配置的包：找到 spring-boot-autoconfigure-x.x.x.RELEASE.jar，打开其中的META-INF/spring.factories文件会找到自动配置的映射。</p>
<p> 当 pom.xml 添加某 Starter 依赖组件的时候，就会自动触发该依赖的默认配置。</p>
</li>
<li><p><strong>你如何理解 Spring Boot 中的 Starters？</strong></p>
<p> Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。</p>
<p> Spring Boot 提供了很多 “开箱即用” 的 Starter 组件。<strong>Starter 组件是</strong>可被加载在应用中的 <strong>Maven 依赖项</strong>。只需要在 Maven 配置中添加对应的依赖配置，即可使用对应的 Starter 组件。例如，添加 <code>spring-boot-starter-web</code> 依赖，就可用于构建 REST API 服务，其包含了 Spring MVC 和 Tomcat 内嵌容器等。</p>
<p> 一个完整的 Starter 组件包括以下两点：</p>
<ul>
<li><p>提供自动配置功能的自动配置模块。</p>
</li>
<li><p>提供依赖关系管理功能的组件模块，即封装了组件所有功能，开箱即用。</p>
<p>starter 的 jar 包虽然很小，但它的 pom 文件中却包含了很多。starter 只不过是把我们某一模块，比如web 开发时所需要的所有JAR 包打包好给我们而已。不过它的厉害之处在于，能自动把配置文件搞好，不用我们手动配置。</p>
</li>
</ul>
</li>
<li><p><strong>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</strong></p>
<p>常见的日志框架：</p>
<ul>
<li><p>JUL（Java Util Logging）</p>
<p>虽然来自于官方，但实现过于简陋。</p>
</li>
<li><p>jboss-logging</p>
<p>自诞生之初就不是为了服务大众</p>
</li>
<li><p>Log4j</p>
<p>Log4j、SLF4j 和 Logback 的作者是同一个人 ceki，作者说 Log4j 太烂，他已经不想改了，重新写了一个升级版的框架，名字就叫 Logback。</p>
</li>
<li><p>Log4j2</p>
<p>Apache 出品的，设计很优秀，但太过于先进，很多框架对其支持不是很好，保不准就会出现一个不大不小的坑。Log4j2 为了追求极致的性能，在框架的设计上存在过度设计的嫌疑。</p>
</li>
</ul>
<p>SLF4J主要是为了给Java日志访问提供一个标准、规范的API框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架，例如Log4J和logback等。即 SLF4J 是日志门面， logback 是日志实现。</p>
<p>Spring Boot 支持 Java Util Logging, Log4j, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架。</p>
</li>
<li><p><strong>你如何理解 Spring Boot 配置加载顺序？</strong></p>
<p>  在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>  1）properties文件；</p>
<p>  2）YAML文件；</p>
<p>  3）系统环境变量；</p>
<p>  4）命令行参数；</p>
<p>  等等……</p>
<p>  <strong>配置属性加载的顺序如下：</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开发者工具 &#96;Devtools&#96; 全局配置参数；</span><br><span class="line"></span><br><span class="line">2、单元测试上的 &#96;@TestPropertySource&#96; 注解指定的参数；</span><br><span class="line"></span><br><span class="line">3、单元测试上的 &#96;@SpringBootTest&#96; 注解指定的参数；</span><br><span class="line"></span><br><span class="line">4、命令行指定的参数，如 &#96;java -jar springboot.jar --name&#x3D;&quot;Java技术栈&quot;&#96;；</span><br><span class="line"></span><br><span class="line">5、命令行中的 &#96;SPRING_APPLICATION_JSONJSON&#96; 指定参数, 如 &#96;java -Dspring.application.json&#x3D;&#39;&#123;&quot;name&quot;:&quot;Java技术栈&quot;&#125;&#39; -jar springboot.jar&#96;</span><br><span class="line"></span><br><span class="line">6、&#96;ServletConfig&#96; 初始化参数；</span><br><span class="line"></span><br><span class="line">7、&#96;ServletContext&#96; 初始化参数；</span><br><span class="line"></span><br><span class="line">8、JNDI参数（如 &#96;java:comp&#x2F;env&#x2F;spring.application.json&#96;）；</span><br><span class="line"></span><br><span class="line">9、Java系统参数（来源：&#96;System.getProperties()&#96;）；</span><br><span class="line"></span><br><span class="line">10、操作系统环境变量参数；</span><br><span class="line"></span><br><span class="line">11、&#96;RandomValuePropertySource&#96; 随机数，仅匹配：&#96;ramdom.*&#96;；</span><br><span class="line"></span><br><span class="line">12、JAR包外面的配置文件参数（&#96;application-&#123;profile&#125;.properties（YAML）&#96;）</span><br><span class="line"></span><br><span class="line">13、JAR包里面的配置文件参数（&#96;application-&#123;profile&#125;.properties（YAML）&#96;）</span><br><span class="line"></span><br><span class="line">14、JAR包外面的配置文件参数（&#96;application.properties（YAML）&#96;）</span><br><span class="line"></span><br><span class="line">15、JAR包里面的配置文件参数（&#96;application.properties（YAML）&#96;）</span><br><span class="line"></span><br><span class="line">16、&#96;@Configuration&#96;配置文件上 &#96;@PropertySource&#96; 注解加载的参数；</span><br><span class="line"></span><br><span class="line">17、默认参数（通过 &#96;SpringApplication.setDefaultProperties&#96; 指定）；</span><br></pre></td></tr></table></figure>

<p>  <strong>数字小的优先级越高，即数字小的会覆盖数字大的参数值，我们来实践下，验证以上配置参数的加载顺序。</strong></p>
</li>
<li><p><strong>Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</strong></p>
<ul>
<li><p>依赖 JDK 版本升级</p>
<p>2.x 至少需要 JDK 8 的支持，2.x 里面的许多方法应用了 JDK 8 的许多高级新特性，所以你要升级到 2.0 版本，先确认你的应用必须兼容 JDK 8。</p>
<p>另外，2.x 开始了对 JDK 9 的支持。</p>
</li>
<li><p>第三方类库升级</p>
<p>2.x 对第三方类库升级了所有能升级的最新稳定版本。</p>
<p>1) Spring Framework 5+</p>
<p>2) Tomcat 8.5+</p>
<p>3) Flyway 5+</p>
<p>4) Hibernate 5.2+</p>
<p>5) Thymeleaf 3+</p>
</li>
<li><p>响应式 Spring 编程支持</p>
</li>
<li><p>HTTP/2 支持</p>
</li>
</ul>
</li>
<li><p><strong>过滤器、拦截器的区别</strong></p>
<p> spring 的拦截器和 servlet 的过滤器 Filter 有相似之处，比如二者都是 AOP 编程思想的体现。</p>
<ol>
<li><p>使用范围不同</p>
<p>Filter 是 servlet 规范定义的，只能用于 web 程序中；而拦截器既可以y用于 web 程序，也可以用于 application、swing 程序中。</p>
</li>
<li><p>规范不同</p>
<p>Filter 是在 servlet 规范中定义的，定义在 javax.servlet 包中，是 servlet 容器支持的，由 Server(Tomcat) 调用；而拦截器是 spring 容器内的，定义在org.springframework.web.servlet 包中，是 spring 框架支持的，由 Spring 调用。因此 Filter 总是优先于 Interceptor 执行。</p>
</li>
<li><p>使用的资源不同</p>
<p>拦截器是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如 Service对象、数据源、事务管理等，通过IoC注入到拦截器即可，而 Filter 则不能。</p>
</li>
<li><p>深度不同</p>
<p>Filter在只在 Servlet 前后起作用。拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。</p>
<p>过滤器拦截器执行顺序： </p>
<p><img data-src="https://img-blog.csdn.net/20180418181054330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hld2VpbWluZ21pbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><img data-src="https://s2.51cto.com/wyfs02/M02/8B/3D/wKiom1hHhbmxseDtAACidU9Y84s787.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h3><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<h3 id="Redis-五种基本数据结构"><a href="#Redis-五种基本数据结构" class="headerlink" title="Redis 五种基本数据结构"></a>Redis 五种基本数据结构</h3><blockquote>
<p><a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16" target="_blank" rel="noopener">通俗易懂的Redis数据结构基础教程</a></p>
</blockquote>
<ol>
<li><p>String 字符串</p>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<p>常用命令: <code>set,get,decr,incr,mget</code> 等。</p>
</li>
</ol>
<p>  使用场景：常规key-value缓存应用； 常规计数：微博数，粉丝数等，计数器是有范围的，它不能超过Long.Max，不能低于Long.MIN。</p>
<ol start="2">
<li><p>Hash 字典</p>
<p>哈希等价于Java语言的HashMap，在实现结构上它使用二维结构，第一维是数组，第二维是链表，hash的内容key和value存放在链表中，数组里存放的是链表的头指针。通过key查找元素时，先计算key的hashcode，然后用hashcode对数组的长度进行取模定位到链表的表头，再对链表进行遍历获取到相应的value值，链表的作用就是用来将产生了「hash碰撞」的元素串起来。Java语言开发者会感到非常熟悉，因为这样的结构和HashMap是没有区别的。哈希的第一维数组的长度也是2^n。hash特别适合用于存储对象。 比如我们可以用Hash数据结构来存储用户信息，商品信息等等。</p>
<p>当hash内部的元素比较拥挤时(hash碰撞比较频繁)，就需要进行扩容。扩容需要申请新的两倍大小的数组，然后将所有的键值对重新分配到新的数组下标对应的链表中(rehash)。如果hash结构很大，比如有上百万个键值对，那么一次完整rehash的过程就会耗时很长。这对于单线程的Redis里来说有点压力山大。所以Redis采用了渐进式rehash的方案。它会同时保留两个新旧hash结构，在后续的定时任务以及hash结构的读写指令中将旧结构的元素逐渐迁移到新的结构中。这样就可以避免因扩容导致的线程卡顿现象。</p>
<p>常用命令： <code>hget,hset,hgetall</code> 等。</p>
<p>举个例子： 最近做的一个电商网站项目的首页就使用了redis的hash数据结构进行缓存，因为一个网站的首页访问量是最大的，所以通常网站的首页可以通过redis缓存来提高性能和并发量。</p>
</li>
<li><p>List 列表</p>
<p>Redis将列表数据结构命名为list而不是array，是因为列表的存储结构用的是链表而不是数组，而且链表还是双向链表。因为它是链表，所以随机定位性能较弱，首尾插入删除性能较优。如果list的列表长度很长，使用时我们一定要关注链表相关操作的时间复杂度。如果再深入一点，你会发现Redis底层存储的还不是一个简单的linkedlist，而是称之为快速链表quicklist的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。所以Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<p>常用命令: <code>lpush,rpush,lpop,rpop,lrange</code>等</p>
<p>应用场景：微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。在日常应用中，列表常用来作为异步队列来使用。</p>
</li>
<li><p>Set 集合</p>
<p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。Java程序员都知道HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<p>常用命令：<code>sadd,spop,smembers,sunion</code> 等</p>
<p>应用场景：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p>
</li>
<li><p>Sorted Set 有序集合</p>
<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重<code>score</code>，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层实现使用了两个数据结构，第一个是hash，第二个是跳跃列表，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。跳跃列表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<p>常用命令： <code>zadd,zrange,zrem,zcard</code>等</p>
<p>应用场景：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</p>
</li>
</ol>
<h3 id="数据淘汰-内存回收-策略"><a href="#数据淘汰-内存回收-策略" class="headerlink" title="数据淘汰(内存回收)策略"></a>数据淘汰(内存回收)策略</h3><blockquote>
<p><a href="https://blog.csdn.net/yangshangwei/article/details/82890682" target="_blank" rel="noopener">Redis-17Redis内存回收策略</a></p>
</blockquote>
<p>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 </li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 </li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 </li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ol>
<p>Redis 在默认情况下会采用 noeviction 策略。换句话说，如果内存己满 ， 则不再提供写入操作 ， 而只提供读取操作 。 可以采用 <code>config set maxmemory-policy {policy}</code> 命令来动态配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.4&gt;config set maxmemory-policy volatile-lru</span><br><span class="line">"OK"</span><br></pre></td></tr></table></figure>

<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><blockquote>
<p><a href="http://einverne.github.io/post/2017/04/redis-command.html" target="_blank" rel="noopener">Redis 常用命令 </a></p>
</blockquote>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）。前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘。</p>
<ul>
<li><p>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</p>
</li>
<li><p>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</p>
</li>
<li><p>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</p>
</li>
<li><p>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据，因为AOF的数据更准确。</p>
</li>
<li><p>RDB 方式可以保存过去一段时间内的数据，并且保存结果是一个单一的文件，可以将文件备份到其他服务器，并且在回复大量数据的时候，RDB 方式的速度会比 AOF 方式的回复速度要快。</p>
</li>
<li><p>AOF 方式默认每秒钟备份 1 次，频率很高，它的操作方式是以追加的方式记录日志而不是数据，并且它的重写过程是按顺序进行追加，所以它的文件内容非常容易读懂。</p>
</li>
<li><p>RDB 由于备份频率不高，所以在恢复数据的时候有可能丢失一小段时间的数据，而且在数据集比较大的时候有可能对毫秒级的请求产生影响。</p>
</li>
<li><p>AOF 的文件体积比较大，而且由于保存频率很高，所以整体的速度会比 RDB 慢一些，但是性能依旧很高。</p>
</li>
</ul>
<h3 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h3><blockquote>
<p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">【原创】分布式之数据库和缓存双写一致性方案解析</a></p>
<p><a href="https://www.javazhiyin.com/22969.html" target="_blank" rel="noopener">如何保证缓存与数据库的双写一致性？</a></p>
</blockquote>
<p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p>
<p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p>
<p>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。<br>更新的时候，先删除缓存，然后更新数据库。</p>
<p>为什么是删除缓存，而不是更新缓存？</p>
<p>原因很简单，很多时候，复杂点的缓存的场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值。</p>
<p>另外更新缓存的代价有时候是很高的。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次，100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>
<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p>
<h3 id="Redis分区"><a href="#Redis分区" class="headerlink" title="Redis分区"></a>Redis分区</h3><p>分区是将你的数据分发到不同redis实例上的一个过程，每个redis实例只是你所有key的一个子集。</p>
<p>Redis分区主要有两个目的:</p>
<ul>
<li>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。</li>
<li>分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</li>
</ul>
<p><strong>分区类型</strong></p>
<p>有许多分区标准。假如我们有4个Redis实例<strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong>, <strong>R3</strong>,有一批用户数据<code>user:1</code>, <code>user:2</code>, … ,那么有很多存储方案可以选择。</p>
<ol>
<li><p><strong>范围分区：</strong>就是将不同范围的对象映射到不同Redis实例。比如说，用户ID从0到10000的都被存储到<strong>R0</strong>,用户ID从10001到20000被存储到<strong>R1</strong>,依此类推。</p>
</li>
<li><p><strong>散列分区：</strong></p>
<ul>
<li>使用散列函数 (如 <code>crc32</code> )将键名称转换为一个数字。例：键<code>foobar</code>, 使用<code>crc32(foobar)</code>函数将产生散列值<code>93024922</code>。</li>
<li>对转换后的散列值进行取模，以产生一个0到3的数字，以便可以使这个key映射到4个Redis实例当中的一个。<code>93024922 % 4</code> 等于 <code>2</code>, 所以 <code>foobar</code> 会被存储到第2个Redis实例。 <strong>R2</strong> <em>注意: 对一个数字进行取模，在大多数编程语言中是使用运算符%</em></li>
</ul>
</li>
</ol>
<ul>
<li>如果Redis只作为可<strong>伸缩缓存服务器</strong>来使用，那么用一致性哈希是非常容易的。</li>
<li>如果Redis被作为数据持久化服务器，<strong>需要提供节点和键值的固定映射，还有节点数目必须是固定的，不能改变。</strong>否则当增加或删除节点时，我们需要一个系统来为键重新分配节点，从2015年4月1日开始，Redis集群提供该特性。</li>
</ul>
<p><strong>分区实现</strong></p>
<ol>
<li><p>Redis 集群</p>
</li>
<li><p>Twemproxy</p>
<p><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy是Twitter维护的（缓存）代理系统</a>，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。</p>
<p>Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。</p>
<p>Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。</p>
<p>Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>
</li>
<li><p>支持一致性哈希的客户端</p>
<p>相对于Twemproxy，另一种可选的分区方案是在客户端实现一致性哈希或者其他类似算法。有很多客户端已经支持一致性哈希，如 <a href="https://github.com/redis/redis-rb" target="_blank" rel="noopener">Redis-rb</a> 和 <a href="https://github.com/nrk/predis" target="_blank" rel="noopener">Predis</a>.</p>
</li>
</ol>
<h3 id="Redis-Java-客户端"><a href="#Redis-Java-客户端" class="headerlink" title="Redis Java 客户端"></a>Redis Java 客户端</h3><p>Redis的Java客户端主要有 Redisson、Jedis、lettuce 等等，官方推荐使用Redisson。</p>
<p><strong>Spring Boot 2.0</strong>中 Redis 客户端驱动现在由 <strong>Jedis</strong>变为了 <strong>Lettuce</strong>，但依然支持 jedis。</p>
<p>Spring boot data-redis 依赖 jedis或Lettuce，实际上是对jedis这些客户端的封装，提供一套与客户端无关的api供应用使用，从而你在从一个redis客户端切换为另一个客户端，不需要修改业务代码。spring-boot-data-redis 内部实现了对Lettuce和jedis两个客户端的封装，默认使用的是Lettuce。</p>
<h4 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h4><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis,  JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作。</p>
<h3 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h3><blockquote>
<p><a href="https://www.jianshu.com/p/14835303b07e" target="_blank" rel="noopener">Redis集群方案总结</a></p>
</blockquote>
<p>集群的实现基础是 Redis 分区。</p>
<p>集群实现方式有三种：</p>
<ol>
<li><p>客户端分片</p>
<p>由客户端决定key写入或者读取的节点。包括jedis在内的一些客户端，实现了客户端分片机制。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/1521743-5490a7b34deae42c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/524/format/webp" alt="img"></p>
</li>
<li><p>基于代理的分片</p>
<p>客户端发送请求到一个代理，代理解析客户端的数据，将请求转发至正确的节点，然后将结果回复给客户端。例如：Twemproxy、codis。</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/1521743-5b8e35bb04543259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/529/format/webp" alt=""></p>
</li>
<li><p>路由查询</p>
<p>将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。如：Redis-cluster</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/1521743-204c4cc057006efa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt=""></p>
</li>
</ol>
<ul>
<li><p>twemproxy</p>
<p> 大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p>
</li>
<li><p>codis</p>
<p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。使用这套方案的公司：阿里云、ApsaraCache, RedisLabs、京东、百度等</p>
</li>
<li><p>redis cluster3.0自带的集群</p>
<p>特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>
</li>
<li><p>在业务代码层实现</p>
<p>起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，需要考虑节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控等等。</p>
</li>
</ul>
<p><strong>方案选择</strong></p>
<p>基于客户端的方案任何时候都要慎重考虑，在此我们不予推荐。</p>
<p>基于twemproxy的方案虽然看起来功能挺全面，但是实际使用中存在的问题同样很多，具体见上述，目前也不推荐再用twemproxy的方案。</p>
<p>codis在redis cluster出来之前应该是最理想的一种redis集群解决方案，但是codis需要采用其自身修改版的redis，因此这和redis社区版本会有差异，因此无法及时跟进redis社区版本更新，而对于那些自己对redis有所改动的用户来讲，那更不便使用codis。同时codis-proxy是go语言编写，在性能方面，尤其是耗时表现损耗较多。</p>
<p>redis cluster自redis 3.0推出以来，目前已经在很多生产环境上得到了应用，目前来讲，构建redis集群，推荐采用redis cluster搭配一款支持redis cluster的代理方案。</p>
<h3 id="Redis与消息队列"><a href="#Redis与消息队列" class="headerlink" title="Redis与消息队列"></a>Redis与消息队列</h3><blockquote>
<p><a href="https://segmentfault.com/a/1190000012244418" target="_blank" rel="noopener">用redis实现消息队列（实时消费+ack机制）</a></p>
</blockquote>
<p>尽量不要使用redis去做消息队列，这不是redis的设计目标。但实在太多人使用redis去做去消息队列。一般比较多的还是使用redis做缓存，比如秒杀系统，首页缓存等等。</p>
<p>首先做简单的引入，MQ（消息队列）主要是用来：</p>
<ul>
<li>解耦应用、</li>
<li>异步化消息</li>
<li>流量削峰填谷</li>
</ul>
<p>目前使用的较多的有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等。</p>
<p><strong>为什么要用Redis实现轻量级MQ？</strong></p>
<p>在业务的实现过程中，就算没有大量的流量，解耦和异步化几乎也是处处可用，此时MQ就显得尤为重要。但与此同时MQ也是一个蛮重的组件，例如我们如果用RabbitMQ就必须为它搭建一个服务器，同时如果要考虑可用性，就要为服务端建立一个集群，而且在生产如果有问题也需要查找功能。在中小型业务的开发过程中，可能业务的其他整个实现都没这个重。过重的组件服务会成倍增加工作量。所幸的是，<strong>Redis提供的list数据结构非常适合做消息队列。</strong></p>
<p><strong>生产者消费者模式</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/jia_costa/article/details/79030621" target="_blank" rel="noopener">利用redis实现消息队列之queue模式</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.229.128"</span>, <span class="number">6379</span>); </span><br><span class="line">		<span class="comment">// 向键为“test queue”的值的左端推入数据</span></span><br><span class="line">		jedis.lpush(<span class="string">"test queue"</span>, <span class="string">"message: hello redis queue"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.229.128"</span>, <span class="number">6379</span>);  </span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">// 设置超时时间为0，表示无限期阻塞</span></span><br><span class="line">			List&lt;String&gt; message = jedis.brpop(<span class="number">0</span>, <span class="string">"test queue"</span>);</span><br><span class="line">			System.out.println(message);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发布订阅模式</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/jia_costa/article/details/79033899" target="_blank" rel="noopener">利用redis实现消息队列之topic模式</a></p>
</blockquote>
<p>redis同样可以实现消息队列的发布订阅功能，发布消息者使用比较简单，订阅消息者则需要手动继承 redis.clients.jedis.JedisPubSub 这个抽象类，消费者有动作时就会回调这个实现类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.229.128"</span>, <span class="number">6379</span>); </span><br><span class="line">		<span class="comment">// 向“channel1”的频道发送消息, 返回订阅者的数量</span></span><br><span class="line">		Long publishCount = jedis.publish(<span class="string">"channel1"</span>, <span class="keyword">new</span> Date() + <span class="string">": hello redis channel1"</span>);</span><br><span class="line">		jedis.publish(<span class="string">"channel1"</span>,<span class="string">"close channel"</span>);</span><br><span class="line">		System.out.println(<span class="string">"发送成功，该频道有"</span> +publishCount + <span class="string">"个订阅者"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * channel频道接收到新消息后，执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行逻辑</span></span><br><span class="line">		System.out.println(channel + <span class="string">"频道发来消息："</span> + message);</span><br><span class="line">		<span class="comment">// 如果消息为 close channel， 则取消此频道的订阅</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"close channel"</span>.equals(message))&#123;</span><br><span class="line">			<span class="keyword">this</span>.unsubscribe(channel);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * channel频道有新的订阅者时执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(String channel, <span class="keyword">int</span> subscribedChannels)</span> </span>&#123;</span><br><span class="line">		System.out.println(channel + <span class="string">"频道新增了"</span>+ subscribedChannels +<span class="string">"个订阅者"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * channel频道有订阅者退订时执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUnsubscribe</span><span class="params">(String channel, <span class="keyword">int</span> subscribedChannels)</span> </span>&#123;</span><br><span class="line">		System.out.println(channel + <span class="string">"频道退订成功"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.229.128"</span>, <span class="number">6379</span>);</span><br><span class="line">		MessageHandler handler = <span class="keyword">new</span> MessageHandler();</span><br><span class="line">		jedis.subscribe(handler, <span class="string">"channel1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何实现ack机制？</strong></p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000012244418" target="_blank" rel="noopener">用redis实现消息队列（实时消费+ack机制）</a></p>
</blockquote>
<p><strong>ack</strong>，即消息确认机制(Acknowledge)。</p>
<p>首先来看RabbitMQ的ack机制：</p>
<ul>
<li>Publisher把消息通知给Consumer，如果Consumer已处理完任务，那么它将向Broker发送ACK消息，告知某条消息已被成功处理，可以从队列中移除。如果Consumer没有发送回ACK消息，那么Broker会认为消息处理失败，会将此消息及后续消息分发给其他Consumer进行处理(redeliver flag置为true)。</li>
<li>这种确认机制和TCP/IP协议确立连接类似。不同的是，TCP/IP确立连接需要经过三次握手，而RabbitMQ只需要一次ACK。</li>
<li>值的注意的是，RabbitMQ当且仅当检测到ACK消息未发出且Consumer的连接终止时才会将消息重新分发给其他Consumer，因此不需要担心消息处理时间过长而被重新分发的情况。</li>
</ul>
<p>那么在我们用Redis实现消息队列的ack机制的时候该怎么做呢？<br>需要注意两点：</p>
<ol>
<li>work处理失败后，要回滚消息到原始pending队列</li>
<li>假如worker挂掉，也要回滚消息到原始pending队列</li>
</ol>
<p>上面第一点可以在业务中完成，即失败后执行回滚消息。</p>
<p><strong>实现方案</strong></p>
<p>（该方案主要解决worker挂掉的情况）</p>
<ol>
<li>维护两个队列：pending队列和doing表（hash表）。</li>
<li>workers定义为ThreadPool。</li>
<li>由pending队列出队后，workers分配一个线程（单个worker）去处理消息——给目标消息append一个当前时间戳和当前线程名称，将其写入doing表，然后该worker去消费消息，完成后自行在doing表擦除信息。</li>
<li>启用一个定时任务，每隔一段时间去扫描doing队列，检查每个元素的时间戳，如果超时，则由worker的ThreadPoolExecutor去检查线程是否存在，如果存在则取消当前任务执行，并把事务rollback。最后把该任务从doing队列中pop出，再重新push进pending队列。</li>
<li>在worker的某线程中，如果处理业务失败，则主动回滚，并把任务从doing队列中移除，重新push进pending队列。</li>
</ol>
<h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><blockquote>
<p><a href="https://coding.imooc.com/lesson/117.html#mid=6404" target="_blank" rel="noopener">redis分布式锁</a></p>
</blockquote>
<p>针对分布式锁，目前有以下几种实现方案：</p>
<ol>
<li>基于数据库锁机制实现分布式锁 </li>
<li>基于缓存实现分布式锁 </li>
<li>基于zookeeper实现分布式锁</li>
</ol>
<p>说实话，如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用<strong>Redisson</strong>框架就好了，非常的简便易用。</p>
<p>非要自己实现的话就是使用 Redis 的 <a href="http://redis.cn/commands/hsetnx.html" target="_blank" rel="noopener">SETNX</a> 和 <a href="http://redis.cn/commands/getset.html" target="_blank" rel="noopener">GETSET</a> 这两个命令实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key	商品ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 当前时间+超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// SETNX再java中对应的是setIfAbsent</span></span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(key, value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String currentValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 如果锁过期</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(currentValue)</span><br><span class="line">                &amp;&amp; Long.parseLong(currentValue) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">// 获取上一个锁的时间</span></span><br><span class="line">            String oldValue = redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(oldValue) &amp;&amp; oldValue.equals(currentValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String currentValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(currentValue) &amp;&amp; currentValue.equals(value)) &#123;</span><br><span class="line">                redisTemplate.opsForValue().getOperations().delete(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"【redis分布式锁】解锁异常，&#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecKillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询秒杀或多特价商品的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">querySecKillProductInfo</span><span class="params">(String productId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟不同用户秒杀同一商品的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderProductMockDiffUser</span><span class="params">(String productId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SecKillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLock redisLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">10</span> * <span class="number">1000</span>; <span class="comment">// 超时时间 10s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Integer&gt; products;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Integer&gt; stock;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt; orders;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模拟多个表，商品信息表，库存表，秒杀成功订单表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        products = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        stock = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        orders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        products.put(<span class="string">"123456"</span>, <span class="number">100000</span>);</span><br><span class="line">        stock.put(<span class="string">"123456"</span>, <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">queryMap</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"国庆活动，皮蛋粥特价，限量份"</span></span><br><span class="line">                + products.get(productId)</span><br><span class="line">                + <span class="string">" 还剩："</span> + stock.get(productId) + <span class="string">" 份"</span></span><br><span class="line">                + <span class="string">" 该商品成功下单用户数目："</span></span><br><span class="line">                + orders.size() + <span class="string">" 人"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">querySecKillProductInfo</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryMap(productId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderProductMockDiffUser</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis()+TIMEOUT;</span><br><span class="line">        <span class="keyword">if</span> (!redisLock.lock(productId, String.valueOf(time)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(<span class="number">101</span>, <span class="string">"哎呦喂，人也太多了，换个姿势再试试~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 查询该商品库存，为0则活动结束</span></span><br><span class="line">        <span class="keyword">int</span> stockNum = stock.get(productId);</span><br><span class="line">        <span class="keyword">if</span> (stockNum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(<span class="number">100</span>, <span class="string">"活动结束"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 下单（模拟不同用户openid不同</span></span><br><span class="line">            orders.put(KeyUtil.genUniqueKey(), productId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 减库存</span></span><br><span class="line">            stockNum = stockNum -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stock.put(productId, stockNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        redisLock.unlock(productId, String.valueOf(time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁核心代码解析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key	商品ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 当前时间+超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SETNX再java中对应的是setIfAbsent</span></span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(key, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String currentValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 如果锁过期</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(currentValue)</span><br><span class="line">        &amp;&amp; Long.parseLong(currentValue) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 获取上一个锁的时间</span></span><br><span class="line">        String oldValue = redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldValue) &amp;&amp; oldValue.equals(currentValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>最原始的加锁其实只需要看 <code>SETNX</code> 是否成功即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SETNX再java中对应的是setIfAbsent</span></span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(key, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderProductMockDiffUser</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis()+TIMEOUT;</span><br><span class="line">    <span class="keyword">if</span> (!redisLock.lock(productId, String.valueOf(time)))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SellException(<span class="number">101</span>, <span class="string">"哎呦喂，人也太多了，换个姿势再试试~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    redisLock.unlock(productId, String.valueOf(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样会出现死锁的情况：当某个线程获取锁后在业务代码出现异常，此时解锁的代码就走不到了，锁就一直被占用了，就会出现死锁的情况。</p>
<p>为了解决这一问题，引入了超时时间，当死锁超过一定时间后让该锁自动失效，其他线程就可以抢占该锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SETNX再java中对应的是setIfAbsent</span></span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(key, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String currentValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 如果锁过期</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(currentValue)</span><br><span class="line">        &amp;&amp; Long.parseLong(currentValue) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是此时还存在线程安全问题：当死锁过期的时候如果有两个线程同时执行到了判断锁过期的 if 语句内，则这两个线程都将获得该锁，造成线程安全问题，导致数据不一致。</p>
<p>利用 Redis 的单线程特性可以防止该问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SETNX再java中对应的是setIfAbsent</span></span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(key, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String currentValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 如果锁过期</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(currentValue)</span><br><span class="line">        &amp;&amp; Long.parseLong(currentValue) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 获取上一个锁的时间</span></span><br><span class="line">        String oldValue = redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(oldValue) &amp;&amp; oldValue.equals(currentValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个线程同时走到判断锁过期的代码内，此时由于 Redis 是单线程的，只会有一个线程先执行 <code>GETSET</code> 命令，过去该锁，当另一个线程再执行 <code>GETSET</code> 后将会导致里面的 if 语句结果为 false，故最终只会有一个线程获得锁。</p>
</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>Redis缓存穿透是指查询一个一定不存在的数据，由于缓存不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>对于缓存穿透问题，通常有如下解决方案：</p>
<ol>
<li><p>可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。</p>
</li>
<li><p>如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。</p>
</li>
<li><p>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力。关于布隆过滤器，详情查看：基于BitSet的布隆过滤器(Bloom Filter) </p>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是<strong>大量缓存集中在一段时间内失效</strong>，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。</p>
<p>解决办法：</p>
<ol>
<li><p>这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布，设置不同的过期时间，比如超时时间是固定的5分钟加上随机的2分钟。</p>
</li>
<li><p>用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。在加锁方法内先从缓存中再获取一次，没有再查DB。 （当然也可以： 在没有获取锁的线程中一直轮询缓存，至超限时）</p>
</li>
<li><p>缓存的高可用性</p>
<p>缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。</p>
</li>
<li><p>缓存降级</p>
<p>可以利用ehcache等本地缓存(暂时使用)，但主要还需要对源服务访问进行限流、资源隔离(熔断)、降级等。</p>
<p>当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。降级的最终目的是保证核心服务可用，即使是有损的。</p>
</li>
<li><p>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>1、直接写个缓存刷新页面，上线时手工操作下；</p>
<p>2、数据量不大，可以在项目启动的时候自动进行加载；</p>
<p>3、定时刷新缓存；</p>
<h3 id="一致性-Hash-算法"><a href="#一致性-Hash-算法" class="headerlink" title="一致性 Hash 算法"></a>一致性 Hash 算法</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">面试必备：什么是一致性Hash算法？ - 知乎</a></p>
</blockquote>
<p>我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-e8e325f7395296718a69349b4a44e731_hd.jpg" alt="img"></p>
<p>假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下：</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-8b328ac9a5664f65132a063d6c459224_hd.jpg" alt="img"></p>
<p>如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如下：</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-bc6db15378a13b66a1ddaea68979762b_hd.jpg" alt="img"></p>
<p>上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为<code>hash(a.png) % 4 = 2</code> ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！</p>
<p><strong>Hash的问题</strong></p>
<p>使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！</p>
<p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-fd44ab71c834f3fe458a6f76f3997f98_hd.jpg" alt="img"></p>
<p>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-509993a49d447b378273e455a095de3c_hd.jpg" alt="img"></p>
<p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
<p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-4fab60735dfae0bf511709e9d337789b_hd.jpg" alt="img"></p>
<p>根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<p><strong>一致性Hash算法的容错性和可扩展性</strong></p>
<p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-4ebcb8c23bb64a60896bde87dd546214_hd.jpg" alt="img"></p>
<p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-9cdb1adc37eb1a54c114232120da1485_hd.jpg" alt="img"></p>
<p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<p><strong>Hash环的数据倾斜问题</strong></p>
<p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-d499324a9aa067915bbb3f5f3416b032_hd.jpg" alt="img"></p>
<p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p>
<p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-0368841e5020dd07f1e67f449b49a1ba_hd.jpg" alt="img"></p>
<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<h3 id="Hash槽"><a href="#Hash槽" class="headerlink" title="Hash槽"></a>Hash槽</h3><p>Redis Cluster 里面使用的方法，一个 Redis Cluster 包含16384（0~16383）个哈希槽，存储在Redis Cluster中的所有键都会被映射到这些slot中。</p>
<ul>
<li>redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value。</li>
<li>一共有16384个槽，每台服务器分管其中的一部分</li>
<li>插入一个数据的时候，先根据CRC16算法计算key对应的值，然后用该值对16384取余数（即CRC16(key) mod 16384），确定将数据放到哪个槽里面</li>
<li>在增加节点的时候，之前的节点各自分出一些槽给新节点，对应的数据也一起迁出</li>
</ul>
<p>为什么要选择的槽是16384个呢？<br>crc16会输出16bit的结果，可以看作是一个分布在0-2^16-1之间的数，redis的作者测试发现这个数对2^{14}求模的会将key在0-2^{14-1}之间分布得很均匀，因此选了这个值。</p>
<h3 id="面试常见问题-3"><a href="#面试常见问题-3" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><ol>
<li><p>Redis与Memcached的区别</p>
<blockquote>
<p><a href="http://blog.leanote.com/post/huangjiecong@163.com/Redis-%E5%92%8C-Memcache-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">Redis 和 Memcache 的区别</a></p>
</blockquote>
<ol>
<li><p>数据类型支持不同</p>
<p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。</p>
</li>
<li><p>内存管理机制不同</p>
<p>Redis支持数据的备份，即master-slave模式的数据备份；</p>
</li>
<li><p>数据持久化支持</p>
<p>Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。而memcached是不支持数据持久化操作的。</p>
</li>
<li><p>集群管理的不同</p>
<p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。</p>
<p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。</p>
</li>
<li><p>网络IO模型不同</p>
<p>memcached是多线程，非阻塞IO复用的网络模型。redis使用单线程的IO复用模型。</p>
<p>redis使用的是单线程模型，保证了数据按顺序提交。<br>memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作 </p>
</li>
<li><p>value大小不同</p>
<p>redis最大可以达到1GB，而memcache只有1MB</p>
</li>
<li><p>性能比较</p>
<p>Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</p>
</li>
</ol>
</li>
</ol>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h3><blockquote>
<p><a href="https://blog.csdn.net/weixin_36571185/article/details/78554514" target="_blank" rel="noopener">浅谈Mybatis之mybatis是什么？</a></p>
</blockquote>
<p>MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来。</p>
<p>MyBatis是在Apache许可证 2.0下分发的自由软件，是iBATIS 3.0的分支版本。其维护团队也包含iBATIS的初创成员。</p>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/3/12/1621790903a0654f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="MyBatis的优点"><a href="#MyBatis的优点" class="headerlink" title="MyBatis的优点"></a>MyBatis的优点</h3><ol>
<li><p>MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。</p>
</li>
<li><p>MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。</p>
</li>
<li><p>因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。</p>
</li>
</ol>
<h3 id="接口绑定"><a href="#接口绑定" class="headerlink" title="接口绑定"></a>接口绑定</h3><p>MyBatis的接口绑定就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.</p>
<p>接口绑定有两种方式：一种是通过注解绑定,就是在接口的方法上面加上 <code>@Select</code> 、<code>@Update</code> 等注解里面包含Sql语句来绑定。另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<p>当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定.</p>
<h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--association  一对一关联查询 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>  </span><br><span class="line">        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--collection  一对多关联查询 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass2"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>  </span><br><span class="line">        select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"com.lcb.user.Student"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><blockquote>
<p><a href="https://blog.csdn.net/luanlouis/article/details/41390801" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis缓存机制的设计与实现</a></p>
<p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">聊聊MyBatis缓存机制</a></p>
</blockquote>
<p>MyBatis的查询缓存机制，根据缓存区的作用域（生命周期）可划分为两种：一级缓存与二级缓存</p>
<p> 一级缓存是Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）；</p>
<p>二级缓存是Application应用级别的缓存，它的生命周期很长，跟Application的声明周期一样，也就是说它的作用范围是整个Application应用。</p>
<p><strong>MyBatis</strong>中一级缓存和二级缓存的组织如下图所示：</p>
<p><img data-src="https://img-blog.csdn.net/20141122222537708" alt=""></p>
<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><blockquote>
<p><a href="https://blog.csdn.net/luanlouis/article/details/41280959" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的一级缓存实现详解 及使用注意事项</a></p>
</blockquote>
<p>每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话。</p>
<p>为了减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p>
<p>实际上, SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。SqlSession、Executor、Cache之间的关系：<strong>Executor</strong>接口的实现类<strong>BaseExecutor</strong>中拥有一个<strong>Cache</strong>接口的实现类<strong>PerpetualCache</strong>，对于<strong>BaseExecutor</strong>对象而言，它将使用<strong>PerpetualCache</strong>对象维护缓存。</p>
<p><img data-src="https://img-blog.csdn.net/20141120100824184" alt=""></p>
<p><strong>一级缓存配置</strong></p>
<p>只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>SESSION</code>或者<code>STATEMENT</code>，默认是<code>SESSION</code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是<code>STATEMENT</code>级别，可以理解为缓存只对当前执行的这一个<code>Statement</code>有效。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>一级缓存的生命周期</strong></p>
<ul>
<li><p>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</p>
</li>
<li><p>如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；</p>
</li>
<li><p>如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；</p>
</li>
<li><p>SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；</p>
</li>
</ul>
<p><strong>一级缓存的工作流程：</strong></p>
<ol>
<li><p>对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果；</p>
</li>
<li><p>判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；</p>
</li>
<li><p>如果命中，则直接将缓存结果返回；</p>
</li>
<li><p>如果没命中：</p>
<p> 4.1  去数据库中查询数据，得到查询结果；</p>
<p> 4.2  将key和查询到的结果分别作为key,value对存储到Cache中；</p>
<p> 4.3. 将查询结果返回；</p>
</li>
<li><p>结束。</p>
</li>
</ol>
<p><strong>Cache接口的设计以及CacheKey的定义</strong><br>MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。</p>
<p>Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。现在最核心的问题出现了：怎样来确定一次查询的特征值？换句话说就是：怎样判断某两次查询是完全相同的查询？也可以这样说：如何确定Cache中的key值？</p>
<p>MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询：</p>
<ol>
<li><p>传入的 statementId </p>
</li>
<li><p>查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）；</p>
</li>
<li><p>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）</p>
</li>
<li><p>传递给java.sql.Statement要设置的参数值</p>
</li>
</ol>
<p>现在分别解释上述四个条件：</p>
<ol>
<li><p>传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql；</p>
</li>
<li><p>MyBatis自身提供的分页功能是通过RowBounds来实现的，它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页；</p>
</li>
</ol>
<p>由于MyBatis底层还是依赖于JDBC实现的，那么，对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。</p>
<p>上述的第3个条件正是要求保证传递给JDBC的SQL语句完全一致；第4条则是保证传递给JDBC的参数也完全一致；</p>
<p>综上所述,CacheKey由以下条件决定：<strong>statementId  + rowBounds  + 传递给JDBC的SQL  + 传递给JDBC的参数值</strong></p>
<p><strong>总结</strong></p>
<ol>
<li>MyBatis一级缓存的生命周期和SqlSession一致。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
</ol>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><blockquote>
<p><a href="https://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的二级缓存的设计原理</a></p>
</blockquote>
<p>当开启一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。如果用户配置了”cacheEnabled=true”，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。</p>
<p><strong>二级缓存配置</strong></p>
<p>要正确的使用二级缓存，需完成如下配置的。</p>
<ol>
<li><p>在MyBatis的配置文件中开启二级缓存。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在MyBatis的映射XML中配置cache或者 cache-ref 。</p>
<p> cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过。</p>
</li>
<li><p><code>eviction</code>： 定义回收的策略，常见的有FIFO，LRU。</p>
</li>
<li><p><code>flushInterval</code>： 配置一定时间自动刷新缓存，单位是毫秒。</p>
</li>
<li><p><code>size</code>： 最多缓存对象的个数。</p>
</li>
<li><p><code>readOnly</code>： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</p>
</li>
<li><p><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</p>
<p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><strong>MyBatis二级缓存的划分</strong><br>MyBatis并不是简单地对整个Application就只有一个Cache缓存对象，它将缓存划分的更细，即是Mapper级别的，即每一个Mapper都可以拥有一个Cache对象，具体如下：</p>
<p>a.为每一个Mapper分配一个Cache缓存对象（使用<code>&lt;cache&gt;</code>节点配置）；</p>
<p>b.多个Mapper共用一个Cache缓存对象（使用<code>&lt;cache-ref&gt;</code>节点配置）；</p>
<p><strong>使用二级缓存，必须要具备的条件</strong><br>MyBatis对二级缓存的支持粒度很细，它会指定某一条查询语句是否使用二级缓存。虽然在Mapper中配置了<code>&lt;cache&gt;</code>,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在<code>&lt;select&gt;</code> 节点中配置useCache=”true”，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。如下所示，Select语句配置了useCache=”true”，则表明这条Select语句的查询会使用二级缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByMinSalary"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总之，要想使某条Select查询支持二级缓存，你需要保证：</p>
<pre><code>1.  MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true

2.  该select语句所在的Mapper，配置了`&lt;cache&gt;` 或`&lt;cached-ref&gt;`节点，并且有效

3.  该select语句的参数 useCache=true</code></pre><p><strong>一级缓存和二级缓存的使用顺序</strong><br>请注意，如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存。</p>
<p><strong>二级缓存实现的选择</strong><br>MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等；另外，MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在<code>&lt;cache  type=&quot;&quot;&gt;</code>节点的type属性上即可；除此之外，MyBatis还支持跟第三方内存缓存库如Memecached的集成，总之，使用MyBatis的二级缓存有三个选择:</p>
<ol>
<li>MyBatis自身提供的缓存实现；</li>
<li>用户自定义的Cache接口实现；</li>
<li>跟第三方内存缓存库的集成；</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><p>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</p>
</li>
<li><p>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</p>
<p>通常我们会为每个单表创建单独的映射文件，由于MyBatis的二级缓存是基于<code>namespace</code>的，多表查询语句所在的<code>namspace</code>无法感应到其他<code>namespace</code>中的语句对多表查询中涉及的表进行的修改，引发脏数据问题。</p>
</li>
<li><p>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</p>
</li>
</ol>
<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><blockquote>
<p><a href="https://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html" target="_blank" rel="noopener">Mybatis解析动态sql原理分析</a></p>
</blockquote>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<ul>
<li><p><code>&lt;foreach&gt;</code></p>
<p>foreach的主要用在构建 in 条件中，它可以在SQL语句中进行迭代一个集合。<br>foreach元素的属性主要有 item，index，collection，open，separator，close。<br>item表示集合中每一个元素进行迭代时的别名，index指定一个名字，用于表示在迭代过程中，每次迭代到的位置，open表示该语句以什么开始，separator表示在每次进行迭代之间以什么符号作为分隔 符，close表示以什么结束，在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p>
<ol>
<li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li>
<li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li>
<li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map</li>
</ol>
</li>
</ul>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><blockquote>
<p><a href="https://pagehelper.github.io/docs/howtouse/" target="_blank" rel="noopener">如何使用分页插件 PageHelper</a></p>
<p><a href="https://blog.csdn.net/gnail_oug/article/details/80229542" target="_blank" rel="noopener">Spring Boot教程(八)：Spring Boot集成pagehelper分页插件</a></p>
</blockquote>
<ol>
<li><p>添加pagehelper依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 application.yml 配置文件中添加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pagehelper分页插件配置</span></span><br><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line">  <span class="attr">helperDialect:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">reasonable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">supportMethodsArguments:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">params:</span> <span class="string">count=countSql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Mapper 查询接口调用前增加 <code>PageHelper.startPage(pageNo,pageSize);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">lists</span><span class="params">(@RequestParam(defaultValue = <span class="string">"1"</span>)</span> <span class="keyword">int</span> pageNo, @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"10"</span>)</span> <span class="keyword">int</span> pageSize) </span>&#123;</span><br><span class="line">    PageHelper.startPage(pageNo,pageSize);</span><br><span class="line">    <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，分页代码 <code>PageHelper.startPage(pageNo,pageSize);</code> 只对其后的第一个查询有效。</p>
</li>
<li><p>返回分页信息</p>
<p>上面我们返回的只是数据，而总页数、当前页数、每页条数等分页相关的信息并没有返回。</p>
<p>下面我们对controller、service、mapper里的方法的返回值做一下修改，将 <code>List&lt;User&gt;</code> 改为<code>Page&lt;User&gt;</code>，Page是 com.github.pagehelper 包里的类，它是 java.util.ArrayList 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PageInfo&lt;User&gt; <span class="title">lists</span><span class="params">(@RequestParam(defaultValue = <span class="string">"1"</span>)</span> <span class="keyword">int</span> pageNo,@<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"10"</span>)</span> <span class="keyword">int</span> pageSize) </span>&#123;</span><br><span class="line">    PageHelper.startPage(pageNo,pageSize);</span><br><span class="line">    PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(userService.getUsers());</span><br><span class="line">    <span class="keyword">return</span> pageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdn.net/20180507181922378?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2duYWlsX291Zw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>MyBatis Plus 中的分页</p>
<blockquote>
<p><a href="https://mp.baomidou.com/guide/page.html" target="_blank" rel="noopener">分页插件</a></p>
<p><a href="https://libo9527.github.io/2018/12/25/Study-Notes-of-Guns/#%E5%90%8E%E7%AB%AF%E5%88%86%E9%A1%B5" target="_blank" rel="noopener">后端分页</a></p>
</blockquote>
</li>
</ol>
<h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><blockquote>
<p><a href="https://my.oschina.net/zjllovecode/blog/1818716" target="_blank" rel="noopener">需要注意的 Mybatis 批量插入</a></p>
</blockquote>
<p>Mybatis 批量插入通过 foreach 标签，将多条数据拼接在sql 语句后，一次执行只获取一次session,提交一条sql语句。减少了程序和数据库交互的准备时间。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span> &gt;</span></span><br><span class="line">	insert into user(name,age) values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (#&#123;item.name&#125;, #&#123;item.age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>首先是返回值</p>
<p><strong>对于普通的单条插入，数据库的返回值就是 （0/1） 。</strong></p>
<p>对于返回值代表的意思可以认为是“语句执行返回的数据库受影响的行数。”或者是“此次执行是否成功（0-失败，1-成功）。”对应的也就是在Dao层中，对于插入方法的返回值类型的设定有（int/boolean）两种。</p>
<p><strong>对于批量插入的返回值，返回的还是（0/1）,而不是统计插入成功几条，即使你的Dao层方法的返回值类型为int.</strong></p>
<p>这里的（0/1） 也就代表着，这次批量插入是否成功（0-失败，1-成功）。当然你Dao层的返回值还是可以是（int/boolean）</p>
</li>
<li><p>对于批量插入中间有一个失败会怎么样</p>
<p>批量语句，只要有一个失败，就会全部失败。数据库会回滚全部数据。</p>
<p>其实也很好理解。首先我们知道了mybatis <code>&lt;foreache&gt;</code>批量插入，是在程序内拼接sql 语句（拼接成多条同时插入的sql语句），拼接后发给数据库。就相当于咱们自己在mysql的命令行中，执行一条多插入的语句。默认情况下 mysql 单条语句是一个事务，这在一个事务范围内，当中间的sql语句有问题，或者有一个插入失败，就会触发事务回滚。同时你也能看到错误提示。（命令行执行单条sql的情况）所以有一个插入不成功肯定全部回滚。</p>
</li>
<li><p>批量插入数据量的限制</p>
<blockquote>
<p><a href="https://blog.csdn.net/syy_c_j/article/details/52151402" target="_blank" rel="noopener">Mybatis 批量插入引发的血案</a></p>
</blockquote>
<p><strong>1）、Mybatis 本身对插入的数据量没有限制</strong></p>
<p><strong>2）、mysql对语句的长度有限制，默认是 4M</strong></p>
<p>其他数据库的情况这里不介绍，可以自行百度。通过上面 “mysql对语句的长度有限制，默认是 4M” 我们可以知道，批量插入数据是有限制的。不能一下把几万条数据（就是太大数据量意思）一次性插入。</p>
<p><strong>所以一般情况下我们推荐即使使用批量插入，也要分批次。</strong></p>
<p>每次批次设置多少？需要根据你的插入一条数据的参数量来做度量。因为受限条件是sql语句的长度。而且分批插入更加合理，对于插入失败，回滚范围会缩小很多。</p>
</li>
<li><p>为了保证程序健壮性，对空集合参数的校验</p>
<p>Mybatis并没有做集合容量的验证，如果集合参数为空或者size为0则生成的sql可能只有”insert into user(name,age) values”这样一段或者没有，所以说，写批量sql的时候注意在调用批量方法的地方加入对容量的验证。</p>
</li>
<li><p>mybatis批量插入的另外一种不推荐的写法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addBatchUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">        insert into user(name,age) values(#&#123;item.name&#125;,#&#123;item.age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种写法也能实现批量插入。但是有很多问题。</p>
<p>a、首先这种方式的批量插入也是sql拼接。但是明显<strong>字符长度增加。这就导致每批次可插入的数量减少</strong></p>
<p>b、这种方式执行返回值还是（0、1）是已经尝试插入的最后一条数据是否成功。由于这种foreach 拼接成的sql语句，是以分号“；”分隔的多条insert语句。这就导致前面的数据项都插入成功了。（<strong>默认数据库的事务处理是单条提交的</strong>，出错前的执行都是一个个单条语句，所以并并没有回滚数据。）</p>
<p>所以如果中间插入失败回滚的话，需要使用Spring事务，但是还需要注意spring事务是抛出运行时异常时才会回滚。这种批量插入中间有没插入成功的是不会抛出异常的。所以你需要根据返回值判断手动编码抛出异常。而最上面的那种写法就不用用spring事务，因为他是一条sql语句。</p>
</li>
</ol>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ol>
<li><p><strong>MyBatis和Hibernate的区别</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/eff666/article/details/71332386" target="_blank" rel="noopener">MyBatis与Hibernate区别</a></p>
</blockquote>
<ol>
<li><p>hibernate是全自动，而mybatis是半自动</p>
<p>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。Hibernate 真正实现了java代码和sql的分离。</p>
</li>
<li><p>hibernate数据库移植性远大于mybatis</p>
<p>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</p>
</li>
<li><p>hibernate拥有完整的日志系统，mybatis则欠缺一些</p>
<p>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</p>
</li>
<li><p>mybatis相比hibernate需要关心很多细节</p>
<p>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</p>
</li>
<li><p>sql直接优化上，mybatis要比hibernate方便很多</p>
<p>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</p>
</li>
<li><p>缓存机制上，hibernate要比mybatis更好一些</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>而Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。</p>
</li>
</ol>
</li>
<li><p><strong>#{}和${}的区别是什么？</strong></p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000004617028" target="_blank" rel="noopener">mybatis深入理解(一)之 # 与 $ 区别以及 sql 预编译</a></p>
</blockquote>
<p><strong>动态 SQL</strong> 是 mybatis 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。</p>
<p>在动态 SQL 解析阶段， #{ } 和 ${ } 会有不同的表现：</p>
<blockquote>
<p><strong>#{ } 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符。</strong></p>
</blockquote>
<p>例如，sqlMap 中如下的 sql 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where name &#x3D; #&#123;name&#125;;</span><br></pre></td></tr></table></figure>

<p>解析为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where name &#x3D; ?;</span><br></pre></td></tr></table></figure>

<p>一个 #{ } 被解析为一个参数占位符 <code>?</code> 。</p>
<p>而，</p>
<blockquote>
<p><strong>${ } 仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换</strong></p>
</blockquote>
<p>例如，sqlMap 中如下的 sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where name &#x3D; &#39;$&#123;name&#125;&#39;;</span><br></pre></td></tr></table></figure>

<p>当我们传递的参数为 “ruhua” 时，上述 sql 的解析为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where name &#x3D; &quot;ruhua&quot;;</span><br></pre></td></tr></table></figure>

<p>预编译之前的 SQL 语句已经不包含变量 name 了。</p>
<p>综上所得， ${ } 的变量的替换阶段是在动态 SQL 解析阶段，而 #{ }的变量的替换是在 DBMS 中。</p>
<p>总结：</p>
<ol>
<li>#{}是预编译处理，${}是字符串替换。</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>Mybatis在处理${}时，就是把${}替换成变量的值。当需要直接插入一个不做任何修改的字符串到SQL语句中，例如在ORDER BY后接一个不添加引号的值作为列名，这时候就需要使用${}。</li>
<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ol>
</li>
<li><p><strong>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></p>
<p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectorder"</span> <span class="attr">parametertype</span>=<span class="string">"int"</span> <span class="attr">resultetype</span>=<span class="string">"me.gacl.domain.order"</span>&gt;</span> </span><br><span class="line">    select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> 123</span><br></pre></td></tr></table></figure>

<p>第2种： 通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type&#x3D;&quot;me.gacl.domain.order&quot; id&#x3D;&quot;orderresultmap&quot;&gt; </span><br><span class="line">    &lt;!--用id属性来映射主键字段--&gt; </span><br><span class="line">	&lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;order_id&quot;&gt; </span><br><span class="line">	&lt;!--用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性--&gt; </span><br><span class="line">	&lt;result property&#x3D;&quot;orderno&quot; column &#x3D;”order_no&quot;&#x2F;&gt; </span><br><span class="line">	&lt;result property&#x3D;&quot;price&quot; column&#x3D;&quot;order_price&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;reslutMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;getOrder&quot; parameterType&#x3D;&quot;int&quot; resultMap&#x3D;&quot;orderresultmap&quot;&gt;</span><br><span class="line">    select * from orders where order_id&#x3D;#&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模糊查询like语句该怎么写?</strong></p>
<p>第1种：在Java代码中添加sql通配符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string wildcardname = “%smi%”; </span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span> </span><br><span class="line"> select * from foo where bar like #&#123;value&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第2种：在sql语句中拼接通配符，会引起sql注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string wildcardname = “smi”; </span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span> </span><br><span class="line"> select * from foo where bar like "%"#&#123;value&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第3种：MySQL的 CONCAT() 函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string wildcardname = “smi”; </span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span> </span><br><span class="line"> select * from foo where bar like  CONCAT('%', #&#123;value&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第4种：Mybatis 的 bind，bind 标签可以将OGNL(对象图导航语言)表达式的值绑定到一个变量中，方便以后引用这个变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">string wildcardname = “smi”; </span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBykeyWord"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"com.why.mybatis.entity.RoleEntity"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + value + '%'"</span> /&gt;</span></span><br><span class="line"> 	select * from foo where bar like #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</strong></p>
<p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到namespace为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的MappedStatement。在Mybatis中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略，而不是全限名+方法名+参数。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
</li>
<li><p><strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong></p>
<p>Mybatis 使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，添加对应的物理分页语句和物理分页参数。<br>举例：<code>select * from student</code>，拦截 SQL 后重写为：<code>select t.* from （select * from student）t limit 0，10</code>。</p>
</li>
<li><p><strong>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p>
<p>第一种是使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
</li>
<li><p><strong>如何获取自动生成的(主)键值?</strong></p>
<p>insert 方法总是返回一个int值，这个值代表的是插入的行数。<br>而自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span> <span class="attr">usegeneratedkeys</span>=<span class="string">”true”</span> <span class="attr">keyproperty</span>=<span class="string">”id”</span>&gt;</span> </span><br><span class="line">    insert into names (name) values (#&#123;name&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name name = <span class="keyword">new</span> name(); </span><br><span class="line">name.setname(“fred”); </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = mapper.insertname(name); </span><br><span class="line"><span class="comment">// 完成后,id已经被设置到对象中 </span></span><br><span class="line">system.out.println(“rows inserted = ” + rows); </span><br><span class="line">system.out.println(“generated key value = ” + name.getid());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在mapper中如何传递多个参数?</strong></p>
<p>第1种：如果使用的是JDK8的话，那么会有Bug。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DAO层的函数</span></span><br><span class="line"><span class="function">Public <span class="title">UserselectUser</span><span class="params">(String name,String area)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--</span> #&#123;<span class="attr">0</span>&#125;代表接收的是<span class="attr">dao</span>层中的第一个参数，#&#123;<span class="attr">1</span>&#125;代表<span class="attr">dao</span>层中第二参数，更多参数一致往后加即可。<span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span><span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span>  </span><br><span class="line">    select *  fromuser_user_t   whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第2种：使用 @param 注解: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">usermapper</span> </span>&#123; </span><br><span class="line">    <span class="function">user <span class="title">selectuser</span><span class="params">(@param(“username”)</span> string username, </span></span><br><span class="line"><span class="function">                    @<span class="title">param</span><span class="params">(“hashedpassword”)</span> string hashedpassword)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper): </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectuser"</span> <span class="attr">resulttype</span>=<span class="string">"user"</span>&gt;</span> </span><br><span class="line">    select id, username, hashedpassword </span><br><span class="line">    from some_table </span><br><span class="line">    where username = #&#123;username&#125; </span><br><span class="line">    and hashedpassword = #&#123;hashedpassword&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></p>
<p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
</li>
<li><p><strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong></p>
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p><strong>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</strong></p>
<p>举例：<code>select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</code></p>
</li>
<li><p><strong>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p>
<p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。</p>
<p>在Mybatis配置文件中，<strong>可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</strong></p>
<p>它的原理是，<strong>使用CGLIB创建目标对象的代理对象</strong>，当调用目标方法时，<strong>进入拦截器方法</strong>，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是Mybatis，几乎所有的 ORM 包括Hibernate，支持延迟加载的原理都是一样的。</p>
</li>
<li><p><strong>SqlMapConfig.xml中配置有哪些内容？</strong></p>
<p>SqlMapConfig.xml中配置的内容和顺序如下： </p>
<ol>
<li>properties（属性）</li>
<li>settings（配置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境集合属性对象）</li>
<li>environment（环境子属性对象）</li>
<li>transactionManager（事务管理）</li>
<li>dataSource（数据源）</li>
<li>mappers（映射器）</li>
</ol>
</li>
<li><p><strong>MyBatis实现一对一有几种方式?具体怎么操作的？</strong></p>
<p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。</p>
</li>
<li><p><strong>Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</strong></p>
<p>Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p>
</li>
<li><p><strong>MyBatis里面的动态Sql是怎么设定的?用什么语法?</strong></p>
<p>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。</p>
</li>
<li><p><strong>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</strong></p>
<p>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<code>&lt;sql&gt;</code>为sql片段标签，通过<code>&lt;include&gt;</code>标签引入sql片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
</li>
<li><p><strong>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</strong></p>
<p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
</li>
<li><p><strong>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</strong></p>
<p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<ol>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map</li>
<li>BatchExecutor：完成批处理。</li>
</ol>
</li>
<li><p><strong>Mybatis中如何指定使用哪一种Executor执行器？</strong></p>
<p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
</li>
<li><p><strong>Mybatis是否可以映射Enum枚举类？</strong></p>
<p>Mybatis 不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>
</li>
<li><p><strong>resultType resultMap的区别？</strong></p>
<p>类的名字和数据库相同时，可以直接设置resultType参数为Pojo类，若不同，需要设置resultMap 将结果名字和Pojo名字进行转换</p>
</li>
<li><p><strong>Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</strong></p>
<p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
</li>
<li><p><strong>Mapper 接口的工作原理</strong></p>
<p>mybatis 在运行时使用 JDK 动态代理生成代理对象，在调用接口方法时，代理对象会拦截接口方法，转而运行 MappedStatement 的 sql 语句，并生成结果返回。</p>
</li>
</ol>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="为什么要引入消息中间件？"><a href="#为什么要引入消息中间件？" class="headerlink" title="为什么要引入消息中间件？"></a>为什么要引入消息中间件？</h3><ol>
<li>系统解耦</li>
<li>异步调用</li>
<li>流量削峰</li>
</ol>
<h3 id="消息中间件对比"><a href="#消息中间件对比" class="headerlink" title="消息中间件对比"></a>消息中间件对比</h3><p>常见的消息中间件有：ActiveMQ，RabbitMQ，RocketMQ，Kafka。</p>
<ol>
<li><p>ActiveMQ<br>Apache ActiveMQ 是最受欢迎且功能最强大的开源消息传递和Integration Patterns服务器。Apache ActiveMQ速度快，支持许多跨语言客户端和协议，带有易于使用的企业集成模式和许多高级功能，同时完全支持JMS 1.1和J2EE 1.4。Apache ActiveMQ是在Apache 2.0许可下发布。</p>
</li>
<li><p>RabbitMQ</p>
<p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
</li>
<li><p>RocketMQ</p>
<p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p>
</li>
<li><p>Kafka</p>
<p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p>
<p><img data-src="https://img-blog.csdn.net/20170730143301053" alt=""></p>
</li>
</ol>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/12/14/167aa14337dccf2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p>
<p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>
<p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>
<ol>
<li>可靠性（Reliability）<br>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
<li>灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li>
<li>消息集群（Clustering）<br>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li>
<li>高可用（Highly Available Queues）<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li>多种协议（Multi-protocol）<br>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>多语言客户端（Many Clients）<br>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li>
<li>管理界面（Management UI）<br>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方<br>面。</li>
<li>跟踪机制（Tracing）<br>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li>
<li>插件机制（Plugin System）<br>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img data-src="http://www.xiaohuait.com/wp-content/uploads/2018/05/20170419105717083.png" alt=""></p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li>RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</li>
<li>Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。</li>
<li>Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。</li>
<li>Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</li>
<li>Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</li>
<li>RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。</li>
<li>Connection：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</li>
<li>Channels：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</li>
<li>VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用。</li>
</ol>
<h3 id="直接模式（Direct）"><a href="#直接模式（Direct）" class="headerlink" title="直接模式（Direct）"></a>直接模式（Direct）</h3><p>什么是Direct模式</p>
<p>我们需要将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式。</p>
<p><img data-src="data:image/png;base64,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" alt=""></p>
<p>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</p>
<ol>
<li>一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</li>
<li>这种模式下不需要将Exchange进行任何绑定(binding)操作</li>
<li>消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</li>
<li>如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</li>
</ol>
<p>创建队列<br>做下面的例子前，我们先建立一个叫itcast的队列。</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95d8f61d183.jpg" alt=""></p>
<p>Durability：是否做持久化 Durable（持久）/ transient（临时）<br>Auto delete : 是否自动删除</p>
<p>代码实现-消息生产者</p>
<p>（1）创建工程rabbitmq_demo，引入amqp起步依赖 ，pom.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）编写配置文件application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="string">host:</span> <span class="number">192.168</span><span class="number">.184</span><span class="number">.134</span></span><br></pre></td></tr></table></figure>

<p>（3）编写启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span></span>=Application<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MqTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"itcast"</span>,<span class="string">"我要红包"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现-消息消费者</p>
<p>（1）编写消息消费者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"itcast"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"itcast接收到消息："</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）运行启动类，可以在控制台看到刚才发送的消息</p>
<h3 id="分列模式（Fanout）"><a href="#分列模式（Fanout）" class="headerlink" title="分列模式（Fanout）"></a>分列模式（Fanout）</h3><p>什么是分列（Fanout）模式<br>当我们需要将消息一次发给多个队列时，需要使用这种模式。如下图：</p>
<p><img data-src="data:image/png;base64,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" alt=""></p>
<p>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</p>
<ol>
<li>可以理解为路由表的模式</li>
<li>这种模式不需要RouteKey</li>
<li>这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个<br>Queue，一个Queue可以同多个Exchange进行绑定。</li>
<li>如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</li>
</ol>
<p>交换器绑定队列<br>（1）在queue中添加队列itheima 和kudingyu<br>（2）新建交换器chuanzhi</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95db2e026c2.jpg" alt=""></p>
<p>（3）将itcast 和itheima两个队列绑定到交换器chuanzhi</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95db4ad28c8.jpg" alt=""></p>
<p>点击chuanzhi进入交换器管理界面</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95db888e34e.jpg" alt=""></p>
<p>点击Bindings添加绑定 itheima和kudingyu</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95dbb3c573b.jpg" alt=""></p>
<p>绑定后效果如下：</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95dbc621aa7.jpg" alt=""></p>
<p>代码实现-消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendFanout</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">"chuanzhi"</span>,<span class="string">""</span>, <span class="string">"分列模式走起"</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现-消息消费者<br>创建消息监听类，用于监听itheima的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"itheima"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"itheima接收到消息："</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建消息监听类，用于监听kudingyu的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"kudingyu"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"kudingyu接收到消息："</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主题模式（Topic）"><a href="#主题模式（Topic）" class="headerlink" title="主题模式（Topic）"></a>主题模式（Topic）</h3><p>什么是主题模式<br>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p>
<p><img data-src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2FjY2Vzcy5yZWRoYXQuY29tL2RvY3VtZW50YXRpb24vZW4tVVMvUmVkX0hhdF9FbnRlcnByaXNlX01SRy8yL2h0bWwtc2luZ2xlL01lc3NhZ2luZ19Qcm9ncmFtbWluZ19SZWZlcmVuY2UvaW1hZ2VzLzEwODMucG5n.jpg" alt=""></p>
<p>如上图所示<br>此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.news, usa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 * 匹配不多不少一个<br>词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.* 只会匹配到 usa.XXX 。<br>注：<br>交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所连接的信道，将消息路由键同交换器上绑定的列表进行比较，最后路由消息。<br>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p>
<ol>
<li>这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。</li>
<li>这种模式需要RouteKey，也许要提前绑定Exchange与Queue。</li>
<li>在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。</li>
<li>“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。</li>
<li>同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息</li>
</ol>
<p>创建队列与绑定<br>（1）新建一个交换器 ，类型选择topic</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95dd099bd09.jpg" alt=""></p>
<p>（2）点击新建的交换器topictest</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95dd2345a2a.jpg" alt=""></p>
<p>添加匹配规则，添加后列表如下：</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95dd3af41c7.jpg" alt=""></p>
<p>代码实现<br>编写测试类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopic1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"topictest"</span>,<span class="string">"goods.aaa"</span>,<span class="string">"主题模式"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：itcast接收到消息：主题模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopic2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"topictest"</span>,<span class="string">"article.content.log"</span>,<span class="string">"主题模式"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：itheima接收到消息：主题模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopic3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"topictest"</span>,<span class="string">"goods.log"</span>,<span class="string">"主题模式"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>itheima接收到消息：主题模式<br>itcast接收到消息：主题模式<br>kudingyu接收到消息：主题模式</p>
</blockquote>
<p>RestFul</p>
<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">RESTful API 最佳实践</a></p>
<p><a href="http://restcookbook.com/" target="_blank" rel="noopener">restcookbook.com</a></p>
</blockquote>
<h3 id="何为RESTful"><a href="#何为RESTful" class="headerlink" title="何为RESTful"></a>何为RESTful</h3><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的 .</p>
<p>REST 是Representational State Transfer的缩写，翻译是”表现层状态转化”。 可以总结为一句话：REST是所有Web应用都应该遵守的架构设计指导原则。</p>
<p>面向资源是REST最明显的特征，对于同一个资源的一组不同的操作。资源是服务器上一个可命名的抽象概念，资源是以名词为核心来组织的，首先关注的是名词。REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。</p>
<p>REST 是一种软件架构风格、设计风格，而<strong>不是</strong>标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<h3 id="安全性和幂等性"><a href="#安全性和幂等性" class="headerlink" title="安全性和幂等性"></a>安全性和幂等性</h3><blockquote>
<p><a href="https://icbd.github.io/wiki/notes/2018/01/16/http-safe-idempotent.html" target="_blank" rel="noopener">HTTP方法的幂等性与安全性</a></p>
</blockquote>
<p>7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS</p>
<p>RestFul service 架构是基于 http 协议的。Http 有两个非常重要的特性，安全性和幂等性。</p>
<p>安全性: 请求一次或多次, 不会改变实例的表现形式. 重点强调无副作用.</p>
<p>幂等性: 请求一次或多次, 响应结果相同. 重点强调副作用的一致性.</p>
<p>增删改查，三个不安全，三个幂等</p>
<table>
<thead>
<tr>
<th align="left">Function</th>
<th align="left">idempotent</th>
<th align="left">safe</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">获取实例</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">获取响应头</td>
</tr>
<tr>
<td align="left">OPTIONS</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">获取支持的请求方式</td>
</tr>
<tr>
<td align="left">TRACE</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">追踪查看最终的请求</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">全量覆盖某个实例</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">创建新实例</td>
</tr>
<tr>
<td align="left">PATCH</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">修改实例的某些属性</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">删除某个实例</td>
</tr>
</tbody></table>
<p><strong>一、起源</strong></p>
<p>REST这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="noopener">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">博士论文</a>中提出的。</p>
<p><img data-src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091201.jpg" alt="img"></p>
<p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>
<p><strong>二、名称</strong></p>
<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。</p>
<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>
<p><strong>三、资源（Resources）</strong></p>
<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p>
<p><strong>四、表现层（Representation）</strong></p>
<p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<p><strong>五、状态转化（State Transfer）</strong></p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>
<p><strong>六、综述</strong></p>
<p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>（1）每一个URI代表一种资源；</p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p><strong>七、误区</strong></p>
<p>RESTful架构有一些典型的设计误区。</p>
<p><strong>最常见的一种设计错误，就是URI包含动词。</strong>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p>
<blockquote>
<p>　　POST /accounts/1/transfer/500/to/2</p>
</blockquote>
<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p>
<blockquote>
<p>　　POST /transaction HTTP/1.1<br>　　Host: 127.0.0.1<br>　　<br>　　from=1&amp;to=2&amp;amount=500.00</p>
</blockquote>
<p><strong>另一个设计误区，就是在URI中加入版本号</strong>：</p>
<blockquote>
<p>　　<a href="http://www.example.com/app/1.0/foo" target="_blank" rel="noopener">http://www.example.com/app/1.0/foo</a></p>
<p>　　<a href="http://www.example.com/app/1.1/foo" target="_blank" rel="noopener">http://www.example.com/app/1.1/foo</a></p>
<p>　　<a href="http://www.example.com/app/2.0/foo" target="_blank" rel="noopener">http://www.example.com/app/2.0/foo</a></p>
</blockquote>
<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p>
<blockquote>
<p>　　Accept: vnd.example-com.foo+json; version=1.0</p>
<p>　　Accept: vnd.example-com.foo+json; version=1.1</p>
<p>　　Accept: vnd.example-com.foo+json; version=2.0</p>
</blockquote>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><blockquote>
<p><a href="http://hyuga.top/2018/09/18/jiagou-gainian/" target="_blank" rel="noopener">单体、服务化架构一点概念</a></p>
</blockquote>
<h3 id="什么是系统架构设计"><a href="#什么是系统架构设计" class="headerlink" title="什么是系统架构设计"></a>什么是系统架构设计</h3><p>系统架构设计描述了在应用系统的内部，如何根据业务、技术、组织、灵活性、可扩展性以及可维护性等多种因素，将应用系统划分成不同的部分，并使这些部分彼此之间相互分工、相互协作，从而使得这些部分之间能够进行有机的联系，合并组装成为一个整体，完成目标系统的所有工作。</p>
<h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p>微服务架构(Microservice Architecture)是一种架构风格，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。</p>
<h3 id="单体应用的优缺点"><a href="#单体应用的优缺点" class="headerlink" title="单体应用的优缺点"></a>单体应用的优缺点</h3><p>所谓单体应用，就是把所有业务的代码都放在一起。随着业务递增，项目慢慢大了起来，单体应用的缺点就逐一暴露出来了。单体应用主要有以下缺点：</p>
<ol>
<li><p>可扩展性差： 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。</p>
<p>垂直扩展就是升级原有的系统处理能力，比如从硬件上可以扩充系统内存，增加CPU核数，升级网卡等；从软件上可以通过使用Cache减少IO次数，使用异步增加吞吐量</p>
<p>水平扩展就是使用结合负载均衡服务器实现集群部署，解决高可用问题。</p>
</li>
<li><p>维护成本大： 随着应用程序的功能越来越多，当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复 bug 时引入新的 bug。再就是团队越来越大时，沟通成本、管理成本也显著增加。</p>
</li>
<li><p>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉。</p>
</li>
<li><p>持续交付周期长： 构建和部署时间会随着功能的增多而增加，改了一个业务的一行代码，都需要重启整个单体应用，重新部署。</p>
</li>
<li><p>新人培养周期长： 新成员了解背景、熟悉业务和配置环境的时间越来越长。</p>
</li>
<li><p>技术选型成本高： 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。</p>
</li>
</ol>
<p>正因为单体应用有着这些缺陷，才有了微服务。</p>
<p>优点：</p>
<ul>
<li>易于开发： 开发方式简单，IDE 支持好，方便运行和调试。</li>
<li>易于测试： 所有功能运行在一个进程中，一旦进程启动，便可以进行系统测试。</li>
<li>易于部署： 只需要将打好的一个软件包发布到服务器即可。</li>
<li>易于水平伸缩： 只需要创建一个服务器节点，配置好运行时环境，再将软件包发布到新服务器节点即可运行程序（当然也需要采取分发策略保证请求能有效地分发到新节点）。</li>
</ul>
<h3 id="微服务架构的特性"><a href="#微服务架构的特性" class="headerlink" title="微服务架构的特性"></a>微服务架构的特性</h3><p><strong>1. 独立性</strong></p>
<p>微服务架构中的每个服务，都是具有自身的业务逻辑，符合高内聚、低耦合以及单一职责原则。每个服务在应用交付过程中，能够独立地开发、测试和部署。</p>
<p><strong>2. 轻量级通信</strong></p>
<p>服务之间通过轻量级的通信机制实现互通互联，而所谓的轻量级，通常指语言无关、平台无关的交互方式。</p>
<p>对于轻量级通信的格式而言，我们熟悉的 XML 和 JSON，它们是语言无关、平台无关的；对于通信的协议而言，通常基于 HTTP，能让服务间的通信变得标准化、无状态化。目前大家熟悉的 REST（Representational State Transfer）是实现服务间互相协作的轻量级通信机制之一。使用轻量级通信机制，可以让团队选择更适合的语言、工具或者平台来开发服务本身。</p>
<p>RPC与REST</p>
<p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p>
<p>REST（Representational State Transfer 表现层状态转化）</p>
<ul>
<li>要求要将接口以资源的形式呈现。REST规范把所有内容都视为资源，网络上一切皆资源</li>
<li>它的URL主体是资源，是个名词</li>
<li>仅支持HTTP协议</li>
</ul>
<p>RPC（Remote Procedure Call 远程过程调用）</p>
<ul>
<li>主体都是动作，是个动词，表示我要做什么。</li>
<li>像调用本地方法一样调用远程方法</li>
<li>大多数都是用TCP协议</li>
</ul>
<p>比较：都是网络交互的协议规范。通常用于多个微服务之间的通信协议。</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/VxcvTeWncReyq4GXO296qb1BuqBHZJkJyxiaFjsvq1vrMm7bHiautH18Ej5NF0o3KyWkmq30eQoTRicPC5gqXxxGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>高与低是对实现两种规范框架的相对比较，但也不是绝对的，需要根据实际情况而定。</p>
<p>1、HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</p>
<p>2、RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</p>
<p><strong>4. 进程隔离</strong></p>
<p>单体架构中，整个系统运行在同一个进程中，当应用进行部署时，必须停掉当前正在运行的应用，部署完成后再重启进程，无法做到独立部署。</p>
<p>有时候我们会将重复的代码抽取出来封装成组件，在单块架构中，组件通常的形态叫做共享库（如 jar 包或者 DLL），但是当程序运行时，所有组件最终也会被加载到同一进程中运行。</p>
<p>在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上。</p>
<p>理论上所有服务可以部署在同一个服务器节点，但是并不推荐这么做，因为微服务架构的主旨就是高度自治和高度隔离。</p>
<h3 id="微服务的本质"><a href="#微服务的本质" class="headerlink" title="微服务的本质"></a>微服务的本质</h3><p><strong>1. 服务作为组件</strong></p>
<p>微服务也可以被认为是一种组件，但是跟传统组件的区别在于它可以独立部署，因此它的一个显著的优势。另外一个优点是，它在组件与组件之间定义了清晰的、语言无关、平台无关的规范接口，耦合度低，灵活性非常高。但它的不足之处是，分布式调用严重依赖于网络的可靠性和稳定性。</p>
<p><strong>2. 围绕业务组织团队</strong></p>
<p>在单块架构中，企业一般会根据技能划分团队，在这种组织架构下，即便是简单的需求变更都有可能需要跨团队协作，沟通成本很高。而在微服务架构中，它提倡以业务为核心，按照业务能力来组织团队，团队中的成员具有多样性的技能。</p>
<p><strong>3. 关注产品而非项目</strong></p>
<p>在单块架构中，应用基本上是基于“项目模式”构建的，即项目启动时从不同技能资源池中抽取相关资源组成团队，项目结束后释放所有资源。这种情况下团队成员缺乏主人翁意识和产品成就感。</p>
<p>在微服务架构中，提倡采用“产品模式”构建，即更倾向于让团队负责整个服务的生命周期，以便提供更优质的服务。</p>
<p><strong>4. 技术多样性</strong></p>
<p>微服务架构中，提倡针对不同的业务特征选择合适的技术方案，有针对性的解决具体业务问题，而不是像单块架构中采用统一的平台或技术来解决所有问题。</p>
<p><strong>5. 业务数据独立</strong></p>
<p>随着业务的发展，可以方便地选择更合的工具管理或者迁移业务数据。</p>
<p><strong>6. 基础设施自动化</strong></p>
<p>微服务架构提供自主管理其相关的业务数据，这样可以随着业务的发展提供数据接口集成，而不是以数据库的方式同其他服务集成。另外，在微服务架构的实践过程中，对持续交付和部署流水线的要求很高，将促进企业不断寻找更高效的方式完成基础设施的自动化及 DevOps 运维能力的提升。</p>
<h3 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h3><p>优点：</p>
<ul>
<li>边界清晰，开发测试维护简单：每个服务职责清晰，只关注于一个业务功能</li>
<li>技术栈灵活：每个服务开发语言可不同，只需要把服务注册到注册中心，统一协议</li>
<li>松耦合：各个服务间不像单体架构一样通过方法调用</li>
<li>可用性：单个服务宕机，不影响其他服务访问，可能影响业务，如果有关联</li>
<li>按需扩展：某个服务需要做硬件升级，比如集群，硬件升级等，不影响其他服务</li>
</ul>
<p>缺点：</p>
<ul>
<li>分布式带来的复杂性：网络延迟、容错性、消息序列化、数据一致性、异步机制、版本化、差异化等</li>
<li>运维开销成本增加：整体应用可能只需部署至一小片应用服务区集群，而微服务架构可能变成需要构建/测试/部署/运行数十个独立的服务，并可能需要支持多种语言和环境。</li>
<li>服务版本问题：当某个服务接口版本升级，其他调用的单体服务可能都要进行升级</li>
</ul>
<h3 id="服务架构的落地是存在很多挑战的"><a href="#服务架构的落地是存在很多挑战的" class="headerlink" title="服务架构的落地是存在很多挑战的"></a>服务架构的落地是存在很多挑战的</h3><p><strong>1. 分布式系统的复杂性</strong></p>
<p>微服务架构是基于分布式的系统，而构建分布式系统必然会带来额外的开销。</p>
<ul>
<li>性能： 分布式系统是跨进程、跨网络的调用，受网络延迟和带宽的影响。</li>
<li>可靠性： 由于高度依赖于网络状况，任何一次的远程调用都有可能失败，随着服务的增多还会出现更多的潜在故障点。因此，如何提高系统的可靠性、降低因网络引起的故障率，是系统构建的一大挑战。</li>
<li>异步： 异步通信大大增加了功能实现的复杂度，并且伴随着定位难、调试难等问题。</li>
<li>数据一致性： 要保证分布式系统的数据强一致性，成本是非常高的，需要在 C（一致性）A（可用性）P（分区容错性） 三者之间做出权衡。</li>
</ul>
<p><strong>2. 运维成本</strong></p>
<p>运维主要包括配置、部署、监控与告警和日志收集四大方面。微服务架构中，每个服务都需要独立地配置、部署、监控和收集日志，成本呈指数级增长。</p>
<p><strong>3. 自动化部署</strong></p>
<p>在微服务架构中，每个服务都独立部署，交付周期短且频率高，人工部署已经无法适应业务的快速变化。因此如何有效地构建自动化部署体系，是微服务面临的另一个挑战。</p>
<p><strong>4. DevOps 与组织架构</strong></p>
<p>在微服务架构的实施过程中，开发人员和运维人员的角色发生了变化，开发者将承担起整个服务的生命周期的责任，包括部署和监控；而运维则更倾向于顾问式的角色，尽早考虑服务如何部署。因此，按需调整组织架构、构建全功能的团队，也是一个不小的挑战。</p>
<p><strong>5. 服务间的依赖测试</strong></p>
<p>单块架构中，通常使用集成测试来验证依赖是否正常。而在微服务架构中，服务数量众多，每个服务都是独立的业务单元，服务主要通过接口进行交互，如何保证依赖的正常，是测试面临的主要挑战。</p>
<p><strong>6. 服务间的依赖管理</strong></p>
<p>微服务架构中，服务数量众多，如何清晰有效地展示服务间的依赖关系也是个不小的挑战。</p>
<h3 id="微服务与SOA"><a href="#微服务与SOA" class="headerlink" title="微服务与SOA"></a>微服务与SOA</h3><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQzla0DNH3icbhib5JlicjqfFLPaTfia6vjBBZORmiahOpU7qyGgXDPKdtmlsKeTm7WhybicLeDsDInTh2GQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>微服务是SOA发展出来的产物，它是一种比较现代化的细粒度的SOA实现方式。</p>
<p>SOA（Service-Oriented Architecture 面向服务的架构）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</p>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h3 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h3><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、熔断器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<h3 id="SpringCloud与SpringBoot的关系"><a href="#SpringCloud与SpringBoot的关系" class="headerlink" title="SpringCloud与SpringBoot的关系"></a>SpringCloud与SpringBoot的关系</h3><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就<br>不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot吗？不可以。</p>
<p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</p>
<h3 id="SpringCloud主要框架"><a href="#SpringCloud主要框架" class="headerlink" title="SpringCloud主要框架"></a>SpringCloud主要框架</h3><ol>
<li>服务注册——Netflix Eureka</li>
<li>服务调用——Netflix Feign</li>
<li>熔断器——Netflix Hystrix</li>
<li>服务网关——Netflix Zuul</li>
<li>分布式配置——Spring Cloud Config</li>
<li>消息总线 —— Spring Cloud Bus</li>
</ol>
<h3 id="Spring-Cloud和Dubbo对比"><a href="#Spring-Cloud和Dubbo对比" class="headerlink" title="Spring Cloud和Dubbo对比"></a>Spring Cloud和Dubbo对比</h3><p>或许很多人会说Spring Cloud和Dubbo的对比有点不公平，Dubbo只是实现了服务治理，而Spring Cloud下面有17个子项目（可能还会新增）分别覆盖了微服务架构下的方方面面，服务治理只是其中的一个方面，一定程度来说，Dubbo只是Spring Cloud Netflix中的一个子集。</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>熔断器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<h3 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h3><p>跨域是什么？浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 。我们是采用前后端分离开发的，也是前后端分离部署的，必然会存在跨域问题。 怎么解决跨域？很简单，只需要在controller类上添加注解@CrossOrigin 即可！这个注解其实是CORS的实现。</p>
<p>CORS(Cross-Origin Resource Sharing, 跨源资源共享)是W3C出的一个标准，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。因此，要想实现CORS进行跨域，需要服务器进行一些设置，同时前端也需要做一些配置和分析。</p>
<h3 id="分布式ID生成器"><a href="#分布式ID生成器" class="headerlink" title="分布式ID生成器"></a>分布式ID生成器</h3><blockquote>
<p><a href="https://github.com/twitter-archive/snowflake" target="_blank" rel="noopener">snowflake</a></p>
<p><a href="https://www.lanindex.com/twitter-snowflake%EF%BC%8C64%E4%BD%8D%E8%87%AA%E5%A2%9Eid%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Twitter-Snowflake，64位自增ID算法详解</a></p>
<p><a href="https://blog.csdn.net/yangding_/article/details/52768906" target="_blank" rel="noopener">Twitter Snowflake算法详解</a></p>
</blockquote>
<p>由于我们的数据库在生产环境中要分片部署（MyCat）,所以我们不能使用数据库本身的自增功能来产生主键值，只能由程序来生成唯一的主键值。我们采用的是开源的twitter的snowflake（雪花）算法。</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95e7bf10592.jpg" alt=""></p>
<p>默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1024台机器，序列号支持1毫秒产生4096个自增序列id . SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</p>
<h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4><p>HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic<br>Auth</p>
<h4 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h4><p>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效；</p>
<p><img data-src="https://i.loli.net/2019/03/24/5c972786c2906.jpg" alt=""></p>
<h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><p>OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p>
<p>OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信<br>息，而非所有内容</p>
<p>下面是OAuth2.0的流程：</p>
<p><img data-src="https://i.loli.net/2019/03/24/5c9727dbcf37f.jpg" alt=""></p>
<p>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</p>
<h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
<p><img data-src="https://i.loli.net/2019/03/24/5c97281e3f4f4.jpg" alt=""></p>
<h5 id="Token-Auth的优点"><a href="#Token-Auth的优点" class="headerlink" title="Token Auth的优点"></a>Token Auth的优点</h5><p>Token机制相对于Cookie机制又有什么好处呢？</p>
<ul>
<li><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p>
</li>
<li><p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p>
</li>
<li><p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p>
</li>
<li><p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p>
</li>
<li><p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p>
</li>
<li><p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p>
</li>
<li><p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.</p>
</li>
<li><p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p>
</li>
<li><p>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p>
</li>
</ul>
<h5 id="基于JWT的Token认证机制实现"><a href="#基于JWT的Token认证机制实现" class="headerlink" title="基于JWT的Token认证机制实现"></a>基于JWT的Token认证机制实现</h5><h6 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h6><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<h6 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h6><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p>
<p>头部（Header）</p>
<p>头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"typ"</span>:<span class="string">"JWT"</span>,<span class="attr">"alg"</span>:<span class="string">"HS256"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在头部指明了签名算法是HS256算法。 我们进行BASE64编码<a href="http://base64.xpcha.com/，编码后的字符串如下：" target="_blank" rel="noopener">http://base64.xpcha.com/，编码后的字符串如下：</a></p>
<blockquote>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>
</blockquote>
<p>小知识：Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 BASE64Encoder 和 BASE64Decoder，用它们可以非常方便的完成基于 BASE64 的编码和解码.</p>
<p>载荷（playload）</p>
<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<p>（1）标准中注册的声明（建议但不强制使用）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">iss:</span> <span class="string">jwt签发者</span></span><br><span class="line"><span class="string">sub:</span> <span class="string">jwt所面向的用户</span></span><br><span class="line"><span class="string">aud:</span> <span class="string">接收jwt的一方</span></span><br><span class="line"><span class="string">exp:</span> <span class="string">jwt的过期时间，这个过期时间必须要大于签发时间</span></span><br><span class="line"><span class="string">nbf:</span> <span class="string">定义在什么时间之前，该jwt都是不可用的.</span></span><br><span class="line"><span class="string">iat:</span> <span class="string">jwt的签发时间</span></span><br><span class="line"><span class="string">jti:</span> <span class="string">jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span></span><br></pre></td></tr></table></figure>

<p>（2）公共的声明<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.<br>（3）私有的声明<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。这个指的就是自定义的claim。比如前面那个结构举例中的admin和name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p>
<p>定义一个payload:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"sub"</span>:<span class="string">"1234567890"</span>,<span class="attr">"name"</span>:<span class="string">"John Doe"</span>,<span class="attr">"admin"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>然后将其进行base64编码，得到Jwt的第二部分。</p>
<blockquote>
<p>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</p>
</blockquote>
<p>签证（signature）</p>
<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ol>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ol>
<p>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<blockquote>
<p>TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</blockquote>
<p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p>
<blockquote>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</blockquote>
<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
<h5 id="Java的JJWT实现JWT"><a href="#Java的JJWT实现JWT" class="headerlink" title="Java的JJWT实现JWT"></a>Java的JJWT实现JWT</h5><h6 id="什么是JJWT"><a href="#什么是JJWT" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h6><p>JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p>
<h6 id="JJWT快速入门"><a href="#JJWT快速入门" class="headerlink" title="JJWT快速入门"></a>JJWT快速入门</h6><p><strong>token的创建</strong></p>
<p>（1）创建maven工程，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）创建类CreateJwtTest，用于生成token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JwtBuilder builder= Jwts.builder().setId(<span class="string">"888"</span>)</span><br><span class="line">                .setSubject(<span class="string">"小白"</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println( builder.compact() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setIssuedAt用于设置签发时间, signWith用于设置签名秘钥</p>
<p>（3）测试运行，输出如下:</p>
<blockquote>
<p>eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTM0NTh9.gq0J‐cOM_qCNqU_s‐d_IrRytaNenesPmqAIhQpYXHZk</p>
</blockquote>
<p>再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间。</p>
<p><strong>token的解析</strong></p>
<p>我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。</p>
<p>创建ParseJwtTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String token = <span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTM0NTh9.gq0J‐cOM_qCNqU_s‐d_IrRytaNenesPmqAIhQpYXHZk"</span>;</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(<span class="string">"itcast"</span>).parseClaimsJws(token).getBody();</span><br><span class="line">        System.out.println(<span class="string">"id:"</span>+claims.getId());</span><br><span class="line">        System.out.println(<span class="string">"subject:"</span>+claims.getSubject());</span><br><span class="line">        System.out.println(<span class="string">"IssuedAt:"</span>+claims.getIssuedAt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token</p>
<p><strong>token过期校验</strong></p>
<p>有很多时候，我们并不希望签发的token是永久生效的，所以我们可以为token添加一个过期时间。</p>
<p>创建CreateJwtTest2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJwtTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了方便测试，我们将过期时间设置为1分钟</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();<span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">long</span> exp = now + <span class="number">1000</span>*<span class="number">60</span>;<span class="comment">//过期时间为1分钟</span></span><br><span class="line">        JwtBuilder builder= Jwts.builder().setId(<span class="string">"888"</span>)</span><br><span class="line">                .setSubject(<span class="string">"小白"</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"itcast"</span>)</span><br><span class="line">           .setExpiration(<span class="keyword">new</span> Date(exp));      </span><br><span class="line">        System.out.println( builder.compact() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setExpiration 方法用于设置过期时间</p>
<p>修改ParseJwtTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String compactJws=<span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTY1NjksImV4cCI6MTUyMzQxNjYyOX0.Tk91b6mvyjpKcldkic8DgXz0zsPFFnRgTgkgcAsa9cc"</span>;</span><br><span class="line">        Claims claims =</span><br><span class="line">Jwts.parser().setSigningKey(<span class="string">"itcast"</span>).parseClaimsJws(compactJws).getBody();</span><br><span class="line">        System.out.println(<span class="string">"id:"</span>+claims.getId());</span><br><span class="line">        System.out.println(<span class="string">"subject:"</span>+claims.getSubject());</span><br><span class="line">        SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy‐MM‐dd hh:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"签发时间:"</span>+sdf.format(claims.getIssuedAt()));</span><br><span class="line">        System.out.println(<span class="string">"过期时间:"</span>+sdf.format(claims.getExpiration()));</span><br><span class="line">        System.out.println(<span class="string">"当前时间:"</span>+sdf.format(<span class="keyword">new</span> Date()) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试运行，当未过期时可以正常读取，当过期时会引发io.jsonwebtoken.ExpiredJwtException异常。</p>
<p><strong>自定义claims</strong></p>
<p>我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims </p>
<p>创建CreateJwtTest3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJwtTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了方便测试，我们将过期时间设置为1分钟</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();<span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">long</span> exp = now + <span class="number">1000</span>*<span class="number">60</span>;<span class="comment">//过期时间为1分钟</span></span><br><span class="line">        JwtBuilder builder= Jwts.builder().setId(<span class="string">"888"</span>)</span><br><span class="line">                .setSubject(<span class="string">"小白"</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"itcast"</span>)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(exp))</span><br><span class="line">                .claim(<span class="string">"roles"</span>,<span class="string">"admin"</span>)</span><br><span class="line">                .claim(<span class="string">"logo"</span>,<span class="string">"logo.png"</span>);</span><br><span class="line">        System.out.println( builder.compact() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改ParseJwtTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String</span><br><span class="line">compactJws=<span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTczMjMsImV4cCI6MTUyMzQxNzM4Mywicm9sZXMiOiJhZG1pbiIsImxvZ28iOiJsb2dvLnBuZyJ9.b11p4g4rE94rqFhcfzdJTPCORikqP_1zJ1MP8KihYTQ"</span>;</span><br><span class="line">        Claims claims =</span><br><span class="line">Jwts.parser().setSigningKey(<span class="string">"itcast"</span>).parseClaimsJws(compactJws).getBody();</span><br><span class="line">        System.out.println(<span class="string">"id:"</span>+claims.getId());</span><br><span class="line">        System.out.println(<span class="string">"subject:"</span>+claims.getSubject());</span><br><span class="line">        System.out.println(<span class="string">"roles:"</span>+claims.get(<span class="string">"roles"</span>));</span><br><span class="line">        System.out.println(<span class="string">"logo:"</span>+claims.get(<span class="string">"logo"</span>));</span><br><span class="line">        SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy‐MM‐dd hh:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"签发时间:"</span>+sdf.format(claims.getIssuedAt()));</span><br><span class="line">        System.out.println(<span class="string">"过期时间:"</span>+sdf.format(claims.getExpiration()));</span><br><span class="line">        System.out.println(<span class="string">"当前时间:"</span>+sdf.format(<span class="keyword">new</span> Date()) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h3><p>MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。</p>
<h3 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h3><p>MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。<br>具体特点总结如下：<br>（1）面向集合存储，易于存储对象类型的数据<br>（2）模式自由<br>（3）支持动态查询<br>（4）支持完全索引，包含内部对象<br>（5）支持复制和故障恢复<br>（6）使用高效的二进制数据存储，包括大型对象（如视频等）<br>（7）自动处理碎片，以支持云计算层次的扩展性<br>（8）支持各种语言的驱动程序<br>（9） 文件存储格式为 BSON（一种 JSON 的扩展）</p>
<h3 id="MongoDB体系结构"><a href="#MongoDB体系结构" class="headerlink" title="MongoDB体系结构"></a>MongoDB体系结构</h3><p>MongoDB 的逻辑结构是一种层次结构。主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。<br>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。<br>（2）多个文档组成一个集合（collection），相当于关系数据库的表。<br>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。<br>（4）一个 MongoDB 实例支持多个数据库（database）。<br>文档(document)、集合(collection)、数据库(database)的层次结构如下图:</p>
<p><img data-src="https://i.loli.net/2019/03/23/5c95f6047e160.jpg" alt=""></p>
<p>下表是MongoDB与MySQL数据库逻辑结构概念的对比</p>
<table>
<thead>
<tr>
<th>MongoDb</th>
<th>关系型数据库Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>数据库(databases)</td>
<td>数据库(databases)</td>
</tr>
<tr>
<td>集合(collections)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>行(row)</td>
</tr>
</tbody></table>
<h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型</p>
<ul>
<li><p>null：用于表示空值或者不存在的字段，{“x”:null}</p>
</li>
<li><p>布尔型：布尔类型有两个值true和false，{“x”:true}</p>
</li>
<li><p>数值：shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用 NumberInt（4字节符号整数）或NumberLong（8字节符号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</p>
</li>
<li><p>字符串：UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}</p>
</li>
<li><p>日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()}</p>
</li>
<li><p>正则表达式：查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相同，{“x”:/[abc]/}</p>
</li>
<li><p>数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}</p>
</li>
<li><p>内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}</p>
</li>
<li><p>对象Id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() }</p>
</li>
<li><p>二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非utf-字符保存到数据库中，二进制数据是唯一的方式。</p>
</li>
<li><p>代码：查询和文档中可以包括任何JavaScript代码，{“x”:function(){/…/}}</p>
</li>
</ul>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="选择和创建数据库"><a href="#选择和创建数据库" class="headerlink" title="选择和创建数据库"></a>选择和创建数据库</h4><p>选择和创建数据库的语法格式：</p>
<p><code>use 数据库名称</code></p>
<p>如果数据库不存在则自动创建</p>
<h4 id="插入与查询文档"><a href="#插入与查询文档" class="headerlink" title="插入与查询文档"></a>插入与查询文档</h4><p>插入文档的语法格式：</p>
<p><code>db.集合名称.insert(数据);</code></p>
<p>查询集合的语法格式：</p>
<p><code>db.集合名称.find()</code></p>
<p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p>
<h4 id="修改与删除文档"><a href="#修改与删除文档" class="headerlink" title="修改与删除文档"></a>修改与删除文档</h4><p>修改文档的语法结构：</p>
<p><code>db.集合名称.update(条件,修改后的数据)</code></p>
<p>删除文档的语法结构：</p>
<p><code>db.集合名称.remove(条件)</code></p>
<h4 id="统计条数"><a href="#统计条数" class="headerlink" title="统计条数"></a>统计条数</h4><p>统计记录条件使用count()方法。以下语句统计spit集合的记录数</p>
<p><code>db.spit.count()</code></p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：</p>
<p><code>/模糊查询字符串/</code></p>
<p>例如，我要查询吐槽内容包含“流量”的所有文档，代码如下：</p>
<p><code>db.spit.find({content:/流量/})</code></p>
<h4 id="大于-小于-不等于"><a href="#大于-小于-不等于" class="headerlink" title="大于 小于 不等于"></a>大于 小于 不等于</h4><p>&lt;, &lt;=, &gt;, &gt;= 这个操作符也是很常用的，格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) &#x2F;&#x2F; 大于: field &gt; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) &#x2F;&#x2F; 小于: field &lt; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) &#x2F;&#x2F; 大于等于: field &gt;&#x3D; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) &#x2F;&#x2F; 小于等于: field &lt;&#x3D; value</span><br><span class="line">db.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) &#x2F;&#x2F; 不等于: field !&#x3D; value</span><br></pre></td></tr></table></figure>

<h4 id="包含与不包含"><a href="#包含与不包含" class="headerlink" title="包含与不包含"></a>包含与不包含</h4><p>包含使用$in操作符。<br>示例：查询吐槽集合中userid字段包含1013和1014的文档</p>
<p><code>db.spit.find({userid:{$in:[&quot;1013&quot;,&quot;1014&quot;]}})</code></p>
<p>不包含使用$nin操作符。<br>示例：查询吐槽集合中userid字段不包含1013和1014的文档</p>
<p><code>db.spit.find({userid:{$nin:[&quot;1013&quot;,&quot;1014&quot;]}})</code></p>
<h4 id="条件连接"><a href="#条件连接" class="headerlink" title="条件连接"></a>条件连接</h4><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）<br>格式为：</p>
<p><code>$and:[ {  },{  },{ } ]</code></p>
<p>示例：查询吐槽集合中visits大于等于1000 并且小于2000的文档</p>
<p><code>db.spit.find({$and:[ {visits:{$gte:1000}} ,{visits:{$lt:2000} }]})</code></p>
<h4 id="列值增长"><a href="#列值增长" class="headerlink" title="列值增长"></a>列值增长</h4><p>如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符来实现</p>
<p><code>db.spit.update({_id:&quot;2&quot;},{$inc:{visits:NumberInt(1)}}  )</code></p>
<h3 id="Java操作MongoDB"><a href="#Java操作MongoDB" class="headerlink" title="Java操作MongoDB"></a>Java操作MongoDB</h3><p>mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。我们通过一个入门的案例来了解mongodb-driver的基本使用</p>
<h4 id="查询全部记录"><a href="#查询全部记录" class="headerlink" title="查询全部记录"></a>查询全部记录</h4><p>（1）创建工程 mongoDemo, 引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongodb‐driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）创建测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MongoDb入门小demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MongoClient client=<span class="keyword">new</span> MongoClient(<span class="string">"192.168.184.134"</span>);<span class="comment">//创建连接</span></span><br><span class="line">        MongoDatabase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);<span class="comment">//打开数据库</span></span><br><span class="line">        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(<span class="string">"spit"</span>);<span class="comment">//获取集合</span></span><br><span class="line">        FindIterable&lt;Document&gt; documents = spit.find();<span class="comment">//查询记录获取文档集合</span></span><br><span class="line">        <span class="keyword">for</span>(Document document:documents)&#123; <span class="comment">//</span></span><br><span class="line">            System.out.println(<span class="string">"内容："</span>+  document.getString(<span class="string">"content"</span>));</span><br><span class="line">            System.out.println(<span class="string">"用户ID:"</span>+document.getString(<span class="string">"userid"</span>));</span><br><span class="line">            System.out.println(<span class="string">"浏览量："</span>+document.getInteger(<span class="string">"visits"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>BasicDBObject对象：表示一个具体的记录，BasicDBObject实现了DBObject，是key-value的数据结构，用起来和HashMap是基本一致的。</p>
<p>（1）查询userid为1013的记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MongoClient client=<span class="keyword">new</span> MongoClient(<span class="string">"192.168.184.134"</span>);<span class="comment">//创建连接</span></span><br><span class="line">        MongoDatabase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);<span class="comment">//打开数据库</span></span><br><span class="line">        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(<span class="string">"spit"</span>);<span class="comment">//获取集合</span></span><br><span class="line">        BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"userid"</span>,<span class="string">"1013"</span>);<span class="comment">// 构建查询条件</span></span><br><span class="line">        FindIterable&lt;Document&gt; documents = spit.find(bson);<span class="comment">//查询记录获取结果集合</span></span><br><span class="line">        <span class="keyword">for</span>(Document document:documents)&#123; <span class="comment">//</span></span><br><span class="line">            System.out.println(<span class="string">"内容："</span>+  document.getString(<span class="string">"content"</span>));</span><br><span class="line">            System.out.println(<span class="string">"用户ID:"</span>+document.getString(<span class="string">"userid"</span>));</span><br><span class="line">            System.out.println(<span class="string">"浏览量："</span>+document.getInteger(<span class="string">"visits"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）查询浏览量大于1000的记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MongoClient client=<span class="keyword">new</span> MongoClient(<span class="string">"192.168.184.134"</span>);<span class="comment">//创建连接</span></span><br><span class="line">        MongoDatabase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);<span class="comment">//打开数据库</span></span><br><span class="line">        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(<span class="string">"spit"</span>);<span class="comment">//获取集合</span></span><br><span class="line">        BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">"visits"</span>,<span class="keyword">new</span> BasicDBObject(<span class="string">"$gt"</span>,<span class="number">1000</span>) );<span class="comment">// 构建查询条件</span></span><br><span class="line">       </span><br><span class="line">        FindIterable&lt;Document&gt; documents = spit.find(bson);<span class="comment">//查询记录获取结果集合</span></span><br><span class="line">        <span class="keyword">for</span>(Document document:documents)&#123; <span class="comment">//</span></span><br><span class="line">            System.out.println(<span class="string">"内容："</span>+  document.getString(<span class="string">"content"</span>));</span><br><span class="line">            System.out.println(<span class="string">"用户ID:"</span>+document.getString(<span class="string">"userid"</span>));</span><br><span class="line">            System.out.println(<span class="string">"浏览量："</span>+document.getInteger(<span class="string">"visits"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MongoClient client=<span class="keyword">new</span> MongoClient(<span class="string">"192.168.184.134"</span>);<span class="comment">//创建连接</span></span><br><span class="line">        MongoDatabase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);<span class="comment">//打开数据库</span></span><br><span class="line">        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(<span class="string">"spit"</span>);<span class="comment">//获取集合</span></span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"content"</span>,<span class="string">"我要吐槽"</span>);</span><br><span class="line">        map.put(<span class="string">"userid"</span>,<span class="string">"9999"</span>);</span><br><span class="line">        map.put(<span class="string">"visits"</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">"publishtime"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        Document document=<span class="keyword">new</span> Document(map);</span><br><span class="line">        spit.insertOne(document);<span class="comment">//插入数据</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringDataMongoDB"><a href="#SpringDataMongoDB" class="headerlink" title="SpringDataMongoDB"></a>SpringDataMongoDB</h3><p>SpringData家族成员之一，用于操作MongoDb的持久层框架，封装了底层的mongodb-driver。<br>官网主页： <a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">https://projects.spring.io/spring-data-mongodb/</a></p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h3 id="什么是ElasticSearch"><a href="#什么是ElasticSearch" class="headerlink" title="什么是ElasticSearch"></a>什么是ElasticSearch</h3><p>Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<h3 id="ElasticSearch特点"><a href="#ElasticSearch特点" class="headerlink" title="ElasticSearch特点"></a>ElasticSearch特点</h3><ol>
<li>可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上</li>
<li>将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；</li>
<li>开箱即用的，部署简单</li>
<li>全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理</li>
</ol>
<h3 id="ElasticSearch体系结构"><a href="#ElasticSearch体系结构" class="headerlink" title="ElasticSearch体系结构"></a>ElasticSearch体系结构</h3><p>下表是Elasticsearch与MySQL数据库逻辑结构概念的对比</p>
<table>
<thead>
<tr>
<th>Elasticsearch</th>
<th>关系型数据库Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>索引(index)</td>
<td>数据库(databases)</td>
</tr>
<tr>
<td>类型(type)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>行(row)</td>
</tr>
</tbody></table>
<h3 id="Head插件"><a href="#Head插件" class="headerlink" title="Head插件"></a>Head插件</h3><p>在学习Elasticsearch的过程中，必不可少需要通过一些工具查看es的运行状态以及数据。如果都是通过rest请求，未免太过麻烦，而且也不够人性化。此时，head可以完美的帮助你快速学习和使用es。</p>
<p>Head插件可以实现基本信息的查看，rest请求的模拟，数据的检索等等。</p>
<h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>IK分词是一款国人开发的相对简单的中文分词器。虽然开发者自2012年之后就不在维护了，但在工程应用中IK算是比较流行的一款！</p>
<h2 id="项目整理"><a href="#项目整理" class="headerlink" title="项目整理"></a>项目整理</h2><h3 id="应用世界"><a href="#应用世界" class="headerlink" title="应用世界"></a>应用世界</h3><h4 id="Hacker-News排名算法"><a href="#Hacker-News排名算法" class="headerlink" title="Hacker News排名算法"></a>Hacker News排名算法</h4><blockquote>
<p><a href="https://libo9527.github.io/2019/01/05/Study-Notes-of-Algorithm/" target="_blank" rel="noopener">排名算法</a></p>
</blockquote>
<p><img data-src="https://i.loli.net/2018/12/12/5c10c01fd8f48.png" alt="img"></p>
<p>P：表示帖子的得票数，减去1是为了忽略发帖人的投票。</p>
<p>T：表示距离发帖的时间（单位为小时），加上2是为了防止最新的帖子导致分母过小（之所以选择2，可能是因为从原始文章出现在其他网站，到转贴至Hacker News，平均需要两个小时）。</p>
<p>G：表示”重力因子”（gravityth power），即将帖子排名往下拉的力量，默认值为1.8</p>
<p>结论：</p>
<ol>
<li>得票越多，排名越高。</li>
<li>发帖时间越新，排名越高。或者说，帖子的排名会随着时间不断下降。（经过24小时之后，所有帖子的得分基本上都小于1）</li>
<li><strong>重力因子G</strong>数值大小决定了排名随时间下降的速度。G值越大，排名下降得越快。</li>
</ol>
<p>缺点：用户只能投赞成票，不允许用户投反对票</p>
<p>项目中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RankingUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排名算法，分数越大越靠前</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 阅读数/点击数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h 小时数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 小时偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> g 重力因子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">score</span><span class="params">(Integer p, Integer h, Integer t, <span class="keyword">double</span> g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> score = (<span class="keyword">int</span>) (((p - <span class="number">1</span>) / Math.pow(h + t, g)));</span><br><span class="line">        <span class="keyword">return</span> score &lt;= <span class="number">0</span> ? <span class="number">0</span> : score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：应用世界中的应用排名。后期需求要求可以手动排名，加了排序数字段。将距离应用上架时间和重力因子作为动态配置参数，通过sprint boot的actuator的自动监听实现在不重启服务器的情况下<a href="https://blog.csdn.net/xtayfjpk/article/details/81334704" target="_blank" rel="noopener">自动刷新配置</a>。</p>
<h4 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h4><h5 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h5><ol>
<li><p>SecurityManager</p>
<p>这个类是shiro的核心，shiro的所有功能（登录校验、授权）都是通过这个类实现的。但是他其实什么都不做，他只是一个平台，就像淘宝一样，自己啥也不卖，而是让别人卖 。securityManager是通过它内部的属性来实现的各种功能的，其中最主要的就是Reaml。</p>
</li>
<li><p>Realm</p>
<p>realm有“域”的意思，引申为“来源”，也就是说某些东西原来是在哪的，在shiro判断某个用户能不能登录或者是能不能做什么事的时候，他需要知道之前程序对该用户的信息（比如用户名，密码，角色，权限）的存储放在哪里，这个“哪里”就是realm，我们在实际开发中只有一个域，那就是关系型数据库中的User表，但是有的情况下可能有多个域，比如某些网站允许你使用qq号登陆，也允许你使用自己注册的账号登陆，那就有两个域。简单一句话，域就是存储用户信息的地方，这个很好理解。在以后shiro的登录校验和权限管理的时候都是需要这个接口的，因为他存储了所有的信息。他的实现类有AuthenticationRealm，用来处理登录，AuthorizingRealm，用来处理访问权限。Realm就是提供AuthorizationInfo（权限认证结果）和AuthenticationInfo（登录认证结果）这两个对象的地方。</p>
</li>
<li><p>AuthenticationToken</p>
<p>校验的标签，这个类使用在用户登录的时候，用户填写了用户名+密码，然后我们将其封装在这个类中，用来和数据库中的比较，然后得出结果，返回的结果就是下一个类。</p>
</li>
<li><p>AuthenticationInfo</p>
<p>校验的信息，这个类是在校验完了用户登录之后产生的，校验的结果有很多种，比如根本不存在这个用户或者有用户但是密码不对或者当前用于由于多次输入错误密码而被锁定或者当前用户没有激活（有的情况下可能需要用邮箱激活）或者是重复登录等等，完全可以定义自己的校验失败的情况。在校验成功之后，我们就要返回一个AuthenticationInfo，里面包含了这个用户的很多标示符Principal（不仅仅是用户名）和密码（Credential）。</p>
</li>
<li><p>Principal</p>
<p>是主体（subject）进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。</p>
</li>
<li><p>subject</p>
<p>就是用户，user。只不过这里的user并不一定是一个人，而是任何可能会访问我们应用的请求，比如定期调度的工作。</p>
</li>
</ol>
<h4 id="策略模式实现多模式上架应用"><a href="#策略模式实现多模式上架应用" class="headerlink" title="策略模式实现多模式上架应用"></a>策略模式实现多模式上架应用</h4><p>上架应用时可以指定应用的模式：</p>
<ol>
<li>默认模式：什么都不做</li>
<li>过期时间模式：到达指定时间够自动下架应用</li>
<li>用户数模式：当有指定数量的用户点击过该应用后自动下架</li>
<li>点击数模式：当有指定数量的点击数后自动下架应用</li>
</ol>
<p>用户的每次点击操作都会触发模式处理。用户点击后先找到对应应用的模式ID根据模式ID返回不用的模式处理器进行相应处理。</p>
<p>策略模式和工厂模式在结构上很像，但工厂是创建型模式,它的作用就是创建对象； 而策略是行为型模式,它的作用是让一个对象在许多行为中选择一种行为;</p>
<h4 id="腾讯云OSS对象存储"><a href="#腾讯云OSS对象存储" class="headerlink" title="腾讯云OSS对象存储"></a>腾讯云OSS对象存储</h4><p>结合腾讯云的官方文档和SDK实现即可。上传图片就是先把图片上传到服务器，然后再上传到腾讯云，得到图片链接地址后存到数据库，再将服务器上的图片文件删除即可。</p>
<h4 id="Beetl"><a href="#Beetl" class="headerlink" title="Beetl"></a>Beetl</h4><p>Beetl（“bi tou”）对java语言的良好支持和很好的性能。官网说性能是Freemarker的6倍。它的语法官方文档上全都有很方便，而且都是中文。</p>
<p>那么为什么要用模板引擎呢？很简单的原因，实际应用场景中文本的格式是固定的，但是内容有所不同。如果是不复杂的内容我们可以直接用代码生成需要的文本。但是当文本变得复杂的时候，我们用java生成文本的性能就会下降，同时也不利于维护。解决办法是将数据和格式进行分离，将一个文本分成模板和数据。模板中有固定的格式，需要动态变化的数据一般用占位符代替。这样我们想改模板格式的时候不需要去更改代码，只需要去改模板就可以了。同时模板引擎渲染文本的效率也会更高。</p>
<h5 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h5><p>应用世界中将应用的介绍页面使用Beetl生成静态化的HTML页面放入腾讯云的OSS中。适合静态化的页面是哪些很少变动，访问量又大的页面。</p>
<p>通过GroupTemplate 来生成页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BeetlString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//new一个模板资源加载器</span></span><br><span class="line">    StringTemplateResourceLoader resourceLoader = <span class="keyword">new</span> StringTemplateResourceLoader();</span><br><span class="line">    <span class="comment">/* 使用Beetl默认的配置。</span></span><br><span class="line"><span class="comment">         * Beetl可以使用配置文件的方式去配置，但由于此处是直接上手的例子，</span></span><br><span class="line"><span class="comment">         * 我们不去管配置的问题，只需要基本的默认配置就可以了。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Configuration config = Configuration.defaultConfiguration();</span><br><span class="line">    <span class="comment">//Beetl的核心GroupTemplate</span></span><br><span class="line">    GroupTemplate groupTemplate = <span class="keyword">new</span> GroupTemplate(resourceLoader, config);</span><br><span class="line">    <span class="comment">//我们自定义的模板，其中$&#123;title&#125;就Beetl默认的占位符</span></span><br><span class="line">    String testTemplate=<span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;head&gt;\n"</span> +</span><br><span class="line">        <span class="string">"\t&lt;title&gt;$&#123;title&#125;&lt;/title&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;/head&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;body&gt;\n"</span> +</span><br><span class="line">        <span class="string">"\t&lt;h1&gt;$&#123;name&#125;&lt;/h1&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;/body&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">    Template template = groupTemplate.getTemplate(testTemplate);</span><br><span class="line">    template.binding(<span class="string">"title"</span>,<span class="string">"This is a test template Email."</span>);</span><br><span class="line">    template.binding(<span class="string">"name"</span>, <span class="string">"beetl"</span>);</span><br><span class="line">    <span class="comment">//渲染字符串</span></span><br><span class="line">    String str = template.render();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a test template Email.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>beetl<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="THNews资讯分享平台"><a href="#THNews资讯分享平台" class="headerlink" title="THNews资讯分享平台"></a>THNews资讯分享平台</h3><h4 id="分布式-ID-生成器"><a href="#分布式-ID-生成器" class="headerlink" title="分布式 ID 生成器"></a>分布式 ID 生成器</h4><p>由于分布式下的分库分表（太难了，不是我做的）需要保证全局唯一的ID，故需要分布式 ID 生成器来生成 ID。使用最多的是Twitter公司的SnowFlake算法，就是著名的《<strong>雪花算法</strong>》。</p>
<h5 id="SnowFlake原理"><a href="#SnowFlake原理" class="headerlink" title="SnowFlake原理"></a>SnowFlake原理</h5><p>SnowFlake产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：</p>
<blockquote>
<p>0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</p>
</blockquote>
<ol>
<li><p>1位：标识，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；</p>
</li>
<li><p>41位：时间戳部分，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年；</p>
</li>
<li><p>10位：节点部分，Twitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点；</p>
</li>
<li><p>12位：序列号部分，支持同一毫秒内同一个节点可以生成4096个ID；</p>
</li>
</ol>
<p>SnowFlake算法生成的ID大致上是按照时间递增的，用在分布式系统中时，需要注意数据中心标识和机器标识必须唯一，这样就能保证每个节点生成的ID都是唯一的！</p>
<h4 id="有状态（SESSION）和无状态（JWT）登录验证"><a href="#有状态（SESSION）和无状态（JWT）登录验证" class="headerlink" title="有状态（SESSION）和无状态（JWT）登录验证"></a>有状态（SESSION）和无状态（JWT）登录验证</h4><blockquote>
<p><a href="https://blog.csdn.net/kikajack/article/details/80293328" target="_blank" rel="noopener">从有状态应用（Session）到无状态应用（JWT），以及 SSO 和 OAuth2</a></p>
</blockquote>
<p>有状态的登录验证就是将会话信息存放在服务器中。而无状态的登录验证就是服务器不存会话信息。</p>
<table>
<thead>
<tr>
<th></th>
<th>有状态</th>
<th>无状态</th>
</tr>
</thead>
<tbody><tr>
<td>数据同步</td>
<td>需要同步</td>
<td>无需同步</td>
</tr>
<tr>
<td>资源消耗</td>
<td>消耗内存资源保存数据<br />消耗带宽进行数据同步</td>
<td>无内存消耗<br />无带宽消耗<br />耗费CPU计算资源</td>
</tr>
</tbody></table>
<p>由于HTTP 协议是无状态的，要保存用户状态需要额外的机制。一般有两种方式，Session和JWT，session是有状态的，jwt是无状态的。</p>
<h5 id="Session-原理"><a href="#Session-原理" class="headerlink" title="Session 原理"></a>Session 原理</h5><p>最传统的用户认证方式。用户首次访问应用服务器后建立会话，服务器可以使用 Set-Cookie 这个 HTTP Header，将会话的 SessionID 写入在用户端保存的 Cookie 中。下次用户再次向这个域名发请求时会携带所有 Cookie 信息，包括这个 SessionID。</p>
<p>Session 信息保存在服务器端，而用于唯一标识这个 Session 的 SessionID 则保存在对应客户端的 Cookie 中。SessionID 这个会话标识符本质上是一个随机字符串，每个用户的 SessionID 都不一样。</p>
<p>Session 中可以保存很多信息。例如设置一个 IsLogin 字段，用户通过账号密码登录后，将这个字段设置为 TRUE。这样，在 Session 的有效期内（比如 2 小时），即使用户关闭网页，再次打开后仍会保持登录状态（除非用户清理了 Cookie，导致其访问服务器时没有携带 SessionID 字段）。对于其他的常用字段（如 userID、userName等）也可以添加到 Session 中，以减少数据库的访问压力，但注意不要太大，因为所有用户的会话信息都是保存在服务器的内存中的。</p>
<h5 id="JWT-原理"><a href="#JWT-原理" class="headerlink" title="JWT 原理"></a>JWT 原理</h5><p>JWT（JSON web token）是一种认证协议，可以发布接入令牌（Access Token，保持在客户端）并对发布的签名接入令牌进行验证。令牌（Token）本身包含一系列声明，应用程序可以根据这些声明限制用户对资源的访问。</p>
<p>JWT 由三段信息构成的：header、payload、signature</p>
<h5 id="JWT-工作流程"><a href="#JWT-工作流程" class="headerlink" title="JWT 工作流程"></a>JWT 工作流程</h5><p>用户通过账号密码发起登录请求服务器验证通过后，设置 header 和 payload，并得到加密后的签名，然后将这三部分作为 Token 发送给用户，客户端保存 Token，并在每个请求中附加这个 Token。如果请求携带了 Token，服务器会验证这个 Token 并根据验证结果进行不同处理。</p>
<p>发送请求时，Token 放在请求的 HTTP Header 中。另外，如果发生跨域，例如 <a href="http://www.xx.com" target="_blank" rel="noopener">www.xx.com</a> 下发出到 api.xx.com 的请求，需要在服务端开启 CORS（Cross-Origin Resource Sharing 跨域资源共享），只需要在controller类上添加注解<code>@CrossOrigin</code> 即可！</p>
<h5 id="基于JWT的Token认证机制"><a href="#基于JWT的Token认证机制" class="headerlink" title="基于JWT的Token认证机制"></a>基于JWT的Token认证机制</h5><h6 id="什么是JWT-1"><a href="#什么是JWT-1" class="headerlink" title="什么是JWT"></a>什么是JWT</h6><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<h6 id="JWT组成-1"><a href="#JWT组成-1" class="headerlink" title="JWT组成"></a>JWT组成</h6><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p>
<p>头部（Header）</p>
<p>头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"typ"</span>:<span class="string">"JWT"</span>,<span class="attr">"alg"</span>:<span class="string">"HS256"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在头部指明了签名算法是HS256算法。 我们进行BASE64编码<a href="http://base64.xpcha.com/，编码后的字符串如下：" target="_blank" rel="noopener">http://base64.xpcha.com/，编码后的字符串如下：</a></p>
<blockquote>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>
</blockquote>
<p>小知识：Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 BASE64Encoder 和 BASE64Decoder，用它们可以非常方便的完成基于 BASE64 的编码和解码.</p>
<p>载荷（playload）</p>
<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<p>（1）标准中注册的声明（建议但不强制使用）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">iss:</span> <span class="string">jwt签发者</span></span><br><span class="line"><span class="string">sub:</span> <span class="string">jwt所面向的用户</span></span><br><span class="line"><span class="string">aud:</span> <span class="string">接收jwt的一方</span></span><br><span class="line"><span class="string">exp:</span> <span class="string">jwt的过期时间，这个过期时间必须要大于签发时间</span></span><br><span class="line"><span class="string">nbf:</span> <span class="string">定义在什么时间之前，该jwt都是不可用的.</span></span><br><span class="line"><span class="string">iat:</span> <span class="string">jwt的签发时间</span></span><br><span class="line"><span class="string">jti:</span> <span class="string">jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span></span><br></pre></td></tr></table></figure>

<p>（2）公共的声明<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.<br>（3）私有的声明<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。这个指的就是自定义的claim。比如前面那个结构举例中的admin和name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p>
<p>定义一个payload:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"sub"</span>:<span class="string">"1234567890"</span>,<span class="attr">"name"</span>:<span class="string">"John Doe"</span>,<span class="attr">"admin"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>然后将其进行base64编码，得到Jwt的第二部分。</p>
<blockquote>
<p>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</p>
</blockquote>
<p>签证（signature）</p>
<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ol>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ol>
<p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<blockquote>
<p>TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</blockquote>
<p>将这三部分用<code>.</code>连接成一个完整的字符串,构成了最终的jwt:</p>
<blockquote>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</blockquote>
<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
<h6 id="Java的JJWT实现JWT-1"><a href="#Java的JJWT实现JWT-1" class="headerlink" title="Java的JJWT实现JWT"></a>Java的JJWT实现JWT</h6><h6 id="什么是JJWT-1"><a href="#什么是JJWT-1" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h6><p>JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p>
<h6 id="JJWT快速入门-1"><a href="#JJWT快速入门-1" class="headerlink" title="JJWT快速入门"></a>JJWT快速入门</h6><p><strong>token的创建</strong></p>
<p>（1）创建maven工程，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）创建类CreateJwtTest，用于生成token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JwtBuilder builder= Jwts.builder().setId(<span class="string">"888"</span>)</span><br><span class="line">                .setSubject(<span class="string">"小白"</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println( builder.compact() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setIssuedAt用于设置签发时间, signWith用于设置签名秘钥</p>
<p>（3）测试运行，输出如下:</p>
<blockquote>
<p>eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTM0NTh9.gq0J‐cOM_qCNqU_s‐d_IrRytaNenesPmqAIhQpYXHZk</p>
</blockquote>
<p>再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间。</p>
<p><strong>token的解析</strong></p>
<p>我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。</p>
<p>创建ParseJwtTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String token = <span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTM0NTh9.gq0J‐cOM_qCNqU_s‐d_IrRytaNenesPmqAIhQpYXHZk"</span>;</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(<span class="string">"itcast"</span>).parseClaimsJws(token).getBody();</span><br><span class="line">        System.out.println(<span class="string">"id:"</span>+claims.getId());</span><br><span class="line">        System.out.println(<span class="string">"subject:"</span>+claims.getSubject());</span><br><span class="line">        System.out.println(<span class="string">"IssuedAt:"</span>+claims.getIssuedAt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token</p>
<p><strong>token过期校验</strong></p>
<p>有很多时候，我们并不希望签发的token是永久生效的，所以我们可以为token添加一个过期时间。</p>
<p>创建CreateJwtTest2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJwtTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了方便测试，我们将过期时间设置为1分钟</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();<span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">long</span> exp = now + <span class="number">1000</span>*<span class="number">60</span>;<span class="comment">//过期时间为1分钟</span></span><br><span class="line">        JwtBuilder builder= Jwts.builder().setId(<span class="string">"888"</span>)</span><br><span class="line">                .setSubject(<span class="string">"小白"</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"itcast"</span>)</span><br><span class="line">           .setExpiration(<span class="keyword">new</span> Date(exp));      </span><br><span class="line">        System.out.println( builder.compact() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setExpiration 方法用于设置过期时间</p>
<p>修改ParseJwtTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String compactJws=<span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTY1NjksImV4cCI6MTUyMzQxNjYyOX0.Tk91b6mvyjpKcldkic8DgXz0zsPFFnRgTgkgcAsa9cc"</span>;</span><br><span class="line">        Claims claims =</span><br><span class="line">Jwts.parser().setSigningKey(<span class="string">"itcast"</span>).parseClaimsJws(compactJws).getBody();</span><br><span class="line">        System.out.println(<span class="string">"id:"</span>+claims.getId());</span><br><span class="line">        System.out.println(<span class="string">"subject:"</span>+claims.getSubject());</span><br><span class="line">        SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy‐MM‐dd hh:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"签发时间:"</span>+sdf.format(claims.getIssuedAt()));</span><br><span class="line">        System.out.println(<span class="string">"过期时间:"</span>+sdf.format(claims.getExpiration()));</span><br><span class="line">        System.out.println(<span class="string">"当前时间:"</span>+sdf.format(<span class="keyword">new</span> Date()) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试运行，当未过期时可以正常读取，当过期时会引发io.jsonwebtoken.ExpiredJwtException异常。</p>
<p><strong>自定义claims</strong></p>
<p>我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims </p>
<p>创建CreateJwtTest3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJwtTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了方便测试，我们将过期时间设置为1分钟</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();<span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">long</span> exp = now + <span class="number">1000</span>*<span class="number">60</span>;<span class="comment">//过期时间为1分钟</span></span><br><span class="line">        JwtBuilder builder= Jwts.builder().setId(<span class="string">"888"</span>)</span><br><span class="line">                .setSubject(<span class="string">"小白"</span>)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"itcast"</span>)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(exp))</span><br><span class="line">                .claim(<span class="string">"roles"</span>,<span class="string">"admin"</span>)</span><br><span class="line">                .claim(<span class="string">"logo"</span>,<span class="string">"logo.png"</span>);</span><br><span class="line">        System.out.println( builder.compact() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改ParseJwtTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseJwtTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String</span><br><span class="line">compactJws=<span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTczMjMsImV4cCI6MTUyMzQxNzM4Mywicm9sZXMiOiJhZG1pbiIsImxvZ28iOiJsb2dvLnBuZyJ9.b11p4g4rE94rqFhcfzdJTPCORikqP_1zJ1MP8KihYTQ"</span>;</span><br><span class="line">        Claims claims =</span><br><span class="line">Jwts.parser().setSigningKey(<span class="string">"itcast"</span>).parseClaimsJws(compactJws).getBody();</span><br><span class="line">        System.out.println(<span class="string">"id:"</span>+claims.getId());</span><br><span class="line">        System.out.println(<span class="string">"subject:"</span>+claims.getSubject());</span><br><span class="line">        System.out.println(<span class="string">"roles:"</span>+claims.get(<span class="string">"roles"</span>));</span><br><span class="line">        System.out.println(<span class="string">"logo:"</span>+claims.get(<span class="string">"logo"</span>));</span><br><span class="line">        SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy‐MM‐dd hh:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"签发时间:"</span>+sdf.format(claims.getIssuedAt()));</span><br><span class="line">        System.out.println(<span class="string">"过期时间:"</span>+sdf.format(claims.getExpiration()));</span><br><span class="line">        System.out.println(<span class="string">"当前时间:"</span>+sdf.format(<span class="keyword">new</span> Date()) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>吐槽和评论两项功能存在以下特点：<br>（1）数据量大<br>（2）写入操作频繁<br>（3）价值较低<br>对于这样的数据，我们更适合使用MongoDB来实现数据的存储</p>
<h5 id="什么是MongoDB-1"><a href="#什么是MongoDB-1" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h5><p>MongoDB 是一个跨平台的，面向文档的数据库，它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。</p>
<p>MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。</p>
<p>MongoDB 的逻辑结构是一种层次结构。主要由：<br>文档(document)、集合(collection)、数据库(database)这三部分组成的。<br>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。<br>（2）多个文档组成一个集合（collection），相当于关系数据库的表。<br>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。<br>（4）一个 MongoDB 实例支持多个数据库（database）</p>
<h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ol>
<li>null：用于表示空值或者不存在的字段，{“x”:null}</li>
<li>布尔型：布尔类型有两个值true和false，{“x”:true}</li>
<li>数值：shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用 NumberInt（4字节符号整数）或NumberLong（8字节符号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</li>
<li>字符串：UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}</li>
<li>日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()}</li>
<li>正则表达式：查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相同，{“x”:/[abc]/}</li>
<li>数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}</li>
<li>内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}</li>
<li>对象Id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() }</li>
<li>二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非utf-字符保存到数据库中，二进制数据是唯一的方式。</li>
<li>代码：查询和文档中可以包括任何JavaScript代码，{“x”:function(){/…/}}</li>
</ol>
<h5 id="Java操作MongoDB-1"><a href="#Java操作MongoDB-1" class="headerlink" title="Java操作MongoDB"></a>Java操作MongoDB</h5><p>mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。</p>
<p>SpringDataMongoDB是SpringData家族成员之一，用于操作MongoDb的持久层框架，封装了底层的mongodb-<br>driver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 吐槽数据访问层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitDao</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Spit</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> SpitDao spitDao;    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> IdWorker idWorker;    </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spit&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> spitDao.findAll();                </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spit <span class="title">findById</span><span class="params">(String id)</span></span>&#123;    </span><br><span class="line">        Spit spit = spitDao.findById(id).get();        </span><br><span class="line">        <span class="keyword">return</span> spit;        </span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Spit spit)</span> </span>&#123;    </span><br><span class="line">        spit.set_id(idWorker.nextId()+<span class="string">""</span>); <span class="comment">//主键值        </span></span><br><span class="line">        spitDao.save(spit);        </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Spit spit)</span> </span>&#123;    </span><br><span class="line">        spitDao.save(spit);        </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span> </span>&#123;    </span><br><span class="line">        spitDao.deleteById(id);        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p>文章模块将文章放在缓存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;    </span><br><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 根据ID查询实体 </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Article <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//从缓存中提取        </span></span><br><span class="line">    Article article=</span><br><span class="line">        (Article)redisTemplate.opsForValue().get(<span class="string">"article_"</span>+id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存没有则到数据库查询并放入缓存        </span></span><br><span class="line">    <span class="keyword">if</span>(article==<span class="keyword">null</span>) &#123;        </span><br><span class="line">        article = articleDao.findById(id).get();            </span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"article_"</span> + id, article);   </span><br><span class="line">        <span class="comment">//添加缓存过期时间</span></span><br><span class="line">        <span class="comment">//redisTemplate.opsForValue().set("article_" + id, article,10,TimeUnit.SECONDS);</span></span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> article;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 修改    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Article article)</span> </span>&#123;    </span><br><span class="line">    redisTemplate.delete( <span class="string">"article_"</span> + article.getId() );<span class="comment">//删除缓存        </span></span><br><span class="line">    articleDao.save(article);        </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 删除      </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span> </span>&#123;    </span><br><span class="line">    redisTemplate.delete( <span class="string">"article_"</span> + id );<span class="comment">//删除缓存        </span></span><br><span class="line">    articleDao.deleteById(id);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-Cache的使用"><a href="#Spring-Cache的使用" class="headerlink" title="Spring Cache的使用"></a>Spring Cache的使用</h5><blockquote>
<p><a href="https://www.jianshu.com/p/931484bb3fdc" target="_blank" rel="noopener">使用 Spring Cache + Redis 作为缓存</a></p>
</blockquote>
<p>活动详情的缓存采用Spring Cache实现</p>
<p>使用Spring Cache只需要记住三个主机即可：</p>
<ol>
<li>@EnableCaching：加在启动类上开启缓存支持。</li>
<li>@Cacheable：使用这个注解的方法在执行后会缓存其返回结果。</li>
<li>@CacheEvict：使用这个注解的方法在其执行前或执行后移除Spring Cache中的某些元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 根据ID查询实体    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"gathering"</span>,key=<span class="string">"#id"</span>)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Gathering <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> gatheringDao.findById(id).get();        </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 修改    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gathering    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="meta">@CacheEvict</span>(value=<span class="string">"gathering"</span>,key=<span class="string">"#gathering.id"</span>)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Gathering gathering)</span> </span>&#123;    </span><br><span class="line">    gatheringDao.save(gathering);        </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 删除    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="meta">@CacheEvict</span>(value=<span class="string">"gathering"</span>,key=<span class="string">"#id"</span>)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span> </span>&#123;    </span><br><span class="line">    gatheringDao.deleteById(id);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>ActiveMQ没有交换机的概念，直接将消息发送到队列中。</p>
<p>交换器（Exchange）连接队列（Queue）的方式常用的有三种：直接模式、分列模式、主题模式。</p>
<ul>
<li><p>直连模式就是通过默认的交换器（默认的交换器名字为一个空字符串<code>&quot;&quot;</code>）将消息转发到队列中。</p>
</li>
<li><p>分列模式通过交换器与队列的绑定（Binding），交换器会将消息转发到所有绑定的队列中。</p>
</li>
<li><p>主题模式也需要绑定交换器与队列，但每个队列都只关心部分消息，即交换器只会将队列关心的消息转发到对应的队列中。</p>
</li>
</ul>
<p>项目中的短信验证码用到了RabbitMQ和Redis来实现。</p>
<ol>
<li><p>用户注册后将手机号作为key，验证码作为value，存放在缓存中，设置过期时间为五分钟。</p>
</li>
<li><p>将手机号和验证码放到map中，然后发送到以“sms”为名字的队列中（使用的是直连模式）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;    </span><br><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;    </span><br><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"> * 发送短信验证码    </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mobile 手机号    </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(String mobile)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//1.生成6位短信验证码        </span></span><br><span class="line">    Random random=<span class="keyword">new</span> Random();        </span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">999999</span>;<span class="comment">//最大数        </span></span><br><span class="line">    <span class="keyword">int</span> min=<span class="number">100000</span>;<span class="comment">//最小数        </span></span><br><span class="line">    <span class="keyword">int</span> code = random.nextInt(max);<span class="comment">//随机生成        </span></span><br><span class="line">    <span class="keyword">if</span>(code&lt;min)&#123;        </span><br><span class="line">        code=code+min;            </span><br><span class="line">    &#125;        </span><br><span class="line">    System.out.println(<span class="string">"给"</span>+mobile+<span class="string">"发送的验证码是："</span>+code);        </span><br><span class="line">    <span class="comment">//2.将验证码放入redis        </span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"smscode_"</span>+mobile, code+<span class="string">""</span> ,<span class="number">5</span>,</span><br><span class="line">                                    TimeUnit.MINUTES );<span class="comment">//五分钟过期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将验证码和手机号发动到rabbitMQ中        </span></span><br><span class="line">    Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap();        </span><br><span class="line">    map.put(<span class="string">"mobile"</span>,mobile);        </span><br><span class="line">    map.put(<span class="string">"code"</span>,code+<span class="string">""</span>);        </span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"sms"</span>,map);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>短信模块中添加消息监听器处理消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 短信监听类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"sms"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  SmsUtil smsUtil;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;aliyun.sms.template_code&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String template_code;<span class="comment">//模板编号</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;aliyun.sms.sign_name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sign_name;<span class="comment">//签名</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"手机号："</span>+map.get(<span class="string">"mobile"</span>));</span><br><span class="line">        System.out.println(<span class="string">"验证码："</span>+map.get(<span class="string">"code"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            smsUtil.sendSms(map.get(<span class="string">"mobile"</span>),template_code,sign_name,<span class="string">"&#123;\"number\":\""</span>+ map.get(<span class="string">"code"</span>) +<span class="string">"\"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">全文搜索引擎 Elasticsearch 入门教程</a></p>
</blockquote>
<h5 id="什么是ElasticSearch-1"><a href="#什么是ElasticSearch-1" class="headerlink" title="什么是ElasticSearch"></a>什么是ElasticSearch</h5><p>Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<h5 id="ElasticSearch体系结构-1"><a href="#ElasticSearch体系结构-1" class="headerlink" title="ElasticSearch体系结构"></a>ElasticSearch体系结构</h5><table>
<thead>
<tr>
<th>Elasticsearch</th>
<th>关系型数据库Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>索引(index)</td>
<td>数据库(databases)</td>
</tr>
<tr>
<td>类型(type)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>行(row)</td>
</tr>
</tbody></table>
<p>默认情况下，Elastic 只允许本机访问，不允许跨域调用，如果需要远程访问，可以修改 Elastic 安装目录的<code>config/elasticsearch.yml</code>文件，增加以下两句命令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">http.cors.allow‐origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol>
<li><p>Node 与 Cluster</p>
<p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p>
<p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>
</li>
<li><p>Index</p>
<p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
</li>
<li><p>Document</p>
<p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>
<p>Document 使用 JSON 格式表示，下面是一个例子。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"user"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">  <span class="attr">"desc"</span>: <span class="string">"数据库管理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
</li>
<li><p>Type</p>
<p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html" target="_blank" rel="noopener">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch" target="_blank" rel="noopener">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>
</li>
</ol>
<h5 id="Head插件-1"><a href="#Head插件-1" class="headerlink" title="Head插件"></a>Head插件</h5><p>一般使用图形化界面来实现Elasticsearch的日常管理，最常用的就是Head插件。</p>
<h5 id="IK分词器-1"><a href="#IK分词器-1" class="headerlink" title="IK分词器"></a>IK分词器</h5><p>ES默认的中文分词是将每个字看成一个词，这显然是不符合要求的，所以我们需要安装中文分词器来解决这个问题。</p>
<p>IK分词是一款国人开发的相对简单的中文分词器。虽然开发者自2012年之后就不在维护了，但在工程应用中IK算是比较流行的一款！</p>
<h5 id="搜索模块的开发"><a href="#搜索模块的开发" class="headerlink" title="搜索模块的开发"></a>搜索模块的开发</h5><ol>
<li><p>加依赖写配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="string">cluster‐nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文章实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Document</span>(indexName=<span class="string">"tensquare"</span>,type=<span class="string">"article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;<span class="comment">//ID</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Field</span>(index= <span class="keyword">true</span>,analyzer=<span class="string">"ik_max_word"</span>,searchAnalyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//标题</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Field</span>(index= <span class="keyword">true</span>,analyzer=<span class="string">"ik_max_word"</span>,searchAnalyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//文章正文</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String state;<span class="comment">//审核状态</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据访问接口（DAO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章数据访问层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleSearchDao</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Article</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findByTitleOrContentLike</span><span class="params">(String title, String content, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="elasticsearch与MySQL数据同步"><a href="#elasticsearch与MySQL数据同步" class="headerlink" title="elasticsearch与MySQL数据同步"></a>elasticsearch与MySQL数据同步</h5><p>Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集起来，并进行自定义的处理，然后传输到指定的位置，比如某个服务器或者文件。</p>
<p>MySQL数据导入Elasticsearch</p>
<ol>
<li><p>在logstash-5.6.8安装目录下创建文件夹mysqletc （名称随意）</p>
</li>
<li><p>文件夹下创建mysql.conf （名称随意） ，内容如下：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    # mysql jdbc connection string to our backup databse  后面的test</span><br><span class="line">对应mysql中的test数据库</span><br><span class="line">    jdbc_connection_string =&gt;</span><br><span class="line">"jdbc:mysql://127.0.0.1:3306/tensquare_article?characterEncoding=UTF8"</span><br><span class="line">    # the user we wish to excute our statement as</span><br><span class="line">    jdbc_user =&gt; "root"</span><br><span class="line">    jdbc_password =&gt; "123456"</span><br><span class="line">    # the path to our downloaded jdbc driver  </span><br><span class="line">    jdbc_driver_library =&gt; "D:/logstash‐5.6.8/mysqletc/mysql‐</span><br><span class="line">connector‐java‐5.1.46.jar"</span><br><span class="line">    # the name of the driver class for mysql</span><br><span class="line">    jdbc_driver_class =&gt; "com.mysql.jdbc.Driver"</span><br><span class="line">    jdbc_paging_enabled =&gt; "true"</span><br><span class="line">    jdbc_page_size =&gt; "50000"</span><br><span class="line">    #以下对应着要执行的sql的绝对路径。</span><br><span class="line">    statement =&gt; "select id,title,content from tb_article"</span><br><span class="line">    #定时字段 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为</span><br><span class="line">每分钟都更新</span><br><span class="line">      schedule =&gt; "* * * * *"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    #ESIP地址与端口</span><br><span class="line">    hosts =&gt; "localhost:9200" </span><br><span class="line">    #ES索引名称（自己定义的）</span><br><span class="line">    index =&gt; "tensquare"</span><br><span class="line">    #自增ID编号</span><br><span class="line">    document_id =&gt; "%&#123;id&#125;"</span><br><span class="line">    document_type =&gt; "article"</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123;</span><br><span class="line">      #以JSON格式输出</span><br><span class="line">      codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将mysql驱动包mysql-connector-java-5.1.46.jar拷贝至D:/logstash-5.6.8/mysqletc/ 下 。D:/logstash-5.6.8是你的安装目录</li>
<li>每间隔1分钟就执行一次sql查询。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hexo 多分类综合工具合集方案与使用手册</title>
    <url>/2025/10/20/Hexo-%E5%A4%9A%E5%88%86%E7%B1%BB%E7%BB%BC%E5%90%88%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86%E6%96%B9%E6%A1%88%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="Hexo-多分类综合工具合集方案与使用手册"><a href="#Hexo-多分类综合工具合集方案与使用手册" class="headerlink" title="Hexo 多分类综合工具合集方案与使用手册"></a>Hexo 多分类综合工具合集方案与使用手册</h1><h2 id="一、方案设计核心思路"><a href="#一、方案设计核心思路" class="headerlink" title="一、方案设计核心思路"></a>一、方案设计核心思路</h2><h3 id="1-1-核心目标"><a href="#1-1-核心目标" class="headerlink" title="1.1 核心目标"></a>1.1 核心目标</h3><p>打破单一理财工具局限，构建支持<strong>多分类、可扩展</strong>的综合工具库，实现 “分类导航 - 工具筛选 - 快速使用” 的完整流程，同时保持页面美观与操作便捷性。</p>
<h3 id="1-2-方案亮点"><a href="#1-2-方案亮点" class="headerlink" title="1.2 方案亮点"></a>1.2 方案亮点</h3><a id="more"></a>

<ul>
<li><p><strong>三级结构设计</strong>：「工具首页（总入口）→ 分类页（如投资类）→ 工具详情页」，层级清晰；</p>
</li>
<li><p><strong>分类灵活配置</strong>：支持新增 / 删除分类（如后续添加 “生活类”“设计类” 工具）；</p>
</li>
<li><p><strong>多类型工具适配</strong>：无论是 HTML 静态工具（如计算器）、在线工具链接（如代码格式化工具），还是文档类工具（如学习模板），均能统一管理；</p>
</li>
<li><p><strong>用户体验优化</strong>：添加分类筛选、工具搜索功能，方便快速找到目标工具。</p>
</li>
</ul>
<h2 id="二、多分类工具合集方案（落地架构）"><a href="#二、多分类工具合集方案（落地架构）" class="headerlink" title="二、多分类工具合集方案（落地架构）"></a>二、多分类工具合集方案（落地架构）</h2><h3 id="2-1-目录结构设计（核心）"><a href="#2-1-目录结构设计（核心）" class="headerlink" title="2.1 目录结构设计（核心）"></a>2.1 目录结构设计（核心）</h3><p>采用 “分类目录 + 工具子目录” 的层级结构，每个分类独立管理所属工具，后续新增分类 / 工具只需按此结构扩展：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo-blog&#x2F;</span><br><span class="line"></span><br><span class="line">└── source&#x2F;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   └── tools&#x2F;                # 工具合集总目录（总入口）</span><br><span class="line"></span><br><span class="line">&amp;#x20;       ├── index.md          # 工具首页（分类导航+搜索+推荐工具）</span><br><span class="line"></span><br><span class="line">&amp;#x20;       ├── common&#x2F;           # 公共资源目录（共用CSS&#x2F;JS&#x2F;图标）</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   ├── css&#x2F;tool-common.css  # 所有页面共用样式</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   └── js&#x2F;tool-search.js    # 工具搜索功能脚本</span><br><span class="line"></span><br><span class="line">&amp;#x20;       ├── investment&#x2F;       # 分类1：投资类工具</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   ├── index.md      # 投资类分类页（展示该类下所有工具）</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   ├── calculator&#x2F;   # 工具1：投资资金配置计算器</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   │   └── index.html</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   └── compound&#x2F;     # 工具2：复利收益分析器</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │       └── index.html</span><br><span class="line"></span><br><span class="line">&amp;#x20;       ├── study&#x2F;            # 分类2：学习类工具</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   ├── index.md      # 学习类分类页</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   ├── note-template&#x2F; # 工具1：笔记模板生成器</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   │   └── index.html</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │   └── flashcard&#x2F;    # 工具2：单词卡片制作工具</span><br><span class="line"></span><br><span class="line">&amp;#x20;       │       └── index.html</span><br><span class="line"></span><br><span class="line">&amp;#x20;       └── coding&#x2F;           # 分类3：编程类工具</span><br><span class="line"></span><br><span class="line">&amp;#x20;           ├── index.md      # 编程类分类页</span><br><span class="line"></span><br><span class="line">&amp;#x20;           ├── formatter&#x2F;    # 工具1：代码格式化工具（静态HTML）</span><br><span class="line"></span><br><span class="line">&amp;#x20;           │   └── index.html</span><br><span class="line"></span><br><span class="line">&amp;#x20;           └── json-parser&#x2F;  # 工具2：JSON解析器（跳转外部链接）</span><br><span class="line"></span><br><span class="line">&amp;#x20;               └── index.md  # 用Markdown配置跳转链接</span><br></pre></td></tr></table></figure>

<h3 id="2-2-核心页面功能设计"><a href="#2-2-核心页面功能设计" class="headerlink" title="2.2 核心页面功能设计"></a>2.2 核心页面功能设计</h3><table>
<thead>
<tr>
<th>页面类型</th>
<th>核心功能</th>
<th>示例访问路径</th>
</tr>
</thead>
<tbody><tr>
<td>工具首页</td>
<td>1. 分类导航栏（投资 / 学习 / 编程）；2. 工具搜索框；3. 热门工具推荐；4. 分类简介</td>
<td><a href="http://xxx.com/tools/" target="_blank" rel="noopener">http://xxx.com/t</a><a href="http://xxx.com/tools/" target="_blank" rel="noopener">ools/</a></td>
</tr>
<tr>
<td>分类页（如投资类）</td>
<td>1. 展示该分类下所有工具卡片；2. 工具排序（热门 / 最新）；3. 返回首页按钮</td>
<td><a href="http://xxx.com/tools/investment/" target="_blank" rel="noopener">http://xxx.co</a><a href="http://xxx.com/tools/investment/" target="_blank" rel="noopener">m/too</a><a href="http://xxx.com/tools/investment/" target="_blank" rel="noopener">ls/in</a><a href="http://xxx.com/tools/investment/" target="_blank" rel="noopener">vestm</a><a href="http://xxx.com/tools/investment/" target="_blank" rel="noopener">ent/</a></td>
</tr>
<tr>
<td>工具详情页</td>
<td>1. 工具主体功能；2. 工具说明（用途 / 使用方法）；3. 返回分类页按钮</td>
<td><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">http://xxx.com/to</a><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">ols/i</a><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">nvest</a><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">ment/</a><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">calcu</a><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">lator</a><a href="http://xxx.com/tools/investment/calculator/" target="_blank" rel="noopener">/</a></td>
</tr>
</tbody></table>
<h2 id="三、使用手册（分步落地指南）"><a href="#三、使用手册（分步落地指南）" class="headerlink" title="三、使用手册（分步落地指南）"></a>三、使用手册（分步落地指南）</h2><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><h4 id="3-1-1-环境要求"><a href="#3-1-1-环境要求" class="headerlink" title="3.1.1 环境要求"></a>3.1.1 环境要求</h4><p>同原方案（Hexo ≥5.0、现代浏览器、文本编辑器），新增：若需实现搜索功能，需确保博客支持引入 JavaScript 脚本（默认支持）。</p>
<h4 id="3-1-2-依赖资源"><a href="#3-1-2-依赖资源" class="headerlink" title="3.1.2 依赖资源"></a>3.1.2 依赖资源</h4><ul>
<li><p>Font Awesome 图标库（分类图标、工具图标）；</p>
</li>
<li><p>公共 CSS/JS：<code>tool-common.css</code>（统一样式）、<code>tool-search.js</code>（搜索功能），后续会提供模板；</p>
</li>
<li><p>各类型工具资源：静态 HTML 工具、外部工具链接、文档模板等。</p>
</li>
</ul>
<h3 id="3-2-第一步：搭建工具首页（总入口，tools-index-md）"><a href="#3-2-第一步：搭建工具首页（总入口，tools-index-md）" class="headerlink" title="3.2 第一步：搭建工具首页（总入口，tools/``index.md）"></a>3.2 第一步：搭建工具首页（总入口，<code>tools/``index.md</code>）</h3><p>工具首页是用户进入工具库的第一站，核心是 “分类导航” 与 “快速搜索”，模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\---</span><br><span class="line"></span><br><span class="line">title: 综合工具合集</span><br><span class="line"></span><br><span class="line">date: 2025-10-21 10:00:00</span><br><span class="line"></span><br><span class="line">layout: page</span><br><span class="line"></span><br><span class="line">comments: false</span><br><span class="line"></span><br><span class="line">sidebar: false</span><br><span class="line"></span><br><span class="line">\---</span><br><span class="line"></span><br><span class="line">\&lt;!-- 搜索框 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;div class&#x3D;&quot;tool-search&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;searchInput&quot; placeholder&#x3D;&quot;搜索工具（如“代码格式化”“复利计算”）...&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;button id&#x3D;&quot;searchBtn&quot;&gt;\&lt;i class&#x3D;&quot;fas fa-search&quot;&gt;\&lt;&#x2F;i&gt;\&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;div id&#x3D;&quot;searchResult&quot; class&#x3D;&quot;search-result hidden&quot;&gt;\&lt;&#x2F;div&gt; \&lt;!-- 搜索结果展示区 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;!-- 分类导航 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;div class&#x3D;&quot;category-nav&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;h2 class&#x3D;&quot;nav-title&quot;&gt;工具分类\&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;div class&#x3D;&quot;category-cards&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 投资类分类卡片 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;investment&#x2F;&quot; class&#x3D;&quot;category-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;div class&#x3D;&quot;category-icon bg-blue-100 text-blue-600&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;       \&lt;i class&#x3D;&quot;fas fa-chart-pie fa-2x&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;h3 class&#x3D;&quot;category-name&quot;&gt;投资类工具\&lt;&#x2F;h3&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;p class&#x3D;&quot;category-desc&quot;&gt;10+ 投资计算、收益分析、风险评估工具\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 学习类分类卡片 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;study&#x2F;&quot; class&#x3D;&quot;category-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;div class&#x3D;&quot;category-icon bg-green-100 text-green-600&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;       \&lt;i class&#x3D;&quot;fas fa-book-open fa-2x&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;h3 class&#x3D;&quot;category-name&quot;&gt;学习类工具\&lt;&#x2F;h3&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;p class&#x3D;&quot;category-desc&quot;&gt;8+ 笔记模板、单词卡片、学习计划生成工具\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 编程类分类卡片 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;coding&#x2F;&quot; class&#x3D;&quot;category-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;div class&#x3D;&quot;category-icon bg-purple-100 text-purple-600&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;       \&lt;i class&#x3D;&quot;fas fa-code fa-2x&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;h3 class&#x3D;&quot;category-name&quot;&gt;编程类工具\&lt;&#x2F;h3&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;p class&#x3D;&quot;category-desc&quot;&gt;12+ 代码格式化、JSON解析、语法检查工具\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 新增分类只需复制上方卡片，修改图标、名称、链接 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;!-- 热门工具推荐 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;div class&#x3D;&quot;hot-tools&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;h2 class&#x3D;&quot;section-title&quot;&gt;热门工具\&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;div class&#x3D;&quot;tool-list&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 热门工具1：投资计算器 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;investment&#x2F;calculator&#x2F;&quot; class&#x3D;&quot;hot-tool-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;i class&#x3D;&quot;fas fa-calculator&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;h4&gt;投资资金配置计算器\&lt;&#x2F;h4&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;span class&#x3D;&quot;tool-category&quot;&gt;投资类\&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 热门工具2：代码格式化工具 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;coding&#x2F;formatter&#x2F;&quot; class&#x3D;&quot;hot-tool-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;i class&#x3D;&quot;fas fa-code&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;h4&gt;代码格式化工具\&lt;&#x2F;h4&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;span class&#x3D;&quot;tool-category&quot;&gt;编程类\&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;!-- 引入公共样式与脚本 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;font-awesome&#x2F;6.4.0&#x2F;css&#x2F;all.min.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">\&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;tools&#x2F;common&#x2F;css&#x2F;tool-common.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">\&lt;script src&#x3D;&quot;&#x2F;tools&#x2F;common&#x2F;js&#x2F;tool-search.js&quot;&gt;\&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-第二步：搭建分类页（如投资类，tools-investment-index-md）"><a href="#3-3-第二步：搭建分类页（如投资类，tools-investment-index-md）" class="headerlink" title="3.3 第二步：搭建分类页（如投资类，tools/investment/``index.md）"></a>3.3 第二步：搭建分类页（如投资类，<code>tools/investment/``index.md</code>）</h3><p>分类页展示该类下所有工具，结构统一，方便用户浏览，模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\---</span><br><span class="line"></span><br><span class="line">title: 投资类工具</span><br><span class="line"></span><br><span class="line">date: 2025-10-21 10:30:00</span><br><span class="line"></span><br><span class="line">layout: page</span><br><span class="line"></span><br><span class="line">comments: false</span><br><span class="line"></span><br><span class="line">sidebar: false</span><br><span class="line"></span><br><span class="line">\---</span><br><span class="line"></span><br><span class="line">\&lt;!-- 分类头部：返回首页+分类简介 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;div class&#x3D;&quot;category-header&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;&quot; class&#x3D;&quot;back-home&quot;&gt;\&lt;i class&#x3D;&quot;fas fa-arrow-left&quot;&gt;\&lt;&#x2F;i&gt; 返回工具合集\&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;h1 class&#x3D;&quot;category-title&quot;&gt;投资类工具\&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;p class&#x3D;&quot;category-intro&quot;&gt;专注于投资决策辅助，包含收益计算、风险分析、资金配置等工具，助力科学投资。\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;!-- 工具列表 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;div class&#x3D;&quot;tool-container&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;!-- 工具1：投资资金配置计算器 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;div class&#x3D;&quot;tool-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;div class&#x3D;&quot;tool-icon bg-blue-100 text-blue-600&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;i class&#x3D;&quot;fas fa-calculator fa-xl&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;h3 class&#x3D;&quot;tool-name&quot;&gt;投资资金配置计算器\&lt;&#x2F;h3&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;p class&#x3D;&quot;tool-desc&quot;&gt;输入稳钱、长钱、海外账户的年化收益和占比，实时计算综合收益，生成风险偏好配置表。\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;div class&#x3D;&quot;tool-tags&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;span class&#x3D;&quot;tag&quot;&gt;收益计算\&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;span class&#x3D;&quot;tag&quot;&gt;资金配置\&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;investment&#x2F;calculator&#x2F;&quot; class&#x3D;&quot;tool-btn&quot;&gt;立即使用 →\&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;!-- 工具2：复利收益分析器 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;div class&#x3D;&quot;tool-card&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;div class&#x3D;&quot;tool-icon bg-blue-100 text-blue-600&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;i class&#x3D;&quot;fas fa-chart-line fa-xl&quot;&gt;\&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;h3 class&#x3D;&quot;tool-name&quot;&gt;复利收益分析器\&lt;&#x2F;h3&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;p class&#x3D;&quot;tool-desc&quot;&gt;输入本金、年化收益、投资期限，计算复利终值，生成收益趋势图，直观展示“滚雪球”效果。\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;div class&#x3D;&quot;tool-tags&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;span class&#x3D;&quot;tag&quot;&gt;复利计算\&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;     \&lt;span class&#x3D;&quot;tag&quot;&gt;趋势分析\&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;investment&#x2F;compound&#x2F;&quot; class&#x3D;&quot;tool-btn&quot;&gt;立即使用 →\&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;!-- 引入公共样式 --&gt;</span><br><span class="line"></span><br><span class="line">\&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;font-awesome&#x2F;6.4.0&#x2F;css&#x2F;all.min.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">\&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;tools&#x2F;common&#x2F;css&#x2F;tool-common.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-第三步：添加工具详情页（分两种类型）"><a href="#3-4-第三步：添加工具详情页（分两种类型）" class="headerlink" title="3.4 第三步：添加工具详情页（分两种类型）"></a>3.4 第三步：添加工具详情页（分两种类型）</h3><h4 id="3-4-1-类型-1：静态-HTML-工具（如计算器，tools-investment-calculator-index-html）"><a href="#3-4-1-类型-1：静态-HTML-工具（如计算器，tools-investment-calculator-index-html）" class="headerlink" title="3.4.1 类型 1：静态 HTML 工具（如计算器，tools/investment/calculator/index.html）"></a>3.4.1 类型 1：静态 HTML 工具（如计算器，<code>tools/investment/calculator/index.html</code>）</h4><p>直接放入静态 HTML 文件，注意资源路径引用（根路径）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">\&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;</span><br><span class="line"></span><br><span class="line">\&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;title&gt;投资资金配置计算器\&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;tools&#x2F;common&#x2F;css&#x2F;tool-common.css&quot;&gt; \&lt;!-- 引用公共样式 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   &#x2F;\* 工具专属样式 \*&#x2F;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   .calculator-container &#123; padding: 20px; &#125;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   &#x2F;\* ... 其他样式 ... \*&#x2F;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">\&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;!-- 返回分类页 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;investment&#x2F;&quot; class&#x3D;&quot;back-category&quot;&gt;\&lt;i class&#x3D;&quot;fas fa-arrow-left&quot;&gt;\&lt;&#x2F;i&gt; 返回投资类工具\&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;&amp;#x20;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;!-- 工具主体 --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;div class&#x3D;&quot;calculator-container&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;h1&gt;投资资金配置计算器\&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- 工具功能代码（如输入框、计算逻辑） --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20;   \&lt;!-- ... 省略具体代码 ... --&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;script src&#x3D;&quot;&#x2F;tools&#x2F;investment&#x2F;calculator&#x2F;js&#x2F;script.js&quot;&gt;\&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-类型-2：外部链接工具（如在线-JSON-解析器，tools-coding-json-parser-index-md）"><a href="#3-4-2-类型-2：外部链接工具（如在线-JSON-解析器，tools-coding-json-parser-index-md）" class="headerlink" title="3.4.2 类型 2：外部链接工具（如在线 JSON 解析器，tools/coding/json-parser/``index.md）"></a>3.4.2 类型 2：外部链接工具（如在线 JSON 解析器，<code>tools/coding/json-parser/``index.md</code>）</h4><p>用 Markdown 配置跳转链接，无需开发静态页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\---</span><br><span class="line"></span><br><span class="line">title: JSON解析器（在线工具）</span><br><span class="line"></span><br><span class="line">date: 2025-10-21 11:00:00</span><br><span class="line"></span><br><span class="line">layout: page</span><br><span class="line"></span><br><span class="line">comments: false</span><br><span class="line"></span><br><span class="line">sidebar: false</span><br><span class="line"></span><br><span class="line">\---</span><br><span class="line"></span><br><span class="line">\&lt;div class&#x3D;&quot;external-tool&quot;&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;a href&#x3D;&quot;&#x2F;tools&#x2F;coding&#x2F;&quot; class&#x3D;&quot;back-category&quot;&gt;\&lt;i class&#x3D;&quot;fas fa-arrow-left&quot;&gt;\&lt;&#x2F;i&gt; 返回编程类工具\&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;h1&gt;JSON解析器（在线工具）\&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;p class&#x3D;&quot;tool-desc&quot;&gt;推荐一款稳定的在线JSON解析工具，支持格式化、校验、压缩功能，无需下载安装。\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.json.cn&#x2F;&quot; target&#x3D;&quot;\_blank&quot; class&#x3D;&quot;external-btn&quot;&gt;前往在线工具 →\&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&amp;#x20; \&lt;p class&#x3D;&quot;tip&quot;&gt;提示：点击按钮将跳转到外部网站，若无法访问请检查网络。\&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">\&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">\&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;tools&#x2F;common&#x2F;css&#x2F;tool-common.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-第四步：配置公共资源（统一样式与功能）"><a href="#3-5-第四步：配置公共资源（统一样式与功能）" class="headerlink" title="3.5 第四步：配置公共资源（统一样式与功能）"></a>3.5 第四步：配置公共资源（统一样式与功能）</h3><h4 id="3-5-1-公共-CSS（tools-common-css-tool-common-css）"><a href="#3-5-1-公共-CSS（tools-common-css-tool-common-css）" class="headerlink" title="3.5.1 公共 CSS（tools/common/css/tool-common.css）"></a>3.5.1 公共 CSS（<code>tools/common/css/tool-common.css</code>）</h4><p>统一所有页面的样式，避免重复编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;\* 基础重置 \*&#x2F;</span><br><span class="line"></span><br><span class="line">\* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;</span><br><span class="line"></span><br><span class="line">body &#123; font-family: &quot;Microsoft YaHei&quot;, sans-serif; background: #f9fafb; color: #374151; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;\* 搜索框样式 \*&#x2F;</span><br><span class="line"></span><br><span class="line">.tool-search &#123; max-width: 800px; margin: 0 auto 40px; position: relative; &#125;</span><br><span class="line"></span><br><span class="line">\#searchInput &#123; width: 100%; padding: 12px 16px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 16px; &#125;</span><br><span class="line"></span><br><span class="line">\#searchBtn &#123; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #6b7280; cursor: pointer; &#125;</span><br><span class="line"></span><br><span class="line">.search-result &#123; position: absolute; top: 100%; left: 0; width: 100%; background: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); z-index: 10; padding: 16px; margin-top: 8px; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;\* 分类卡片样式 \*&#x2F;</span><br><span class="line"></span><br><span class="line">.category-cards &#123; display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 24px; max-width: 1200px; margin: 0 auto; &#125;</span><br><span class="line"></span><br><span class="line">.category-card &#123; background: #fff; border-radius: 12px; padding: 24px; text-decoration: none; color: inherit; transition: transform 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.03); &#125;</span><br><span class="line"></span><br><span class="line">.category-card:hover &#123; transform: translateY(-5px); &#125;</span><br><span class="line"></span><br><span class="line">.category-icon &#123; width: 64px; height: 64px; border-radius: 16px; display: flex; align-items: center; justify-content: center; margin-bottom: 16px; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;\* 工具卡片样式 \*&#x2F;</span><br><span class="line"></span><br><span class="line">.tool-container &#123; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px; max-width: 1200px; margin: 30px auto 0; padding: 0 20px; &#125;</span><br><span class="line"></span><br><span class="line">.tool-card &#123; background: #fff; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.03); &#125;</span><br><span class="line"></span><br><span class="line">.tool-btn &#123; display: inline-block; margin-top: 20px; padding: 10px 20px; background: #3b82f6; color: #fff; border-radius: 8px; text-decoration: none; font-weight: 500; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;\* 返回按钮样式 \*&#x2F;</span><br><span class="line"></span><br><span class="line">.back-home, .back-category &#123; display: inline-block; margin-bottom: 20px; color: #3b82f6; text-decoration: none; font-size: 14px; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;\* 响应式适配 \*&#x2F;</span><br><span class="line"></span><br><span class="line">@media (max-width: 768px) &#123;</span><br><span class="line"></span><br><span class="line">&amp;#x20; .category-cards, .tool-container &#123; grid-template-columns: 1fr; gap: 16px; padding: 0 16px; &#125;</span><br><span class="line"></span><br><span class="line">&amp;#x20; .tool-search &#123; padding: 0 16px; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、功能扩展与进阶配置"><a href="#四、功能扩展与进阶配置" class="headerlink" title="四、功能扩展与进阶配置"></a>四、功能扩展与进阶配置</h2><h3 id="4-1-搜索功能完善（tool-search-js-实现）"><a href="#4-1-搜索功能完善（tool-search-js-实现）" class="headerlink" title="4.1 搜索功能完善（tool-search.js 实现）"></a>4.1 搜索功能完善（<code>tool-search.js</code> 实现）</h3><p>搜索功能需支持跨分类检索工具，匹配工具名称、描述及标签，实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tools/common/js/tool-search.js</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> searchInput = <span class="built_in">document</span>.getElementById(<span class="string">'searchInput'</span>);</span><br><span class="line">  <span class="keyword">const</span> searchBtn = <span class="built_in">document</span>.getElementById(<span class="string">'searchBtn'</span>);</span><br><span class="line">  <span class="keyword">const</span> searchResult = <span class="built_in">document</span>.getElementById(<span class="string">'searchResult'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 工具数据索引（需手动维护，新增工具时同步更新）</span></span><br><span class="line">  <span class="keyword">const</span> toolIndex = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'投资资金配置计算器'</span>,</span><br><span class="line">      desc: <span class="string">'输入稳钱、长钱、海外账户的年化收益和占比，实时计算综合收益'</span>,</span><br><span class="line">      category: <span class="string">'投资类'</span>,</span><br><span class="line">      tags: [<span class="string">'收益计算'</span>, <span class="string">'资金配置'</span>],</span><br><span class="line">      url: <span class="string">'/tools/investment/calculator/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'复利收益分析器'</span>,</span><br><span class="line">      desc: <span class="string">'输入本金、年化收益、投资期限，计算复利终值并生成趋势图'</span>,</span><br><span class="line">      category: <span class="string">'投资类'</span>,</span><br><span class="line">      tags: [<span class="string">'复利计算'</span>, <span class="string">'趋势分析'</span>],</span><br><span class="line">      url: <span class="string">'/tools/investment/compound/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'代码格式化工具'</span>,</span><br><span class="line">      desc: <span class="string">'支持多语言代码格式化，自动调整缩进和语法结构'</span>,</span><br><span class="line">      category: <span class="string">'编程类'</span>,</span><br><span class="line">      tags: [<span class="string">'代码处理'</span>, <span class="string">'格式化'</span>],</span><br><span class="line">      url: <span class="string">'/tools/coding/formatter/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'JSON解析器（在线工具）'</span>,</span><br><span class="line">      desc: <span class="string">'在线解析JSON数据，支持格式化、校验和压缩'</span>,</span><br><span class="line">      category: <span class="string">'编程类'</span>,</span><br><span class="line">      tags: [<span class="string">'数据处理'</span>, <span class="string">'JSON'</span>],</span><br><span class="line">      url: <span class="string">'/tools/coding/json-parser/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增工具需在此处添加对应数据</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索逻辑</span></span><br><span class="line">  <span class="keyword">const</span> searchTools = <span class="function">(<span class="params">keyword</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyword.trim()) &#123;</span><br><span class="line">      searchResult.classList.add(<span class="string">'hidden'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> lowerKeyword = keyword.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> results = toolIndex.filter(<span class="function"><span class="params">tool</span> =&gt;</span> </span><br><span class="line">      tool.name.toLowerCase().includes(lowerKeyword) || </span><br><span class="line">      tool.desc.toLowerCase().includes(lowerKeyword) ||</span><br><span class="line">      tool.tags.some(<span class="function"><span class="params">tag</span> =&gt;</span> tag.toLowerCase().includes(lowerKeyword))</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    renderResults(results);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染搜索结果</span></span><br><span class="line">  <span class="keyword">const</span> renderResults = <span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (results.length === <span class="number">0</span>) &#123;</span><br><span class="line">      searchResult.innerHTML = <span class="string">'&lt;p class="no-result"&gt;未找到匹配的工具，请尝试其他关键词&lt;/p&gt;'</span>;</span><br><span class="line">      searchResult.classList.remove(<span class="string">'hidden'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">'&lt;ul class="result-list"&gt;'</span>;</span><br><span class="line">    results.forEach(<span class="function"><span class="params">tool</span> =&gt;</span> &#123;</span><br><span class="line">      html += <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;li class="result-item"&gt;</span></span><br><span class="line"><span class="string">          &lt;a href="<span class="subst">$&#123;tool.url&#125;</span>" class="result-link"&gt;</span></span><br><span class="line"><span class="string">            &lt;h4&gt;<span class="subst">$&#123;tool.name&#125;</span>&lt;/h4&gt;</span></span><br><span class="line"><span class="string">            &lt;p class="result-desc"&gt;<span class="subst">$&#123;tool.desc&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;span class="result-category"&gt;<span class="subst">$&#123;tool.category&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">          &lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    html += <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line">    </span><br><span class="line">    searchResult.innerHTML = html;</span><br><span class="line">    searchResult.classList.remove(<span class="string">'hidden'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件绑定</span></span><br><span class="line">  searchBtn.addEventListener(<span class="string">'click'</span>, () =&gt; searchTools(searchInput.value));</span><br><span class="line">  searchInput.addEventListener(<span class="string">'keyup'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) searchTools(searchInput.value);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 点击页面其他区域关闭搜索结果</span></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!searchInput.contains(e.target) &amp;&amp; !searchResult.contains(e.target) &amp;&amp; !searchBtn.contains(e.target)) &#123;</span><br><span class="line">      searchResult.classList.add(<span class="string">'hidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-工具排序功能实现（分类页扩展）"><a href="#4-2-工具排序功能实现（分类页扩展）" class="headerlink" title="4.2 工具排序功能实现（分类页扩展）"></a>4.2 工具排序功能实现（分类页扩展）</h3><p>在分类页添加排序功能，支持按「热门程度」和「最新添加」排序：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在分类页（如investment/index.md）的category-header中添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sort-controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>排序方式：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"sort-btn active"</span> <span class="attr">data-sort</span>=<span class="string">"hot"</span>&gt;</span>热门程度<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"sort-btn"</span> <span class="attr">data-sort</span>=<span class="string">"new"</span>&gt;</span>最新添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对应CSS（添加到tool-common.css） --&gt;</span></span><br><span class="line">.sort-controls &#123; margin: 16px 0; &#125;</span><br><span class="line">.sort-btn &#123; </span><br><span class="line">  background: #f3f4f6; </span><br><span class="line">  border: none; </span><br><span class="line">  padding: 6px 12px; </span><br><span class="line">  border-radius: 4px; </span><br><span class="line">  margin-left: 8px; </span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.sort-btn.active &#123; </span><br><span class="line">  background: #3b82f6; </span><br><span class="line">  color: white; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 排序功能脚本（可单独创建tool-sort.js或添加到现有脚本） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> sortBtns = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.sort-btn'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> toolContainer = <span class="built_in">document</span>.querySelector(<span class="string">'.tool-container'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> toolCards = <span class="built_in">Array</span>.from(toolContainer.children);</span></span><br><span class="line">  </span><br><span class="line"><span class="actionscript">  <span class="comment">// 为工具卡片添加数据属性（实际使用时根据工具真实信息设置）</span></span></span><br><span class="line"><span class="actionscript">  toolCards[<span class="number">0</span>].setAttribute(<span class="string">'data-hot'</span>, <span class="string">'98'</span>); <span class="comment">// 热门指数</span></span></span><br><span class="line"><span class="actionscript">  toolCards[<span class="number">0</span>].setAttribute(<span class="string">'data-date'</span>, <span class="string">'2025-10-15'</span>); <span class="comment">// 创建日期</span></span></span><br><span class="line"><span class="actionscript">  toolCards[<span class="number">1</span>].setAttribute(<span class="string">'data-hot'</span>, <span class="string">'85'</span>);</span></span><br><span class="line"><span class="actionscript">  toolCards[<span class="number">1</span>].setAttribute(<span class="string">'data-date'</span>, <span class="string">'2025-10-20'</span>);</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  sortBtns.forEach(<span class="function"><span class="params">btn</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 更新按钮状态</span></span></span><br><span class="line"><span class="javascript">      sortBtns.forEach(<span class="function"><span class="params">b</span> =&gt;</span> b.classList.remove(<span class="string">'active'</span>));</span></span><br><span class="line"><span class="actionscript">      btn.classList.add(<span class="string">'active'</span>);</span></span><br><span class="line">      </span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> sortType = btn.getAttribute(<span class="string">'data-sort'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> sortedCards;</span></span><br><span class="line">      </span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (sortType === <span class="string">'hot'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 按热门指数降序</span></span></span><br><span class="line"><span class="javascript">        sortedCards = [...toolCards].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> </span></span><br><span class="line"><span class="actionscript">          b.getAttribute(<span class="string">'data-hot'</span>) - a.getAttribute(<span class="string">'data-hot'</span>)</span></span><br><span class="line">        );</span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 按日期降序（最新在前）</span></span></span><br><span class="line"><span class="javascript">        sortedCards = [...toolCards].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> </span></span><br><span class="line"><span class="javascript">          <span class="keyword">new</span> <span class="built_in">Date</span>(b.getAttribute(<span class="string">'data-date'</span>)) - <span class="keyword">new</span> <span class="built_in">Date</span>(a.getAttribute(<span class="string">'data-date'</span>))</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="actionscript">      <span class="comment">// 重新渲染排序后的卡片</span></span></span><br><span class="line"><span class="javascript">      sortedCards.forEach(<span class="function"><span class="params">card</span> =&gt;</span> toolContainer.appendChild(card));</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、新增分类与工具的规范流程"><a href="#五、新增分类与工具的规范流程" class="headerlink" title="五、新增分类与工具的规范流程"></a>五、新增分类与工具的规范流程</h2><h3 id="5-1-新增分类步骤"><a href="#5-1-新增分类步骤" class="headerlink" title="5.1 新增分类步骤"></a>5.1 新增分类步骤</h3><ol>
<li><p><strong>创建目录结构</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以新增"生活类"工具为例</span></span><br><span class="line"><span class="built_in">cd</span> hexo-blog/<span class="built_in">source</span>/tools</span><br><span class="line">mkdir -p life  <span class="comment"># 创建分类目录</span></span><br><span class="line">touch life/index.md  <span class="comment"># 创建分类页</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置分类页</strong><br>复制现有分类页（如<code>investment/index.md</code>）内容，修改以下字段：</p>
<ul>
<li><code>title</code>：分类名称（如”生活类工具”）</li>
<li><code>category-title</code>：同分类名称</li>
<li><code>category-intro</code>：分类描述</li>
<li>工具卡片区域清空，后续添加该分类下的工具</li>
</ul>
</li>
<li><p><strong>在工具首页添加分类导航</strong><br>在<code>tools/index.md</code>的<code>category-cards</code>区域复制现有分类卡片，修改：</p>
<ul>
<li><code>href</code>：指向新分类目录（如”/tools/life/“）</li>
<li><code>category-icon</code>：更换图标（参考Font Awesome图标库）</li>
<li><code>category-name</code>和<code>category-desc</code>：更新为新分类信息</li>
</ul>
</li>
</ol>
<h3 id="5-2-新增工具步骤"><a href="#5-2-新增工具步骤" class="headerlink" title="5.2 新增工具步骤"></a>5.2 新增工具步骤</h3><p>根据工具类型选择对应方式：</p>
<h4 id="5-2-1-新增静态HTML工具"><a href="#5-2-1-新增静态HTML工具" class="headerlink" title="5.2.1 新增静态HTML工具"></a>5.2.1 新增静态HTML工具</h4><ol>
<li>创建工具目录：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p tools/life/weather-forecast  <span class="comment"># 以生活类的"天气预报工具"为例</span></span><br></pre></td></tr></table></figure></li>
<li>在目录中创建<code>index.html</code>，参考3.4.1的模板格式</li>
<li>在对应分类页（<code>life/index.md</code>）添加工具卡片</li>
<li>在<code>tool-search.js</code>的<code>toolIndex</code>中添加工具索引数据</li>
</ol>
<h4 id="5-2-2-新增外部链接工具"><a href="#5-2-2-新增外部链接工具" class="headerlink" title="5.2.2 新增外部链接工具"></a>5.2.2 新增外部链接工具</h4><ol>
<li>创建工具目录及配置文件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p tools/life/map-tools</span><br><span class="line">touch tools/life/map-tools/index.md</span><br></pre></td></tr></table></figure></li>
<li>参考3.4.2的模板配置<code>index.md</code>，修改链接和描述</li>
<li>在对应分类页添加工具卡片</li>
<li>在<code>tool-search.js</code>的<code>toolIndex</code>中添加工具索引数据</li>
</ol>
<h2 id="六、常见问题与解决方案"><a href="#六、常见问题与解决方案" class="headerlink" title="六、常见问题与解决方案"></a>六、常见问题与解决方案</h2><h3 id="6-1-路径引用问题"><a href="#6-1-路径引用问题" class="headerlink" title="6.1 路径引用问题"></a>6.1 路径引用问题</h3><ul>
<li><strong>现象</strong>：CSS/JS资源加载失败，工具页面样式错乱</li>
<li><strong>解决方案</strong>：<ul>
<li>确保所有资源引用使用根路径（以<code>/</code>开头），如<code>/tools/common/css/tool-common.css</code></li>
<li>本地调试时使用<code>hexo server</code>命令启动服务，避免直接打开HTML文件</li>
</ul>
</li>
</ul>
<h3 id="6-2-搜索功能不生效"><a href="#6-2-搜索功能不生效" class="headerlink" title="6.2 搜索功能不生效"></a>6.2 搜索功能不生效</h3><ul>
<li><strong>现象</strong>：搜索关键词无结果或结果错误</li>
<li><strong>解决方案</strong>：<ul>
<li>检查<code>tool-search.js</code>中的<code>toolIndex</code>是否包含对应工具数据</li>
<li>确保关键词匹配逻辑正确（名称、描述、标签均需检查）</li>
<li>清除浏览器缓存后重新测试</li>
</ul>
</li>
</ul>
<h3 id="6-3-响应式适配问题"><a href="#6-3-响应式适配问题" class="headerlink" title="6.3 响应式适配问题"></a>6.3 响应式适配问题</h3><ul>
<li><strong>现象</strong>：移动端页面布局错乱</li>
<li><strong>解决方案</strong>：<ul>
<li>检查CSS中<code>@media (max-width: 768px)</code>的响应式配置</li>
<li>确保工具卡片使用<code>grid-template-columns: repeat(auto-fit, minmax(300px, 1fr))</code>实现自适应</li>
</ul>
</li>
</ul>
<h2 id="七、版本迭代记录"><a href="#七、版本迭代记录" class="headerlink" title="七、版本迭代记录"></a>七、版本迭代记录</h2><table>
<thead>
<tr>
<th>版本</th>
<th>日期</th>
<th>更新内容</th>
</tr>
</thead>
<tbody><tr>
<td>v1.0</td>
<td>2025-10-21</td>
<td>基础框架搭建，支持3大分类共6个工具</td>
</tr>
<tr>
<td>v1.1</td>
<td>2025-10-28</td>
<td>新增搜索功能和工具排序功能</td>
</tr>
<tr>
<td>v1.2</td>
<td>2025-11-05</td>
<td>完善响应式适配，添加生活类分类</td>
</tr>
</tbody></table>
<h2 id="八、未来扩展方向"><a href="#八、未来扩展方向" class="headerlink" title="八、未来扩展方向"></a>八、未来扩展方向</h2><ol>
<li><strong>自动化索引生成</strong>：通过Hexo插件自动扫描工具目录生成<code>toolIndex</code>数据，避免手动维护</li>
<li><strong>用户反馈功能</strong>：为每个工具添加评分和评论功能，提升工具质量</li>
<li><strong>工具收藏夹</strong>：通过本地存储实现用户个性化工具收藏</li>
<li><strong>多语言支持</strong>：添加中英文切换功能，适配国际化需求</li>
</ol>
<p>通过以上完善，该方案不仅实现了基础的工具分类与管理功能，还通过搜索、排序等增强功能提升了用户体验，同时提供了清晰的扩展规范，方便后续持续迭代升级。</p>
]]></content>
  </entry>
</search>
