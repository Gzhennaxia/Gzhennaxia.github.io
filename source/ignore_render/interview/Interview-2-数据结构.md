## 数据结构

### 布隆过滤器

布隆过滤器是一种用来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。

布隆过滤器（Bloom Filter）是由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。

#### 插入操作

1. 使用哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

#### 判断一个元素是否存在

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。

#### 使用场景

1. 判断给定数据是否存在：
    
    - 比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）
    - 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）
    - 邮箱的垃圾邮件过滤
    - 黑名单功能

2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。

#### 实现

##### Google Guava 的布隆过滤器

创建了一个最多存放 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之一（0.01）

```java
// 创建布隆过滤器对象
BloomFilter<Integer> filter = BloomFilter.create(
  Funnels.integerFunnel(),
  1500,
  0.01);
// 判断指定元素是否存在
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
// 将元素添加进布隆过滤器
filter.put(1);
filter.put(2);
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
```

##### Redis 中的布隆过滤器

Guava 提供的布隆过滤器的实现只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，就需要用到 Redis 中的布隆过滤器了。

Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。

官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module。

###### 常用命令

1. **`BF.ADD `**：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：`BF.ADD {key} {item}`。
2. **`BF.MADD `**: 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式`BF.ADD`与之相同，只不过它允许多个输入并返回多个值。格式：`BF.MADD {key} {item} [item ...]` 。
3. **`BF.EXISTS`** : 确定元素是否在布隆过滤器中存在。格式：`BF.EXISTS {key} {item}`。
4. **`BF.MEXISTS`** ： 确定一个或者多个元素是否在布隆过滤器中存在格式：`BF.MEXISTS {key} {item} [item ...]`。

###### 使用

```bash
127.0.0.1:6379> BF.ADD myFilter java
(integer) 1
127.0.0.1:6379> BF.ADD myFilter javaguide
(integer) 1
127.0.0.1:6379> BF.EXISTS myFilter java
(integer) 1
127.0.0.1:6379> BF.EXISTS myFilter javaguide
(integer) 1
127.0.0.1:6379> BF.EXISTS myFilter github
(integer) 0
```

### B 树

B树（balance tree）可以认为是 m 叉的多路平衡查找树



### B+ 树

#### B树和B+树的区别

> [b树和b+树的区别](https://blog.csdn.net/login_sonata/article/details/75268075)

- B+树的中间节点不保存数据，只在叶子结点中保存数据；而B树数据分布在整颗树中。
- B+树的叶子结点按顺序链接，可以很方便的进行**范围查找**。

### 红黑树

#### 5 个特性

1. 每个节点要么是红色，要么是黑色；
2. 根节点永远是黑色的；
3. 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；
4. 每个红色节点的两个子节点一定都是黑色；
5. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

HashMap 为什么要使用红黑树？

红黑树是基于二叉查找树的改造，二叉查找树具有平衡性和有序性的特点，能够支持快速的查找功能，但完全平衡树的维护成本比较高，红黑树采用的“适度平衡”标准，可以保证每次插入或删除操作后的重平衡过程，全树拓扑结构的更新仅涉及常数个节点。**尽管最坏情况下需对多达logn个节点重染色，但就分摊意义而言仅为O(1)个。**

